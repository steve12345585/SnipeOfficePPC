diff -uprN misc/vigra1.4.0/configure misc/build/vigra1.4.0/configure
--- misc/vigra1.4.0/configure	Tue Dec 20 23:53:28 2005
+++ misc/build/vigra1.4.0/configure	Wed Apr  4 20:35:48 2007
@@ -7259,7 +7259,7 @@ kfreebsd*-gnu)
   ;;
 
 freebsd*)
-  objformat=`test -x /usr/bin/objformat && /usr/bin/objformat || echo aout`
+  objformat=`test -x /usr/bin/objformat && /usr/bin/objformat || echo elf`
   version_type=freebsd-$objformat
   case $version_type in
     freebsd-elf*)
@@ -10961,7 +10961,7 @@ kfreebsd*-gnu)
   ;;
 
 freebsd*)
-  objformat=`test -x /usr/bin/objformat && /usr/bin/objformat || echo aout`
+  objformat=`test -x /usr/bin/objformat && /usr/bin/objformat || echo elf`
   version_type=freebsd-$objformat
   case $version_type in
     freebsd-elf*)
@@ -14110,7 +14110,7 @@ kfreebsd*-gnu)
   ;;
 
 freebsd*)
-  objformat=`test -x /usr/bin/objformat && /usr/bin/objformat || echo aout`
+  objformat=`test -x /usr/bin/objformat && /usr/bin/objformat || echo elf`
   version_type=freebsd-$objformat
   case $version_type in
     freebsd-elf*)
@@ -16461,7 +16461,7 @@ kfreebsd*-gnu)
   ;;
 
 freebsd*)
-  objformat=`test -x /usr/bin/objformat && /usr/bin/objformat || echo aout`
+  objformat=`test -x /usr/bin/objformat && /usr/bin/objformat || echo elf`
   version_type=freebsd-$objformat
   case $version_type in
     freebsd-elf*)
diff -uprN misc/vigra1.4.0/include/vigra/array_vector.hxx misc/build/vigra1.4.0/include/vigra/array_vector.hxx
--- misc/vigra1.4.0/include/vigra/array_vector.hxx	2005-12-21 05:53:30.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/array_vector.hxx	2006-08-31 12:08:15.172679000 +0200
@@ -196,7 +196,38 @@ public:
     iterator insert(iterator p, size_type n, value_type const & v);
 
     template <class InputIterator>
-    iterator insert(iterator p, InputIterator i, InputIterator iend);
+    iterator insert(iterator p, InputIterator i, InputIterator iend)
+    {
+        difference_type n = iend - i;
+        difference_type pos = p - begin();
+        size_type new_size = size() + n;
+        if(new_size >= capacity_)
+        {
+            pointer new_data = reserve_raw(new_size);
+            std::uninitialized_copy(begin(), p, new_data);
+            std::uninitialized_copy(i, iend, new_data + pos);
+            std::uninitialized_copy(p, end(), new_data + pos + n);
+            deallocate(data_, size_);
+            capacity_ = new_size;
+            data_ = new_data;
+        }
+        else if(pos + n >= size_)
+        {
+            size_type diff = pos + n - size_;
+            std::uninitialized_copy(p, end(), end() + diff);
+            std::uninitialized_copy(iend - diff, iend, end());
+            std::copy(i, iend - diff, p);
+        }
+        else
+        {
+            size_type diff = size_ - (pos + n);
+            std::uninitialized_copy(end() - n, end(), end());
+            std::copy_backward(p, p + diff, end());
+            std::copy(i, iend, p);
+        }
+        size_ = new_size;
+        return begin() + pos;
+    }
 
     iterator erase(iterator p);
 
@@ -260,23 +291,23 @@ ArrayVector<T, Alloc>::ArrayVector(Alloc
 {}
 
 template <class T, class Alloc>
-ArrayVector<T, Alloc>::ArrayVector( size_type size, Alloc const & alloc)
+ArrayVector<T, Alloc>::ArrayVector( size_type sz, Alloc const & alloc)
 : alloc_(alloc),
-  size_(size),
-  capacity_(size),
-  data_(reserve_raw(size))
+  size_(sz),
+  capacity_(sz),
+  data_(reserve_raw(sz))
 {
     if(size_ > 0)
         std::uninitialized_fill(data_, data_+size_, value_type());
 }
 
 template <class T, class Alloc>
-ArrayVector<T, Alloc>::ArrayVector( size_type size, 
+ArrayVector<T, Alloc>::ArrayVector( size_type sz, 
                          value_type const & initial, Alloc const & alloc)
 : alloc_(alloc),
-  size_(size),
-  capacity_(size),
-  data_(reserve_raw(size))
+  size_(sz),
+  capacity_(sz),
+  data_(reserve_raw(sz))
 {
     if(size_ > 0)
         std::uninitialized_fill(data_, data_+size_, initial);
@@ -295,24 +326,24 @@ ArrayVector<T, Alloc>::ArrayVector( this
 
 template <class T, class Alloc>
 template <class InputIterator>
-ArrayVector<T, Alloc>::ArrayVector(InputIterator i, InputIterator end)
+ArrayVector<T, Alloc>::ArrayVector(InputIterator i, InputIterator iend)
 : alloc_(),
-  size_(std::distance(i, end)),
+  size_(std::distance(i, iend)),
   capacity_(size_),
   data_(reserve_raw(size_))
 {
-    std::uninitialized_copy(i, end, data_);
+    std::uninitialized_copy(i, iend, data_);
 }
 
 template <class T, class Alloc>
 template <class InputIterator>
-ArrayVector<T, Alloc>::ArrayVector(InputIterator i, InputIterator end, Alloc const & alloc)
+ArrayVector<T, Alloc>::ArrayVector(InputIterator i, InputIterator iend, Alloc const & alloc)
 : alloc_(alloc),
-  size_(std::distance(i, end)),
+  size_(std::distance(i, iend)),
   capacity_(size_),
   data_(reserve_raw(size_))
 {
-    std::uninitialized_copy(i, end, data_);
+    std::uninitialized_copy(i, iend, data_);
 }
 
 
@@ -409,42 +440,6 @@ ArrayVector<T, Alloc>::insert(iterator p
 }
 
 template <class T, class Alloc>
-template <class InputIterator>
-typename ArrayVector<T, Alloc>::iterator
-ArrayVector<T, Alloc>::insert(iterator p, InputIterator i, InputIterator iend)
-{
-    difference_type n = iend - i;
-    difference_type pos = p - begin();
-    size_type new_size = size() + n;
-    if(new_size >= capacity_)
-    {
-        pointer new_data = reserve_raw(new_size);
-        std::uninitialized_copy(begin(), p, new_data);
-        std::uninitialized_copy(i, iend, new_data + pos);
-        std::uninitialized_copy(p, end(), new_data + pos + n);
-        deallocate(data_, size_);
-        capacity_ = new_size;
-        data_ = new_data;
-    }
-    else if(pos + n >= size_)
-    {
-        size_type diff = pos + n - size_;
-        std::uninitialized_copy(p, end(), end() + diff);
-        std::uninitialized_copy(iend - diff, iend, end());
-        std::copy(i, iend - diff, p);
-    }
-    else
-    {
-        size_type diff = size_ - (pos + n);
-        std::uninitialized_copy(end() - n, end(), end());
-        std::copy_backward(p, p + diff, end());
-        std::copy(i, iend, p);
-    }
-    size_ = new_size;
-    return begin() + pos;
-}
-
-template <class T, class Alloc>
 typename ArrayVector<T, Alloc>::iterator
 ArrayVector<T, Alloc>::erase(iterator p)
 {
@@ -504,25 +499,25 @@ void ArrayVector<T, Alloc>::swap(this_ty
 }
 
 template <class T, class Alloc>
-void ArrayVector<T, Alloc>::deallocate(pointer data, size_type size)
+void ArrayVector<T, Alloc>::deallocate(pointer target_data, size_type sz)
 {
     if(data)
     {
-        detail::destroy_n(data, size);
-        alloc_.deallocate(data, size);
+        detail::destroy_n(target_data, sz);
+        alloc_.deallocate(target_data, sz);
     }
 }
 
 template <class T, class Alloc>
 typename ArrayVector<T, Alloc>::pointer
-ArrayVector<T, Alloc>::reserve_raw(size_type capacity)
+ArrayVector<T, Alloc>::reserve_raw(size_type cap)
 {
-    pointer data = 0;
-    if(capacity)
+    pointer new_data = 0;
+    if(cap)
     {
-        data = alloc_.allocate(capacity);
+        new_data = alloc_.allocate(cap);
     }
-    return data;
+    return new_data;
 }
 
 } // namespace vigra
diff -uprN misc/vigra1.4.0/include/vigra/basicimage.hxx misc/build/vigra1.4.0/include/vigra/basicimage.hxx
--- misc/vigra1.4.0/include/vigra/basicimage.hxx	2005-12-21 05:53:30.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/basicimage.hxx	2006-08-31 12:08:15.194050000 +0200
@@ -552,7 +552,11 @@ class BasicImage
     typedef Alloc allocator_type;
 
     typedef Alloc Allocator;
+#ifndef VIGRA_WITHOUT_NESTED_TEMPLATE_PARAMS
     typedef typename Alloc::template rebind<PIXELTYPE *>::other LineAllocator;
+#else
+    typedef std::allocator<PIXELTYPE*> LineAllocator;
+#endif
 
         /** construct image of size 0x0
         */
@@ -569,39 +573,51 @@ class BasicImage
       width_(0),
       height_(0),
       allocator_(alloc),
+#ifndef VIGRA_WITHOUT_NESTED_TEMPLATE_PARAMS
       pallocator_(alloc)
+#else
+      pallocator_()
+#endif
     {}
 
         /** construct image of size width x height, use the specified allocator.
         */
-    BasicImage(int width, int height, Alloc const & alloc = Alloc())
+    BasicImage(int w, int h, Alloc const & alloc = Alloc())
     : data_(0),
       width_(0),
       height_(0),
       allocator_(alloc),
+#ifndef VIGRA_WITHOUT_NESTED_TEMPLATE_PARAMS
       pallocator_(alloc)
+#else
+      pallocator_()
+#endif
     {
-        vigra_precondition((width >= 0) && (height >= 0),
-             "BasicImage::BasicImage(int width, int height): "
+        vigra_precondition((w >= 0) && (h >= 0),
+             "BasicImage::BasicImage(int w, int h): "
              "width and height must be >= 0.\n");
 
-        resize(width, height, value_type());
+        resize(w, h, value_type());
     }
 
         /** construct image of size size.x x size.y, use the specified allocator.
         */
-    explicit BasicImage(difference_type const & size, Alloc const & alloc = Alloc())
+    explicit BasicImage(difference_type const & sz, Alloc const & alloc = Alloc())
     : data_(0),
       width_(0),
       height_(0),
       allocator_(alloc),
+#ifndef VIGRA_WITHOUT_NESTED_TEMPLATE_PARAMS
       pallocator_(alloc)
-    {
-        vigra_precondition((size.x >= 0) && (size.y >= 0),
-             "BasicImage::BasicImage(Diff2D size): "
-             "size.x and size.y must be >= 0.\n");
+#else
+      pallocator_()
+#endif
+    {
+        vigra_precondition((sz.x >= 0) && (sz.y >= 0),
+             "BasicImage::BasicImage(Diff2D sz): "
+             "sz.x and sz.y must be >= 0.\n");
 
-        resize(size.x, size.y, value_type());
+        resize(sz.x, sz.y, value_type());
     }
 
         /** construct image of size width*height and initialize every
@@ -609,71 +625,87 @@ class BasicImage
         value_type doesn't have a default constructor). 
         Use the specified allocator.
         */
-    BasicImage(int width, int height, value_type const & d, Alloc const & alloc = Alloc())
+    BasicImage(int w, int h, value_type const & d, Alloc const & alloc = Alloc())
     : data_(0),
       width_(0),
       height_(0),
       allocator_(alloc),
+#ifndef VIGRA_WITHOUT_NESTED_TEMPLATE_PARAMS
       pallocator_(alloc)
+#else
+      pallocator_()
+#endif
     {
-        vigra_precondition((width >= 0) && (height >= 0),
-             "BasicImage::BasicImage(int width, int height, value_type const & ): "
+        vigra_precondition((w >= 0) && (h >= 0),
+             "BasicImage::BasicImage(int w, int h, value_type const & ): "
              "width and height must be >= 0.\n");
 
-        resize(width, height, d);
+        resize(w, h, d);
     }
 
         /** construct image of size size.x x size.y and initialize
         every pixel with given data (use this constructor, if
         value_type doesn't have a default constructor). Use the specified allocator.
         */
-    explicit BasicImage(difference_type const & size, value_type const & d, Alloc const & alloc = Alloc())
+    explicit BasicImage(difference_type const & sz, value_type const & d, Alloc const & alloc = Alloc())
     : data_(0),
       width_(0),
       height_(0),
       allocator_(alloc),
+#ifndef VIGRA_WITHOUT_NESTED_TEMPLATE_PARAMS
       pallocator_(alloc)
-    {
-        vigra_precondition((size.x >= 0) && (size.y >= 0),
-             "BasicImage::BasicImage(Diff2D const & size, value_type const & v): "
-             "size.x and size.y must be >= 0.\n");
+#else
+      pallocator_()
+#endif
+    {
+        vigra_precondition((sz.x >= 0) && (sz.y >= 0),
+             "BasicImage::BasicImage(Diff2D const & sz, value_type const & v): "
+             "sz.x and sz.y must be >= 0.\n");
 
-        resize(size.x, size.y, d);
+        resize(sz.x, sz.y, d);
     }
 
 
         /** construct image of size width*height and copy the data from the
             given C-style array \a d. Use the specified allocator.
         */
-    BasicImage(int width, int height, const_pointer d, Alloc const & alloc = Alloc())
+    BasicImage(int w, int h, const_pointer d, Alloc const & alloc = Alloc())
     : data_(0),
       width_(0),
       height_(0),
       allocator_(alloc),
+#ifndef VIGRA_WITHOUT_NESTED_TEMPLATE_PARAMS
       pallocator_(alloc)
+#else
+      pallocator_()
+#endif
     {
-        vigra_precondition((width >= 0) && (height >= 0),
-             "BasicImage::BasicImage(int width, int height, const_pointer ): "
+        vigra_precondition((w >= 0) && (h >= 0),
+             "BasicImage::BasicImage(int w, int h, const_pointer ): "
              "width and height must be >= 0.\n");
 
-        resizeCopy(width, height, d);
+        resizeCopy(w, h, d);
     }
 
         /** construct image of size size.x x size.y  and copy the data from the
             given C-style array. Use the specified allocator.
         */
-    explicit BasicImage(difference_type const & size, const_pointer d, Alloc const & alloc = Alloc())
+    explicit BasicImage(difference_type const & sz, const_pointer d, Alloc const & alloc = Alloc())
     : data_(0),
       width_(0),
       height_(0),
       allocator_(alloc),
+#ifndef VIGRA_WITHOUT_NESTED_TEMPLATE_PARAMS
       pallocator_(alloc)
-    {
-        vigra_precondition((size.x >= 0) && (size.y >= 0),
-             "BasicImage::BasicImage(Diff2D const & size, const_pointer): "
-             "size.x and size.y must be >= 0.\n");
+#else
+      pallocator_()
+#endif
+    {
+        vigra_precondition((sz.x >= 0) && (sz.y >= 0),
+             "BasicImage::BasicImage(Diff2D const & sz, const_pointer): "
+             "sz.x and sz.y must be >= 0.\n");
 
-        resizeCopy(size.x, size.y, d);
+        resizeCopy(sz.x, sz.y, d);
     }
 
         /** copy rhs image
@@ -710,20 +742,20 @@ class BasicImage
         /** reset image to specified size (dimensions must not be negative)
             (old data are kept if new size matches old size)
         */
-    void resize(int width, int height)
+    void resize(int w, int h)
     {
-        if(width != width_ || height != height_)
-            resize(width, height, value_type());
+        if(w != width_ || h != height_)
+            resize(w, h, value_type());
     }
 
         /** reset image to specified size (dimensions must not be negative)
             (old data are kept if new size matches old size)
         */
-    void resize(difference_type const & size)
+    void resize(difference_type const & sz)
     {
-        if(size.x != width_ || size.y != height_)
+        if(sz.x != width_ || sz.y != height_)
         {
-            resize(size.x, size.y, value_type());
+            resize(sz.x, sz.y, value_type());
         }
     }
 
@@ -732,12 +764,12 @@ class BasicImage
             constructor, dimensions must not be negative,
             old data are kept if new size matches old size)
         */
-    void resize(int width, int height, value_type const & d);
+    void resize(int w, int h, value_type const & d);
 
         /** resize image to given size and initialize by copying data
             from the C-style arra \a data.
         */
-    void resizeCopy(int width, int height, const_pointer data);
+    void resizeCopy(int w, int h, const_pointer data);
 
         /** resize image to size of other image and copy it's data
         */
@@ -1046,30 +1078,30 @@ BasicImage<PIXELTYPE, Alloc>::init(value
 
 template <class PIXELTYPE, class Alloc>
 void
-BasicImage<PIXELTYPE, Alloc>::resize(int width, int height, value_type const & d)
+BasicImage<PIXELTYPE, Alloc>::resize(int w, int h, value_type const & d)
 {
-    vigra_precondition((width >= 0) && (height >= 0),
-         "BasicImage::resize(int width, int height, value_type const &): "
+    vigra_precondition((w >= 0) && (h >= 0),
+         "BasicImage::resize(int w, int h, value_type const &): "
          "width and height must be >= 0.\n");
 
-    if (width_ != width || height_ != height)  // change size?
+    if (width_ != w || height_ != h)  // change size?
     {
         value_type * newdata = 0;
         value_type ** newlines = 0;
-        if(width*height > 0)
+        if(w*h > 0)
         {
-            if (width*height != width_*height_) // different sizes, must reallocate
+            if (w*h != width_*height_) // different sizes, must reallocate
             {
-                newdata = allocator_.allocate(width*height);
-                std::uninitialized_fill_n(newdata, width*height, d);
-                newlines = initLineStartArray(newdata, width, height);
+                newdata = allocator_.allocate(w*h);
+                std::uninitialized_fill_n(newdata, w*h, d);
+                newlines = initLineStartArray(newdata, w, h);
                 deallocate();
             }
             else // need only to reshape
             {
                 newdata = data_;
-                std::fill_n(newdata, width*height, d);
-                newlines = initLineStartArray(newdata, width, height);
+                std::fill_n(newdata, w*h, d);
+                newlines = initLineStartArray(newdata, w, h);
                 pallocator_.deallocate(lines_, height_);
             }
         }
@@ -1080,22 +1112,22 @@ BasicImage<PIXELTYPE, Alloc>::resize(int
 
         data_ = newdata;
         lines_ = newlines;
-        width_ = width;
-        height_ = height;
+        width_ = w;
+        height_ = h;
     }
-    else if(width*height > 0) // keep size, re-init data
+    else if(w*h > 0) // keep size, re-init data
     {
-        std::fill_n(data_, width*height, d);
+        std::fill_n(data_, w*h, d);
     }
 }
 
 
 template <class PIXELTYPE, class Alloc>
 void
-BasicImage<PIXELTYPE, Alloc>::resizeCopy(int width, int height, const_pointer data)
+BasicImage<PIXELTYPE, Alloc>::resizeCopy(int w, int h, const_pointer src_data)
 {
-    int newsize = width*height;
-    if (width_ != width || height_ != height)  // change size?
+    int newsize = w*h;
+    if (width_ != w || height_ != h)  // change size?
     {
         value_type * newdata = 0;
         value_type ** newlines = 0;
@@ -1104,15 +1136,15 @@ BasicImage<PIXELTYPE, Alloc>::resizeCopy
             if (newsize != width_*height_) // different sizes, must reallocate
             {
                 newdata = allocator_.allocate(newsize);
-                std::uninitialized_copy(data, data + newsize, newdata);
-                newlines = initLineStartArray(newdata, width, height);
+                std::uninitialized_copy(src_data, src_data + newsize, newdata);
+                newlines = initLineStartArray(newdata, w, h);
                 deallocate();
             }
             else // need only to reshape
             {
                 newdata = data_;
-                std::copy(data, data + newsize, newdata);
-                newlines = initLineStartArray(newdata, width, height);
+                std::copy(src_data, src_data + newsize, newdata);
+                newlines = initLineStartArray(newdata, w, h);
                 pallocator_.deallocate(lines_, height_);
             }
         }
@@ -1123,12 +1155,12 @@ BasicImage<PIXELTYPE, Alloc>::resizeCopy
 
         data_ = newdata;
         lines_ = newlines;
-        width_ = width;
-        height_ = height;
+        width_ = w;
+        height_ = h;
     }
     else if(newsize > 0) // keep size, copy data
     {
-        std::copy(data, data + newsize, data_);
+        std::copy(src_data, src_data + newsize, data_);
     }
 }
 
@@ -1163,11 +1195,11 @@ BasicImage<PIXELTYPE, Alloc>::deallocate
 
 template <class PIXELTYPE, class Alloc>
 PIXELTYPE **
-BasicImage<PIXELTYPE, Alloc>::initLineStartArray(value_type * data, int width, int height)
+BasicImage<PIXELTYPE, Alloc>::initLineStartArray(value_type * src_data, int w, int h)
 {
-    value_type ** lines = pallocator_.allocate(height);
-    for(int y=0; y<height; ++y)
-         lines[y] = data + y*width;
+    value_type ** lines = pallocator_.allocate(h);
+    for(int y=0; y<h; ++y)
+         lines[y] = src_data + y*w;
     return lines;
 }
 
diff -uprN misc/vigra1.4.0/include/vigra/basicimageview.hxx misc/build/vigra1.4.0/include/vigra/basicimageview.hxx
--- misc/vigra1.4.0/include/vigra/basicimageview.hxx	2005-12-21 05:53:30.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/basicimageview.hxx	2006-08-31 12:08:15.219210000 +0200
@@ -176,20 +176,20 @@ class BasicImageView
 
         /** construct view of size w x h
         */
-    BasicImageView(const_pointer data, int w, int h, int stride = 0)
-    : data_(const_cast<pointer>(data)),
+    BasicImageView(const_pointer src_data, int w, int h, int data_stride = 0)
+    : data_(const_cast<pointer>(src_data)),
       width_(w),
       height_(h),
-      stride_(stride == 0 ? w : stride)
+      stride_(data_stride == 0 ? w : data_stride)
     {}
 
         /** construct view of size size.x x size.y
         */
-    BasicImageView(const_pointer data, difference_type const & size, int stride = 0)
-    : data_(const_cast<pointer>(data)),
-      width_(size.x),
-      height_(size.y),
-      stride_(stride == 0 ? size.x : stride)
+    BasicImageView(const_pointer src_data, difference_type const & sz, int data_stride = 0)
+    : data_(const_cast<pointer>(src_data)),
+      width_(sz.x),
+      height_(sz.y),
+      stride_(data_stride == 0 ? sz.x : data_stride)
     {}
 
         /** set Image with const value
diff -uprN misc/vigra1.4.0/include/vigra/boundarytensor.hxx misc/build/vigra1.4.0/include/vigra/boundarytensor.hxx
--- misc/vigra1.4.0/include/vigra/boundarytensor.hxx	2005-12-21 05:53:31.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/boundarytensor.hxx	2006-08-31 12:08:15.240695000 +0200
@@ -71,8 +71,8 @@ initGaussianPolarFilters1(double std_dev
     int radius = (int)(4.0*std_dev + 0.5);
     std_dev *= 1.08179074376;
     double f = 1.0 / VIGRA_CSTD::sqrt(2.0 * M_PI) / std_dev;  // norm
-    double a = 0.558868151788 / VIGRA_CSTD::pow(std_dev, 5);
-    double b = -2.04251639729 / VIGRA_CSTD::pow(std_dev, 3);
+    double a = 0.558868151788 / VIGRA_CSTD::pow(std_dev, 5.0);
+    double b = -2.04251639729 / VIGRA_CSTD::pow(std_dev, 3.0);
     double sigma22 = -0.5 / std_dev / std_dev;
 
 
@@ -175,7 +175,7 @@ initGaussianPolarFilters3(double std_dev
     std_dev *= 1.15470053838;
     double sigma22 = -0.5 / std_dev / std_dev;
     double f = 1.0 / VIGRA_CSTD::sqrt(2.0 * M_PI) / std_dev;  // norm
-    double a = 0.883887052922 / VIGRA_CSTD::pow(std_dev, 5);
+    double a = 0.883887052922 / VIGRA_CSTD::pow(std_dev, 5.0);
 
     for(unsigned int i=0; i<k.size(); ++i)
     {
@@ -183,7 +183,7 @@ initGaussianPolarFilters3(double std_dev
         k[i].setBorderTreatment(BORDER_TREATMENT_REFLECT);
     }
         
-    double b = -1.3786348292 / VIGRA_CSTD::pow(std_dev, 3);
+    double b = -1.3786348292 / VIGRA_CSTD::pow(std_dev, 3.0);
 
     int ix;
     iterator c = k[0].center();
diff -uprN misc/vigra1.4.0/include/vigra/config.hxx misc/build/vigra1.4.0/include/vigra/config.hxx
--- misc/vigra1.4.0/include/vigra/config.hxx	2005-12-21 05:53:31.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/config.hxx	2006-08-31 12:08:15.261488000 +0200
@@ -84,6 +84,12 @@
 		#endif // VIGRA_NO_STD_MINMAX
 	#endif // (_MSC_VER < 1300)
 
+    #if _MSC_VER <= 1310
+	    #ifndef CMATH_NOT_IN_STD
+	        #define CMATH_NOT_IN_STD
+        #endif
+    #endif // _MSC_VER < 1310
+
     #if _MSC_VER < 1310
         #define NO_PARTIAL_TEMPLATE_SPECIALIZATION
         #define NO_OUT_OF_LINE_MEMBER_TEMPLATES
diff -uprN misc/vigra1.4.0/include/vigra/diff2d.hxx misc/build/vigra1.4.0/include/vigra/diff2d.hxx
--- misc/vigra1.4.0/include/vigra/diff2d.hxx	2005-12-21 05:53:33.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/diff2d.hxx	2006-08-31 12:08:15.282334000 +0200
@@ -490,8 +490,8 @@ public:
 
         /** Construct point at given position.
         */
-    Size2D(int width, int height)
-    : Diff2D(width, height)
+    Size2D(int w, int h)
+    : Diff2D(w, h)
     {}
 
         /** Copy Constructor.
@@ -606,8 +606,8 @@ public:
 
         /** Construct point at given position.
         */
-    Point2D(int x, int y)
-    : Diff2D(x, y)
+    Point2D(int x_, int y_)
+    : Diff2D(x_, y_)
     {}
 
         /** Copy Constructor.
@@ -870,26 +870,26 @@ public:
          * (lowerRight is considered to be outside the rectangle as
          * usual in the VIGRA)
          */
-    Rect2D(Point2D const &upperLeft, Point2D const &lowerRight)
-    : upperLeft_(upperLeft), lowerRight_(lowerRight)
+    Rect2D(Point2D const &ul, Point2D const &lr)
+    : upperLeft_(ul), lowerRight_(lr)
     {}
 
         /** Construct a rectangle representing the given range
          */
-    Rect2D(int left, int top, int right, int bottom)
-    : upperLeft_(left, top), lowerRight_(right, bottom)
+    Rect2D(int l, int t, int r, int b)
+        : upperLeft_(l,t), lowerRight_(r,b)
     {}
 
         /** Construct a rectangle of given position and size
          */
-    Rect2D(Point2D const &upperLeft, Size2D const &size)
-    : upperLeft_(upperLeft), lowerRight_(upperLeft + size)
+    Rect2D(Point2D const &ul, Size2D const &sz)
+    : upperLeft_(ul), lowerRight_(ul + sz)
     {}
 
         /** Construct a rectangle of given size at position (0,0)
          */
-    explicit Rect2D(Size2D const &size)
-    : lowerRight_(Point2D(size))
+    explicit Rect2D(Size2D const &sz)
+    : lowerRight_(Point2D(sz))
     {}
 
         /** Return the first point (scan-order wise) which is
@@ -936,9 +936,9 @@ public:
         /** Move the whole rectangle so that upperLeft() will become
          * Point2D(left, top) afterwards.
          */
-    void moveTo(int left, int top)
+    void moveTo(int l, int t)
     {
-        moveTo(Point2D(left, top));
+        moveTo(Point2D(l, t));
     }
 
         /** Move the whole rectangle by the given 2D offset.
@@ -1023,17 +1023,17 @@ public:
         /** Resize this rectangle to the given extents. This will move
          * the lower right corner only.
          */
-    void setSize(Size2D const &size)
+    void setSize(Size2D const &sz)
     {
-        lowerRight_ = upperLeft_ + size;
+        lowerRight_ = upperLeft_ + sz;
     }
 
         /** Resize this rectangle to the given extents. This will move
          * the lower right corner only.
          */
-    void setSize(int width, int height)
+    void setSize(int w, int h)
     {
-        lowerRight_ = upperLeft_ + Size2D(width, height);
+        lowerRight_ = upperLeft_ + Size2D(w, h);
     }
 
         /** Increase the size of the rectangle by the given offset. This
diff -uprN misc/vigra1.4.0/include/vigra/fftw.hxx misc/build/vigra1.4.0/include/vigra/fftw.hxx
--- misc/vigra1.4.0/include/vigra/fftw.hxx	2005-12-21 05:53:34.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/fftw.hxx	2006-08-31 12:08:15.308081000 +0200
@@ -399,8 +399,6 @@ inline FFTWComplex operator /(FFTWComple
     return a;
 }
 
-using VIGRA_CSTD::abs;
-
 inline FFTWComplex::value_type abs(const FFTWComplex &a)
 {
     return a.magnitude();
diff -uprN misc/vigra1.4.0/include/vigra/fftw3.hxx misc/build/vigra1.4.0/include/vigra/fftw3.hxx
--- misc/vigra1.4.0/include/vigra/fftw3.hxx	2005-12-21 05:53:34.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/fftw3.hxx	2006-08-31 12:08:15.337248000 +0200
@@ -572,8 +572,6 @@ inline FFTWComplex operator /(FFTWComple
     return a;
 }
 
-using VIGRA_CSTD::abs;
-
     /// absolute value (= magnitude)
 inline FFTWComplex::value_type abs(const FFTWComplex &a)
 {
diff -uprN misc/vigra1.4.0/include/vigra/fixedpoint.hxx misc/build/vigra1.4.0/include/vigra/fixedpoint.hxx
--- misc/vigra1.4.0/include/vigra/fixedpoint.hxx	2005-12-21 05:53:34.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/fixedpoint.hxx	2006-08-31 12:08:15.367651000 +0200
@@ -118,20 +118,18 @@ enum FixedPointNoShift { FPNoShift };
 
 namespace detail {
 
-template <bool MustRound>
+template <bool MustRound, int N>
 struct FPAssignWithRound;
 
-template <>
-struct FPAssignWithRound<false>
+template <int N>
+struct FPAssignWithRound<false, N>
 {
-    template <int N>
     static inline int exec(int v) { return v << (-N); }
 };
 
-template <>
-struct FPAssignWithRound<true>
+template <int N>
+struct FPAssignWithRound<true, N>
 {
-    template <int N>
     static inline int exec(int const v)
     {
         return (v + (1 << (N - 1))) >> (N);
@@ -276,7 +274,7 @@ public:
         */
     template <unsigned Int2, unsigned Frac2>
     FixedPoint(const FixedPoint<Int2, Frac2> &other)
-    : value(detail::FPAssignWithRound<(Frac2 > FractionalBits)>::template exec<Frac2 - FractionalBits>(other.value))
+        : value(detail::FPAssignWithRound<(Frac2 > FractionalBits), Frac2 - FractionalBits>::exec(other.value))
     {
         VIGRA_STATIC_ASSERT((FixedPoint_overflow_error__More_than_31_bits_requested<(IntBits + FractionalBits)>));
         VIGRA_STATIC_ASSERT((FixedPoint_assignment_error__Target_object_has_too_few_integer_bits<(IntBits >= Int2)>));
@@ -321,7 +319,7 @@ public:
     FixedPoint & operator=(const FixedPoint<Int2, Frac2> &other)
     {
         VIGRA_STATIC_ASSERT((FixedPoint_assignment_error__Target_object_has_too_few_integer_bits<(IntBits >= Int2)>));
-        value = detail::FPAssignWithRound<(Frac2 > FractionalBits)>::template exec<Frac2 - FractionalBits>(other.value);
+        value = detail::FPAssignWithRound<(Frac2 > FractionalBits),Frac2 - FractionalBits>::exec(other.value);
         return *this;
     }
 
@@ -373,7 +371,7 @@ public:
     FixedPoint & operator+=(const FixedPoint<Int2, Frac2> &other)
     {
         VIGRA_STATIC_ASSERT((FixedPoint_assignment_error__Target_object_has_too_few_integer_bits<(IntBits >= Int2)>));
-        value += detail::FPAssignWithRound<(Frac2 > FractionalBits)>::template exec<Frac2 - FractionalBits>(other.value);
+        value += detail::FPAssignWithRound<(Frac2 > FractionalBits),Frac2 - FractionalBits>::exec(other.value);
         return *this;
     }
 
@@ -384,7 +382,7 @@ public:
     FixedPoint & operator-=(const FixedPoint<Int2, Frac2> &other)
     {
         VIGRA_STATIC_ASSERT((FixedPoint_assignment_error__Target_object_has_too_few_integer_bits<(IntBits >= Int2)>));
-        value -= detail::FPAssignWithRound<(Frac2 > FractionalBits)>::template exec<Frac2 - FractionalBits>(other.value);
+        value -= detail::FPAssignWithRound<(Frac2 > FractionalBits),Frac2 - FractionalBits>::exec(other.value);
         return *this;
     }
     
@@ -428,12 +426,12 @@ struct FixedPointCast<type> \
     } \
 };
 
-VIGRA_FIXED_POINT_CAST(Int8);
-VIGRA_FIXED_POINT_CAST(UInt8);
-VIGRA_FIXED_POINT_CAST(Int16);
-VIGRA_FIXED_POINT_CAST(UInt16);
-VIGRA_FIXED_POINT_CAST(Int32);
-VIGRA_FIXED_POINT_CAST(UInt32);
+VIGRA_FIXED_POINT_CAST(Int8)
+VIGRA_FIXED_POINT_CAST(UInt8)
+VIGRA_FIXED_POINT_CAST(Int16)
+VIGRA_FIXED_POINT_CAST(UInt16)
+VIGRA_FIXED_POINT_CAST(Int32)
+VIGRA_FIXED_POINT_CAST(UInt32)
 
 #undef VIGRA_FIXED_POINT_CAST
 
diff -uprN misc/vigra1.4.0/include/vigra/gaborfilter.hxx misc/build/vigra1.4.0/include/vigra/gaborfilter.hxx
--- misc/vigra1.4.0/include/vigra/gaborfilter.hxx	2005-12-21 05:53:35.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/gaborfilter.hxx	2006-08-31 12:08:15.389636000 +0200
@@ -289,7 +289,11 @@ inline double angularGaborSigma(int dire
     Namespace: vigra
 */
 template <class ImageType, 
+#ifndef VIGRA_WITHOUT_NESTED_TEMPLATE_PARAMS
       class Alloc = typename ImageType::allocator_type::template rebind<ImageType>::other >
+#else
+      class Alloc = std::allocator<ImageType> >
+#endif
 class GaborFilterFamily 
 : public ImageArray<ImageType, Alloc>
 {
diff -uprN misc/vigra1.4.0/include/vigra/gaussians.hxx misc/build/vigra1.4.0/include/vigra/gaussians.hxx
--- misc/vigra1.4.0/include/vigra/gaussians.hxx	2005-12-21 05:53:35.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/gaussians.hxx	2006-08-31 12:08:15.409790000 +0200
@@ -88,26 +88,26 @@ class Gaussian
             sigma > 0.0
             \endcode
         */
-    explicit Gaussian(T sigma = 1.0, unsigned int derivativeOrder = 0)
-    : sigma_(sigma),
-      sigma2_(-0.5 / sigma / sigma),
+    explicit Gaussian(T s = 1.0, unsigned int derivOrder = 0)
+    : sigma_(s),
+      sigma2_(-0.5 / s / s),
       norm_(0.0),
-      order_(derivativeOrder),
-      hermitePolynomial_(derivativeOrder / 2 + 1)
+      order_(derivOrder),
+      hermitePolynomial_(derivOrder / 2 + 1)
     {
-        vigra_precondition(sigma_ > 0.0,
+        vigra_precondition(s > 0.0,
             "Gaussian::Gaussian(): sigma > 0 required.");
         switch(order_)
         {
             case 1:
             case 2:
-                norm_ = -1.0 / (VIGRA_CSTD::sqrt(2.0 * M_PI) * sq(sigma) * sigma);
+                norm_ = -1.0 / (VIGRA_CSTD::sqrt(2.0 * M_PI) * sq(s) * s);
                 break;
             case 3:
-                norm_ = 1.0 / (VIGRA_CSTD::sqrt(2.0 * M_PI) * sq(sigma) * sq(sigma) * sigma);
+                norm_ = 1.0 / (VIGRA_CSTD::sqrt(2.0 * M_PI) * sq(s) * sq(s) * s);
                 break;
             default:
-                norm_ = 1.0 / VIGRA_CSTD::sqrt(2.0 * M_PI) / sigma;
+                norm_ = 1.0 / VIGRA_CSTD::sqrt(2.0 * M_PI) / s;
         }
         calculateHermitePolynomial();
     }
diff -uprN misc/vigra1.4.0/include/vigra/imagecontainer.hxx misc/build/vigra1.4.0/include/vigra/imagecontainer.hxx
--- misc/vigra1.4.0/include/vigra/imagecontainer.hxx	2005-12-21 05:53:36.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/imagecontainer.hxx	2006-08-31 12:08:15.429159000 +0200
@@ -70,7 +70,11 @@ namespace vigra {
     Namespace: vigra
 */
 template <class ImageType, 
+#ifndef VIGRA_WITHOUT_NESTED_TEMPLATE_PARAMS
       class Alloc = typename ImageType::allocator_type::template rebind<ImageType>::other >
+#else
+      class Alloc = std::allocator<ImageType> >
+#endif
 class ImageArray
 {
     Size2D imageSize_;
diff -uprN misc/vigra1.4.0/include/vigra/mathutil.hxx misc/build/vigra1.4.0/include/vigra/mathutil.hxx
--- misc/vigra1.4.0/include/vigra/mathutil.hxx	2005-12-21 05:53:39.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/mathutil.hxx	2006-08-31 12:08:15.449199000 +0200
@@ -73,8 +73,6 @@
 
 namespace vigra {
 
-#ifndef __sun 
-
 /** \addtogroup MathFunctions Mathematical Functions
 
     Useful mathematical functions and functors.
@@ -109,18 +107,11 @@ double erf(T x)
         return ans - 1.0;
 }
 
-#else
-
-using VIGRA_CSTD::erf;
-
-#endif
-
 // import functions into namespace vigra which VIGRA is going to overload
 
 using VIGRA_CSTD::pow;  
 using VIGRA_CSTD::floor;  
 using VIGRA_CSTD::ceil;  
-using std::abs;  
 
 #define VIGRA_DEFINE_UNSIGNED_ABS(T) \
     inline T abs(T t) { return t; }
@@ -130,9 +121,39 @@ VIGRA_DEFINE_UNSIGNED_ABS(unsigned char)
 VIGRA_DEFINE_UNSIGNED_ABS(unsigned short)
 VIGRA_DEFINE_UNSIGNED_ABS(unsigned int)
 VIGRA_DEFINE_UNSIGNED_ABS(unsigned long)
+#ifdef VIGRA_HAS_LONG_LONG
+VIGRA_DEFINE_UNSIGNED_ABS(unsigned long long)
+#endif
 
 #undef VIGRA_DEFINE_UNSIGNED_ABS
 
+#define VIGRA_DEFINE_SIGNED_ABS(T) \
+    inline T abs(T t) { return (T)abs(t); }
+#define VIGRA_DEFINE_SIGNED_LABS(T) \
+    inline T abs(T t) { return (T)labs(t); }
+#define VIGRA_DEFINE_SIGNED_LLABS(T) \
+    inline T abs(T t) { return (T)llabs(t); }
+#define VIGRA_DEFINE_FABS(T) \
+    inline T abs(T t) { return (T)fabs(t); }
+
+VIGRA_DEFINE_SIGNED_ABS(signed char)
+VIGRA_DEFINE_SIGNED_ABS(signed short)
+VIGRA_DEFINE_SIGNED_ABS(signed int)
+VIGRA_DEFINE_SIGNED_LABS(signed long)
+#ifdef VIGRA_HAS_LONG_LONG
+VIGRA_DEFINE_SIGNED_LLABS(signed long long)
+#endif
+VIGRA_DEFINE_FABS(float)
+VIGRA_DEFINE_FABS(double)
+#ifdef VIGRA_HAS_LONG_DOUBLE
+VIGRA_DEFINE_FABS(long double)
+#endif
+
+#undef VIGRA_DEFINE_SIGNED_ABS
+#undef VIGRA_DEFINE_SIGNED_LABS
+#undef VIGRA_DEFINE_SIGNED_LLABS
+#undef VIGRA_DEFINE_FABS
+
     /*! The rounding function.
 
         Defined for all floating point types. Rounds towards the nearest integer for both 
@@ -155,12 +176,14 @@ inline double round(double t)
                : ceil(t - 0.5);
 }
 
+#ifdef VIGRA_HAS_LONG_DOUBLE
 inline long double round(long double t)
 {
     return t >= 0.0
                ? floor(t + 0.5)
                : ceil(t - 0.5);
 }
+#endif
 
     /*! The square function.
 
@@ -371,9 +394,15 @@ VIGRA_DEFINE_NORM(int)
 VIGRA_DEFINE_NORM(unsigned int)
 VIGRA_DEFINE_NORM(long)
 VIGRA_DEFINE_NORM(unsigned long)
+#ifdef VIGRA_HAS_LONG_LONG
+VIGRA_DEFINE_NORM(long long)
+VIGRA_DEFINE_NORM(unsigned long long)
+#endif
 VIGRA_DEFINE_NORM(float)
 VIGRA_DEFINE_NORM(double)
+#ifdef VIGRA_HAS_LONG_DOUBLE
 VIGRA_DEFINE_NORM(long double)
+#endif
 
 #undef VIGRA_DEFINE_NORM
 
diff -uprN misc/vigra1.4.0/include/vigra/numerictraits.hxx misc/build/vigra1.4.0/include/vigra/numerictraits.hxx
--- misc/vigra1.4.0/include/vigra/numerictraits.hxx	2005-12-21 05:53:41.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/numerictraits.hxx	2006-08-31 12:08:15.474422000 +0200
@@ -891,6 +891,90 @@ struct NumericTraits<unsigned long>
     }
 };
 
+#ifdef VIGRA_HAS_LONG_LONG
+template<>
+struct NumericTraits<long long>
+{
+    typedef long long Type;
+    typedef long long Promote;
+    typedef double RealPromote;
+    typedef std::complex<RealPromote> ComplexPromote;
+    typedef Type ValueType;
+
+    typedef VigraTrueType isIntegral;
+    typedef VigraTrueType isScalar;
+    typedef VigraTrueType isSigned;
+    typedef VigraTrueType isOrdered;
+    typedef VigraFalseType isComplex;
+    
+    static long long zero() { return 0; }
+    static long long one() { return 1; }
+    static long long nonZero() { return 1; }
+    static long long min() { return LLONG_MIN; }
+    static long long max() { return LLONG_MAX; }
+    
+#ifdef NO_INLINE_STATIC_CONST_DEFINITION
+    enum { minConst = LONG_MIN, maxConst = LLONG_MAX };
+#else
+    static const long long minConst = LLONG_MIN;
+    static const long long maxConst = LLONG_MAX;
+#endif
+
+    static Promote toPromote(long long v) { return v; }
+    static RealPromote toRealPromote(long long v) { return v; }
+    static long long fromPromote(Promote v) { return v; }
+    static long long fromRealPromote(RealPromote v) {
+        return ((v < 0.0) 
+                 ? ((v < (RealPromote)LLONG_MIN) 
+                     ? LLONG_MIN 
+                     : static_cast<long long>(v - 0.5)) 
+                 : ((v > (RealPromote)LLONG_MAX) 
+                     ? LLONG_MAX 
+                     : static_cast<long long>(v + 0.5))); 
+    }
+};
+
+template<>
+struct NumericTraits<unsigned long long>
+{
+    typedef unsigned long long Type;
+    typedef unsigned long long Promote;
+    typedef double RealPromote;
+    typedef std::complex<RealPromote> ComplexPromote;
+    typedef Type ValueType;
+
+    typedef VigraTrueType isIntegral;
+    typedef VigraTrueType isScalar;
+    typedef VigraFalseType isSigned;
+    typedef VigraTrueType isOrdered;
+    typedef VigraFalseType isComplex;
+    
+    static unsigned long long zero() { return 0; }
+    static unsigned long long one() { return 1; }
+    static unsigned long long nonZero() { return 1; }
+    static unsigned long long min() { return 0; }
+    static unsigned long long max() { return ULLONG_MAX; }
+    
+#ifdef NO_INLINE_STATIC_CONST_DEFINITION
+    enum { minConst = 0, maxConst = ULLONG_MAX };
+#else
+    static const unsigned long long minConst = 0;
+    static const unsigned long long maxConst = ULLONG_MAX;
+#endif
+
+    static Promote toPromote(unsigned long long v) { return v; }
+    static RealPromote toRealPromote(unsigned long long v) { return v; }
+    static unsigned long long fromPromote(Promote v) { return v; }
+    static unsigned long long fromRealPromote(RealPromote v) {
+            return ((v < 0.0) 
+                     ? 0 
+                     : ((v > (RealPromote)ULLONG_MAX) 
+                         ? ULLONG_MAX 
+                         : static_cast<unsigned long long>(v + 0.5)));
+    }
+};
+#endif
+
 template<>
 struct NumericTraits<float>
 {
@@ -949,6 +1033,7 @@ struct NumericTraits<double>
     static double fromRealPromote(RealPromote v) { return v; }
 };
 
+#ifdef VIGRA_HAS_LONG_DOUBLE
 template<>
 struct NumericTraits<long double>
 {
@@ -977,6 +1062,7 @@ struct NumericTraits<long double>
     static long double fromPromote(Promote v) { return v; }
     static long double fromRealPromote(RealPromote v) { return v; }
 };
+#endif
 
 #ifndef NO_PARTIAL_TEMPLATE_SPECIALIZATION
 
@@ -1055,9 +1141,15 @@ VIGRA_DEFINE_NORM_TRAITS(int)
 VIGRA_DEFINE_NORM_TRAITS(unsigned int)
 VIGRA_DEFINE_NORM_TRAITS(long)
 VIGRA_DEFINE_NORM_TRAITS(unsigned long)
+#ifdef VIGRA_HAS_LONG_LONG
+VIGRA_DEFINE_NORM_TRAITS(long long)
+VIGRA_DEFINE_NORM_TRAITS(unsigned long long)
+#endif
 VIGRA_DEFINE_NORM_TRAITS(float)
 VIGRA_DEFINE_NORM_TRAITS(double)
+#ifdef VIGRA_HAS_LONG_DOUBLE
 VIGRA_DEFINE_NORM_TRAITS(long double)
+#endif
 
 #undef VIGRA_DEFINE_NORM_TRAITS
 
diff -uprN misc/vigra1.4.0/include/vigra/orientedtensorfilters.hxx misc/build/vigra1.4.0/include/vigra/orientedtensorfilters.hxx
--- misc/vigra1.4.0/include/vigra/orientedtensorfilters.hxx	2005-12-21 05:53:42.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/orientedtensorfilters.hxx	2006-08-31 12:08:15.503678000 +0200
@@ -434,7 +434,7 @@ class Sin6RingKernel
         if(x == 0 && y == 0)
             return weights_(radius_, radius_);
         double d = dot(vectors_(x+radius_, y+radius_), v);
-        return VIGRA_CSTD::pow(1.0 - d * d, 3) * weights_(x+radius_, y+radius_);
+        return VIGRA_CSTD::pow(1.0 - d * d, 3.0) * weights_(x+radius_, y+radius_);
     }
 };
 
@@ -455,7 +455,7 @@ class Sin6Kernel
         if(x == 0 && y == 0)
             return weights_(radius_, radius_);
         double d = dot(vectors_(x+radius_, y+radius_), v);
-        return VIGRA_CSTD::pow(1.0 - d * d, 3) * weights_(x+radius_, y+radius_);
+        return VIGRA_CSTD::pow(1.0 - d * d, 3.0) * weights_(x+radius_, y+radius_);
     }
 };
 
@@ -476,7 +476,7 @@ class Cos6RingKernel
         if(x == 0 && y == 0)
             return weights_(radius_, radius_);
         double d = dot(vectors_(x+radius_, y+radius_), v);
-        return (1.0 - VIGRA_CSTD::pow(1.0 - d * d, 3)) * weights_(x+radius_, y+radius_);
+        return (1.0 - VIGRA_CSTD::pow(1.0 - d * d, 3.0)) * weights_(x+radius_, y+radius_);
     }
 };
 
@@ -497,7 +497,7 @@ class Cos6Kernel
         if(x == 0 && y == 0)
             return weights_(radius_, radius_);
         double d = dot(vectors_(x+radius_, y+radius_), v);
-        return (1.0 - VIGRA_CSTD::pow(1.0 - d * d, 3)) * weights_(x+radius_, y+radius_);
+        return (1.0 - VIGRA_CSTD::pow(1.0 - d * d, 3.0)) * weights_(x+radius_, y+radius_);
     }
 };
 
diff -uprN misc/vigra1.4.0/include/vigra/polynomial.hxx misc/build/vigra1.4.0/include/vigra/polynomial.hxx
--- misc/vigra1.4.0/include/vigra/polynomial.hxx	2005-12-21 05:53:42.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/polynomial.hxx	2006-08-31 12:08:15.526572000 +0200
@@ -118,10 +118,10 @@ class PolynomialView
             of subsequent algorithms (especially root finding) performed on the
             polynomial.
         */
-    PolynomialView(T * coeffs, unsigned int order, double epsilon = 1.0e-14)
+    PolynomialView(T * coeffs, unsigned int ord, double eps = 1.0e-14)
     : coeffs_(coeffs),
-      order_(order),
-      epsilon_(epsilon)
+      order_(ord),
+      epsilon_(eps)
     {}
     
         /// Access the coefficient of x^i
@@ -244,16 +244,16 @@ class PolynomialView
         { epsilon_ = eps; }
 
   protected:
-    PolynomialView(double epsilon = 1e-14)
+    PolynomialView(double eps = 1e-14)
     : coeffs_(0),
       order_(0),
-      epsilon_(epsilon)
+      epsilon_(eps)
     {}
     
-    void setCoeffs(T * coeffs, unsigned int order)
+    void setCoeffs(T * coeffs, unsigned int ord)
     {
         coeffs_ = coeffs;
-        order_ = order;
+        order_ = ord;
     }
   
     T * coeffs_;
@@ -396,9 +396,9 @@ PolynomialView<T>::deflateConjugatePair(
     
 template <class T>
 void 
-PolynomialView<T>::minimizeOrder(double epsilon)
+PolynomialView<T>::minimizeOrder(double eps)
 {
-    while(std::abs(coeffs_[order_]) <= epsilon && order_ > 0)
+    while(std::abs(coeffs_[order_]) <= eps && order_ > 0)
             --order_;
 }
 
diff -uprN misc/vigra1.4.0/include/vigra/recursiveconvolution.hxx misc/build/vigra1.4.0/include/vigra/recursiveconvolution.hxx
--- misc/vigra1.4.0/include/vigra/recursiveconvolution.hxx	2005-12-21 05:53:42.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/recursiveconvolution.hxx	2006-08-31 12:08:15.553556000 +0200
@@ -259,16 +259,16 @@ void recursiveFilterLine(SrcIterator is,
     {    
        // correction factors for b
         double bright = b;
-        double bleft = VIGRA_CSTD::pow(b, w);
+        double bleft = VIGRA_CSTD::pow(b, (double)w);
 
         for(x=w-1; x>=0; --x, --is, --id)
         {    
             TempType f = b * old;
             old = as(is) + f;
-            double norm = (1.0 - b) / (1.0 + b - bleft - bright);
+            double norm2 = (1.0 - b) / (1.0 + b - bleft - bright);
             bleft /= b;
             bright *= b;
-            ad.set(norm * (line[x] + f), id);
+            ad.set(norm2 * (line[x] + f), id);
         }
     }
     else if(border == BORDER_TREATMENT_AVOID)
diff -uprN misc/vigra1.4.0/include/vigra/rgbvalue.hxx misc/build/vigra1.4.0/include/vigra/rgbvalue.hxx
--- misc/vigra1.4.0/include/vigra/rgbvalue.hxx	2005-12-21 05:53:43.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/rgbvalue.hxx	2006-08-31 12:31:37.392094000 +0200
@@ -39,6 +39,10 @@
 #ifndef VIGRA_RGBVALUE_HXX
 #define VIGRA_RGBVALUE_HXX
 
+#if defined __GNUC__
+#pragma GCC system_header
+#endif
+
 #include <cmath>    // abs(double)
 #include <cstdlib>  // abs(int)
 #include "vigra/config.hxx"
@@ -700,8 +704,6 @@ operator/=(RGBValue<V, RIDX, GIDX, BIDX>
     return l;
 }
 
-using VIGRA_CSTD::abs;
-
     /// component-wise absolute value
 template <class T, unsigned int RIDX, unsigned int GIDX, unsigned int BIDX>
 inline
diff -uprN misc/vigra1.4.0/include/vigra/separableconvolution.hxx misc/build/vigra1.4.0/include/vigra/separableconvolution.hxx
--- misc/vigra1.4.0/include/vigra/separableconvolution.hxx	2005-12-21 05:53:44.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/separableconvolution.hxx	2006-08-31 12:08:15.610465000 +0200
@@ -1017,11 +1017,11 @@ class Kernel1D
         */
     InitProxy operator=(value_type const & v)
     {
-        int size = right_ - left_ + 1;
+        int sz = right_ - left_ + 1;
         for(unsigned int i=0; i<kernel_.size(); ++i) kernel_[i] = v;
-        norm_ = (double)size*v;
+        norm_ = (double)sz*v;
 
-        return InitProxy(kernel_.begin(), size, norm_);
+        return InitProxy(kernel_.begin(), sz, norm_);
     }
 
         /** Destructor.
@@ -1235,17 +1235,17 @@ class Kernel1D
                is 1 or equals the size of the kernel.
             \endcode
         */
-    Kernel1D & initExplicitly(int left, int right)
+    Kernel1D & initExplicitly(int l, int r)
     {
-        vigra_precondition(left <= 0,
+        vigra_precondition(l <= 0,
                      "Kernel1D::initExplicitly(): left border must be <= 0.");
-        vigra_precondition(right >= 0,
+        vigra_precondition(r >= 0,
                      "Kernel1D::initExplicitly(): right border must be <= 0.");
 
-        right_ = right;
-        left_ = left;
+        right_ = r;
+        left_ = l;
 
-        kernel_.resize(right - left + 1);
+        kernel_.resize(r - l + 1);
 
         return *this;
     }
@@ -1342,8 +1342,8 @@ class Kernel1D
 };
 
 template <class ARITHTYPE>
-void Kernel1D<ARITHTYPE>::normalize(value_type norm,
-                          unsigned int derivativeOrder,
+void Kernel1D<ARITHTYPE>::normalize(value_type normFactor,
+                          unsigned int derivOrder,
                           double offset)
 {
     typedef typename NumericTraits<value_type>::RealPromote TmpType;
@@ -1352,7 +1352,7 @@ void Kernel1D<ARITHTYPE>::normalize(valu
     Iterator k = kernel_.begin();
     TmpType sum = NumericTraits<TmpType>::zero();
 
-    if(derivativeOrder == 0)
+    if(derivOrder == 0)
     {
         for(; k < kernel_.end(); ++k)
         {
@@ -1362,11 +1362,11 @@ void Kernel1D<ARITHTYPE>::normalize(valu
     else
     {
         unsigned int faculty = 1;
-        for(unsigned int i = 2; i <= derivativeOrder; ++i)
+        for(unsigned int i = 2; i <= derivOrder; ++i)
             faculty *= i;
         for(double x = left() + offset; k < kernel_.end(); ++x, ++k)
         {
-            sum += *k * VIGRA_CSTD::pow(-x, int(derivativeOrder)) / faculty;
+            sum += *k * VIGRA_CSTD::pow(-x, (double)derivOrder) / faculty;
         }
     }
 
@@ -1374,21 +1374,21 @@ void Kernel1D<ARITHTYPE>::normalize(valu
                     "Kernel1D<ARITHTYPE>::normalize(): "
                     "Cannot normalize a kernel with sum = 0");
     // normalize
-    sum = norm / sum;
+    sum = normFactor / sum;
     k = kernel_.begin();
     for(; k != kernel_.end(); ++k)
     {
         *k = *k * sum;
     }
 
-    norm_ = norm;
+    norm_ = normFactor;
 }
 
 /***********************************************************************/
 
 template <class ARITHTYPE>
 void Kernel1D<ARITHTYPE>::initGaussian(double std_dev,
-                                       value_type norm)
+                                       value_type normFactor)
 {
     vigra_precondition(std_dev >= 0.0,
               "Kernel1D::initGaussian(): Standard deviation must be >= 0.");
@@ -1421,8 +1421,8 @@ void Kernel1D<ARITHTYPE>::initGaussian(d
         right_ = 0;
     }
 
-    if(norm != 0.0)
-        normalize(norm);
+    if(normFactor != 0.0)
+        normalize(normFactor);
     else
         norm_ = 1.0;
 
@@ -1434,7 +1434,7 @@ void Kernel1D<ARITHTYPE>::initGaussian(d
 
 template <class ARITHTYPE>
 void Kernel1D<ARITHTYPE>::initDiscreteGaussian(double std_dev,
-                                       value_type norm)
+                                               value_type normFactor)
 {
     vigra_precondition(std_dev >= 0.0,
               "Kernel1D::initDiscreteGaussian(): Standard deviation must be >= 0.");
@@ -1476,7 +1476,7 @@ void Kernel1D<ARITHTYPE>::initDiscreteGa
             er += warray[i];
         }
 
-        double scale = norm / (2*er - warray[0]);
+        double scale = normFactor / (2*er - warray[0]);
 
         initExplicitly(-radius, radius);
         iterator c = center();
@@ -1489,12 +1489,12 @@ void Kernel1D<ARITHTYPE>::initDiscreteGa
     else
     {
         kernel_.erase(kernel_.begin(), kernel_.end());
-        kernel_.push_back(norm);
+        kernel_.push_back(normFactor);
         left_ = 0;
         right_ = 0;
     }
 
-    norm_ = norm;
+    norm_ = normFactor;
 
     // best border treatment for Gaussians is BORDER_TREATMENT_REFLECT
     border_treatment_ = BORDER_TREATMENT_REFLECT;
@@ -1505,15 +1505,15 @@ void Kernel1D<ARITHTYPE>::initDiscreteGa
 template <class ARITHTYPE>
 void
 Kernel1D<ARITHTYPE>::initGaussianDerivative(double std_dev,
-                    int order,
-                    value_type norm)
+                                            int order,
+                                            value_type normFactor)
 {
     vigra_precondition(order >= 0,
               "Kernel1D::initGaussianDerivative(): Order must be >= 0.");
 
     if(order == 0)
     {
-        initGaussian(std_dev, norm);
+        initGaussian(std_dev, normFactor);
         return;
     }
 
@@ -1544,7 +1544,7 @@ Kernel1D<ARITHTYPE>::initGaussianDerivat
 
     // remove DC, but only if kernel correction is permitted by a non-zero
     // value for norm
-    if(norm != 0.0)
+    if(normFactor != 0.0)
     {
         for(unsigned int i=0; i < kernel_.size(); ++i)
         {
@@ -1555,8 +1555,8 @@ Kernel1D<ARITHTYPE>::initGaussianDerivat
     left_ = -radius;
     right_ = radius;
 
-    if(norm != 0.0)
-        normalize(norm, order);
+    if(normFactor != 0.0)
+        normalize(normFactor, order);
     else
         norm_ = 1.0;
 
@@ -1570,7 +1570,7 @@ Kernel1D<ARITHTYPE>::initGaussianDerivat
 template <class ARITHTYPE>
 void
 Kernel1D<ARITHTYPE>::initBinomial(int radius,
-                                  value_type norm)
+                                  value_type normFactor)
 {
     vigra_precondition(radius > 0,
               "Kernel1D::initBinomial(): Radius must be > 0.");
@@ -1600,12 +1600,12 @@ Kernel1D<ARITHTYPE>::initBinomial(int ra
 
     for(i=0; i<=radius*2+1; ++i)
     {
-        kernel_.push_back(kernel[i] * norm);
+        kernel_.push_back(kernel[i] * normFactor);
     }
 
     left_ = -radius;
     right_ = radius;
-    norm_ = norm;
+    norm_ = normFactor;
 
     // best border treatment for Binomial is BORDER_TREATMENT_REFLECT
     border_treatment_ = BORDER_TREATMENT_REFLECT;
@@ -1615,7 +1615,7 @@ Kernel1D<ARITHTYPE>::initBinomial(int ra
 
 template <class ARITHTYPE>
 void Kernel1D<ARITHTYPE>::initAveraging(int radius,
-                                        value_type norm)
+                                        value_type normFactor)
 {
     vigra_precondition(radius > 0,
               "Kernel1D::initAveraging(): Radius must be > 0.");
@@ -1629,12 +1629,12 @@ void Kernel1D<ARITHTYPE>::initAveraging(
 
     for(int i=0; i<=radius*2+1; ++i)
     {
-        kernel_.push_back(scale * norm);
+        kernel_.push_back(scale * normFactor);
     }
 
     left_ = -radius;
     right_ = radius;
-    norm_ = norm;
+    norm_ = normFactor;
 
     // best border treatment for Averaging is BORDER_TREATMENT_CLIP
     border_treatment_ = BORDER_TREATMENT_CLIP;
@@ -1644,18 +1644,18 @@ void Kernel1D<ARITHTYPE>::initAveraging(
 
 template <class ARITHTYPE>
 void
-Kernel1D<ARITHTYPE>::initSymmetricGradient(value_type norm)
+Kernel1D<ARITHTYPE>::initSymmetricGradient(value_type normFactor)
 {
     kernel_.erase(kernel_.begin(), kernel_.end());
     kernel_.reserve(3);
 
-    kernel_.push_back(0.5 * norm);
-    kernel_.push_back(0.0 * norm);
-    kernel_.push_back(-0.5 * norm);
+    kernel_.push_back(0.5 * normFactor);
+    kernel_.push_back(0.0 * normFactor);
+    kernel_.push_back(-0.5 * normFactor);
 
     left_ = -1;
     right_ = 1;
-    norm_ = norm;
+    norm_ = normFactor;
 
     // best border treatment for SymmetricGradient is
     // BORDER_TREATMENT_REPEAT
diff -uprN misc/vigra1.4.0/include/vigra/sized_int.hxx misc/build/vigra1.4.0/include/vigra/sized_int.hxx
--- misc/vigra1.4.0/include/vigra/sized_int.hxx	2005-12-21 05:53:44.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/sized_int.hxx	2006-08-31 12:26:31.937797000 +0200
@@ -73,6 +73,10 @@ struct SelectIntegerType<SIZE, Int_type_
     typedef Int_type_not_supported_on_this_platform type;
 };
 
+#if defined __SUNPRO_CC
+#pragma disable_warn
+#endif
+
 template<class LIST>
 struct SelectBiggestIntegerType
 {
@@ -86,6 +90,10 @@ struct SelectBiggestIntegerType
        type;
 };
 
+#if defined __SUNPRO_CC
+#pragma enable_warn
+#endif
+
 template<>
 struct SelectBiggestIntegerType<Int_type_not_supported_on_this_platform>
 {
diff -uprN misc/vigra1.4.0/include/vigra/splines.hxx misc/build/vigra1.4.0/include/vigra/splines.hxx
--- misc/vigra1.4.0/include/vigra/splines.hxx	2005-12-21 05:53:44.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/splines.hxx	2006-08-31 12:08:15.655906000 +0200
@@ -108,8 +108,8 @@ class BSplineBase
         /** Create functor for gevine derivative of the spline. The spline's order
             is specified spline by the template argument <TT>ORDER</tt>. 
         */
-    explicit BSplineBase(unsigned int derivativeOrder = 0)
-    : s1_(derivativeOrder)
+    explicit BSplineBase(unsigned int derivOrder = 0)
+    : s1_(derivOrder)
     {}
     
         /** Unary function call.
@@ -280,8 +280,8 @@ class BSplineBase<0, T>
     typedef T            result_type; 
     enum StaticOrder { order = 0 };
 
-    explicit BSplineBase(unsigned int derivativeOrder = 0)
-    : derivativeOrder_(derivativeOrder)
+    explicit BSplineBase(unsigned int derivOrder = 0)
+    : derivativeOrder_(derivOrder)
     {}
     
     result_type operator()(argument_type x) const
@@ -357,8 +357,8 @@ class BSpline<1, T>
     typedef T            result_type; 
     enum  StaticOrder { order = 1 };
 
-    explicit BSpline(unsigned int derivativeOrder = 0)
-    : derivativeOrder_(derivativeOrder)
+    explicit BSpline(unsigned int derivOrder = 0)
+    : derivativeOrder_(derivOrder)
     {}
     
     result_type operator()(argument_type x) const
@@ -454,8 +454,8 @@ class BSpline<2, T>
     typedef T            result_type; 
     enum StaticOrder { order = 2 };
 
-    explicit BSpline(unsigned int derivativeOrder = 0)
-    : derivativeOrder_(derivativeOrder)
+    explicit BSpline(unsigned int derivOrder = 0)
+    : derivativeOrder_(derivOrder)
     {}
     
     result_type operator()(argument_type x) const
@@ -580,8 +580,8 @@ class BSpline<3, T>
     typedef T            result_type; 
     enum StaticOrder { order = 3 };
 
-    explicit BSpline(unsigned int derivativeOrder = 0)
-    : derivativeOrder_(derivativeOrder)
+    explicit BSpline(unsigned int derivOrder = 0)
+    : derivativeOrder_(derivOrder)
     {}
     
     result_type operator()(argument_type x) const
@@ -732,8 +732,8 @@ class BSpline<5, T>
     typedef T            result_type; 
     enum StaticOrder { order = 5 };
 
-    explicit BSpline(unsigned int derivativeOrder = 0)
-    : derivativeOrder_(derivativeOrder)
+    explicit BSpline(unsigned int derivOrder = 0)
+    : derivativeOrder_(derivOrder)
     {}
     
     result_type operator()(argument_type x) const
diff -uprN misc/vigra1.4.0/include/vigra/static_assert.hxx misc/build/vigra1.4.0/include/vigra/static_assert.hxx
--- misc/vigra1.4.0/include/vigra/static_assert.hxx	2005-12-21 05:53:45.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/static_assert.hxx	2006-08-31 12:08:15.677548000 +0200
@@ -115,7 +115,7 @@ assertImpl( void (*)(Predicate), typenam
     
 TODO: provide more assertion base classes for other (non boolean) types of tests
 */
-#if !defined(__GNUC__) || __GNUC__ > 2
+#if (!defined(__GNUC__) || __GNUC__ > 2) && (!defined(__SUNPRO_CC) || __SUNPRO_CC > 0x550)
 #define VIGRA_STATIC_ASSERT(Predicate) \
 enum { \
     VIGRA_PREPROCESSOR_CONCATENATE(vigra_assertion_in_line_, __LINE__) = sizeof( \
diff -uprN misc/vigra1.4.0/include/vigra/tinyvector.hxx misc/build/vigra1.4.0/include/vigra/tinyvector.hxx
--- misc/vigra1.4.0/include/vigra/tinyvector.hxx	2005-12-21 05:53:46.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/tinyvector.hxx	2006-08-31 12:31:25.140791000 +0200
@@ -39,6 +39,10 @@
 #ifndef VIGRA_TINYVECTOR_HXX
 #define VIGRA_TINYVECTOR_HXX
 
+#if defined __GNUC__
+#pragma GCC system_header
+#endif
+
 #include <cmath>    // abs(double)
 #include <cstdlib>  // abs(int)
 #include <iosfwd>   // ostream
@@ -49,7 +53,6 @@
 
 namespace vigra {
 
-using VIGRA_CSTD::abs;
 using VIGRA_CSTD::ceil;
 using VIGRA_CSTD::floor;
 
@@ -439,9 +442,9 @@ class TinyVectorBase
         /** Initialize from another sequence (must have length SIZE!)
         */
     template <class Iterator>
-    void init(Iterator i, Iterator end)
+    void init(Iterator i, Iterator iend)
     {
-		vigra_precondition(end-i == SIZE,
+		vigra_precondition(iend-i == SIZE,
             "TinyVector::init(): Sequence has wrong size.");
         Loop::assignCast(data_, i);
     }
diff -uprN misc/vigra1.4.0/include/vigra/transformimage.hxx misc/build/vigra1.4.0/include/vigra/transformimage.hxx
--- misc/vigra1.4.0/include/vigra/transformimage.hxx	2005-12-21 05:53:46.000000000 +0100
+++ misc/build/vigra1.4.0/include/vigra/transformimage.hxx	2006-08-31 12:08:15.727415000 +0200
@@ -986,11 +986,11 @@ class BrightnessContrastFunctor
     result_type operator()(argument_type const & v) const
     {
         promote_type v1 = (v - min_) / diff_;
-        promote_type brighter = pow(v1, b_);
+        promote_type brighter = pow((promote_type)v1, b_);
         promote_type v2 = 2.0 * brighter - one_;
         promote_type contrasted = (v2 < zero_) ?
-                                     -pow(-v2, c_) :
-                                      pow(v2, c_);
+                                     -pow((promote_type)-v2, c_) :
+                                      pow((promote_type)v2, c_);
         return result_type(0.5 * diff_ * (contrasted + one_) + min_);
     }
 
diff -uprN misc/vigra1.4.0/include/vigra/diff2d.hxx misc/build/vigra1.4.0/include/vigra/diff2d.hxx
--- misc/vigra1.4.0/include/vigra/diff2d.hxx	2009-03-02 09:27:34.000000000 +0000
+++ misc/build/vigra1.4.0/include/vigra/diff2d.hxx	2009-03-02 09:27:57.000000000 +0000
@@ -1117,7 +1117,7 @@
     bool contains(Rect2D const &r) const
     {
         return r.isEmpty() ||
-            contains(r.upperLeft()) && contains(r.lowerRight()-Diff2D(1,1));
+            (contains(r.upperLeft()) && contains(r.lowerRight()-Diff2D(1,1)));
     }
 
         /** Return whether this rectangle overlaps with the given
