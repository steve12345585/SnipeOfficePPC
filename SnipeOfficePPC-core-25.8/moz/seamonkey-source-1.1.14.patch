--- misc/mozilla/build/autoconf/mozconfig-find	2007-02-16 03:19:06.000000000 +0100
+++ misc/build/mozilla/build/autoconf/mozconfig-find	2008-08-19 10:12:04.000000000 +0200
@@ -51,10 +51,7 @@
                "$topsrcdir/.mozconfig" \
                "$topsrcdir/mozconfig" \
                "$topsrcdir/mozconfig.sh" \
-               "$topsrcdir/myconfig.sh" \
-               "$HOME/.mozconfig" \
-               "$HOME/.mozconfig.sh" \
-               "$HOME/.mozmyconfig.sh"
+               "$topsrcdir/myconfig.sh"
 do
   if test -f "$_config"; then
     echo "$_config";
--- misc/mozilla/build/cygwin-wrapper	2004-08-19 01:18:55.000000000 +0200
+++ misc/build/mozilla/build/cygwin-wrapper	2008-08-14 16:22:21.000000000 +0200
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!/bin/bash
 #
 # Stupid wrapper to avoid win32 dospath/cygdrive issues
 # Try not to spawn programs from within this file. If the stuff in here looks royally 
@@ -57,12 +57,36 @@
                         i=-I${mountpoint}/${driveletter}/${pathname}
                     fi
                 else
-                    eval 'leader=${i%%'${mountpoint}'/[a-zA-Z]/*}'
-                    if ! test "${leader}" = "${i}"; then
-                        eval 'pathname=${i#'${leader}${mountpoint}'/[a-zA-Z]/}'
-                        eval 'no_mountpoint=${i#'${leader}${mountpoint}'/}'
-                        driveletter=${no_mountpoint%%/*}
-                        i=${leader}${driveletter}:/${pathname}
+      # The original version missed mounted paths, the new version below
+      # doesn't transform /para as this is most likely a parameter.
+      eval 'notinpath=${i%%'${mountpoint}'/[a-zA-Z]/*}'
+      if ! test "$notinpath" = "$i"; then
+         # found  $mountpoint
+         eval 'restpath=${i#'${notinpath}${mountpoint}'/[a-zA-Z]/}'
+         eval 'withdrive=${i#'${notinpath}${mountpoint}'/}'
+         driveletter=${withdrive%%/*}
+         i=${notinpath}${driveletter}:/${restpath}
+      else
+         # check for potential path. Precheck using shell methods
+         doconvert=""
+         # Shortcut -X<path> when path does not begin with '/'
+         noswitch=${i#-[a-zA-Z]}
+         if test "$noswitch" != "$i"; then
+            test "${noswitch#/}" != "$noswitch" && doconvert="1"
+         fi
+         # Precheck for possible path. Consider only absolute paths that contain at least
+         # a second / to prevent converting of /abc parameters.
+         test -z "$doconvert" -a "${i#/[a-zA-Z0-9_.-]*/}" != "$i" && doconvert="1"
+         if test -n "$doconvert"; then
+            # Can be a path. If forking grep would be faster or we could require bash 3
+            # this regexp would be all that's needed to find pathnames that need converting
+            pathname=`echo $i | grep -oE '^(-[a-zA-Z])?/[a-zA-Z0-9_.-]+/[a-zA-Z0-9_./-]+$'`
+            eval 'notinpath=${i%'${pathname}'}'
+            if test "$notinpath" != "$i" -a "$pathname" != "${pathname#/}"; then
+               pathname=`cygpath -am "$pathname"`
+               i=${notinpath}${pathname}
+            fi
+         fi
                     fi
                 fi
             fi
--- misc/mozilla/config/Makefile.in	2006-12-22 14:50:41.000000000 +0100
+++ misc/build/mozilla/config/Makefile.in	2008-08-14 16:22:21.000000000 +0200
@@ -166,7 +166,7 @@
 
 ifdef MOZ_ENABLE_GTK2
   GLIB_CFLAGS = $(MOZ_GTK2_CFLAGS)
-  GLIB_LIBS = $(MOZ_GTK2_LIBS)
+  GLIB_LIBS = $(filter -lglib% -L%,$(MOZ_GTK2_LIBS))
 endif
 
 build_number: FORCE
--- misc/mozilla/config/autoconf.mk.in	2006-09-14 20:07:03.000000000 +0200
+++ misc/build/mozilla/config/autoconf.mk.in	2008-11-07 16:08:52.937500000 +0100
@@ -543,6 +543,7 @@
 MOZ_TOOLS_DIR	= @MOZ_TOOLS_DIR@
 MOZ_DEBUG_SYMBOLS = @MOZ_DEBUG_SYMBOLS@
 MOZ_QUANTIFY	= @MOZ_QUANTIFY@
+MSMANIFEST_TOOL = @MSMANIFEST_TOOL@
 
 #python options
 PYTHON = @MOZ_PYTHON@
--- misc/mozilla/config/config.mk	2008-01-29 20:30:22.000000000 +0100
+++ misc/build/mozilla/config/config.mk	2008-08-14 16:22:21.000000000 +0200
@@ -758,6 +758,23 @@
 endif
 
 #
+# Shared library RUNPATH linker option(s)
+#
+ifeq ($(OS_ARCH),Linux)
+EXTRA_DSO_LDOPTS += -Wl,-rpath,\$$ORIGIN:\$$ORIGIN/../ure-link/lib
+ifdef IS_COMPONENT
+EXTRA_DSO_LDOPTS += -Wl,-rpath,\$$ORIGIN/..:\$$ORIGIN/../../ure-link/lib
+endif # IS_COMPONENT
+endif # Linux
+
+ifeq ($(OS_ARCH),SunOS)
+EXTRA_DSO_LDOPTS += -R '$$ORIGIN'
+ifdef IS_COMPONENT
+EXTRA_DSO_LDOPTS += -R '$$ORIGIN/..'
+endif # IS_COMPONENT
+endif # SunOS
+
+#
 # Include any personal overrides the user might think are needed.
 #
 -include $(MY_CONFIG)
--- misc/mozilla/config/rules.mk	2008-01-29 20:30:22.000000000 +0100
+++ misc/build/mozilla/config/rules.mk	2009-02-16 14:05:23.000000000 +0100
@@ -529,8 +529,9 @@
 ifeq ($(OS_ARCH),WINNT)
 ifdef GNU_CC
 ifndef IS_COMPONENT
-DSO_LDOPTS += -Wl,--out-implib -Wl,$(IMPORT_LIBRARY)
+DSO_LDOPTS += -Wl,--export-all-symbols -Wl,--out-implib -Wl,$(IMPORT_LIBRARY)
 endif
+DSO_LDOPTS += -Wl,--enable-runtime-pseudo-reloc -Wl,-Map -Wl,$(LIB_PREFIX)$(LIBRARY_NAME).map
 endif
 endif
 
@@ -811,6 +810,12 @@
 
 ifeq (_WINNT,$(GNU_CC)_$(OS_ARCH))
 	$(LD) -NOLOGO -OUT:$@ -PDB:$(PDBFILE) $(WIN32_EXE_LDFLAGS) $(LDFLAGS) $(PROGOBJS) $(RESFILE) $(LIBS) $(EXTRA_LIBS) $(OS_LIBS)
+ifdef MSMANIFEST_TOOL
+	@if test -f $@.manifest; then \
+		mt.exe -NOLOGO -MANIFEST $@.manifest -OUTPUTRESOURCE:$@\;1; \
+		rm -f $@.manifest; \
+	fi
+endif	# MSVC with manifest tool
 else
 ifeq ($(CPP_PROG_LINK),1)
 	$(CCC) -o $@ $(CXXFLAGS) $(WRAP_MALLOC_CFLAGS) $(PROGOBJS) $(RESFILE) $(WIN32_EXE_LDFLAGS) $(LDFLAGS) $(LIBS_DIR) $(LIBS) $(OS_LIBS) $(EXTRA_LIBS) $(BIN_FLAGS) $(WRAP_MALLOC_LIB) $(PROFILER_LIBS) $(EXE_DEF_FILE)
@@ -843,6 +848,12 @@
 else
 ifeq (_WINNT,$(GNU_CC)_$(HOST_OS_ARCH))
 	$(HOST_LD) -NOLOGO -OUT:$@ -PDB:$(PDBFILE) $(HOST_OBJS) $(WIN32_EXE_LDFLAGS) $(HOST_LIBS) $(HOST_EXTRA_LIBS)
+ifdef MSMANIFEST_TOOL
+	@if test -f $@.manifest; then \
+		mt.exe -NOLOGO -MANIFEST $@.manifest -OUTPUTRESOURCE:$@\;1; \
+		rm -f $@.manifest; \
+	fi
+endif	# MSVC with manifest tool
 else
 	$(HOST_CC) -o $@ $(HOST_CFLAGS) $(HOST_LDFLAGS) $(HOST_PROGOBJS) $(HOST_LIBS) $(HOST_EXTRA_LIBS)
 endif
@@ -866,6 +877,12 @@
 else
 ifeq (_WINNT,$(GNU_CC)_$(OS_ARCH))
 	$(LD) -nologo -out:$@ -pdb:$(PDBFILE) $< $(WIN32_EXE_LDFLAGS) $(LDFLAGS) $(LIBS) $(EXTRA_LIBS) $(OS_LIBS)
+ifdef MSMANIFEST_TOOL
+	@if test -f $@.manifest; then \
+		mt.exe -NOLOGO -MANIFEST $@.manifest -OUTPUTRESOURCE:$@\;1; \
+		rm -f $@.manifest; \
+	fi
+endif	# MSVC with manifest tool
 else
 ifeq ($(CPP_PROG_LINK),1)
 	$(CCC) $(WRAP_MALLOC_CFLAGS) $(CXXFLAGS) -o $@ $< $(WIN32_EXE_LDFLAGS) $(LDFLAGS) $(LIBS_DIR) $(LIBS) $(OS_LIBS) $(EXTRA_LIBS) $(WRAP_MALLOC_LIB) $(PROFILER_LIBS) $(BIN_FLAGS)
@@ -1019,6 +1036,14 @@
 endif # SHARED_LIBRARY_LIBS
 endif # NO_LD_ARCHIVE_FLAGS
 	$(MKSHLIB) $(SHLIB_LDSTARTFILE) $(OBJS) $(LOBJS) $(SUB_SHLOBJS) $(RESFILE) $(LDFLAGS) $(EXTRA_DSO_LDOPTS) $(OS_LIBS) $(EXTRA_LIBS) $(DEF_FILE) $(SHLIB_LDENDFILE)
+ifeq (_WINNT,$(GNU_CC)_$(OS_ARCH))
+ifdef MSMANIFEST_TOOL
+	@if test -f $@.manifest; then \
+		mt.exe -NOLOGO -MANIFEST $@.manifest -OUTPUTRESOURCE:$@\;2; \
+		rm -f $@.manifest; \
+	fi
+endif	# MSVC with manifest tool
+endif	# WINNT && !GCC
 	@rm -f foodummyfilefoo $(SUB_SHLOBJS) $(DELETE_AFTER_LINK)
 else # os2 vacpp
 	$(MKSHLIB) -O:$@ -DLL -INC:_dllentry $(LDFLAGS) $(OBJS) $(LOBJS) $(EXTRA_DSO_LDOPTS) $(OS_LIBS) $(EXTRA_LIBS) $(DEF_FILE)
@@ -1043,7 +1070,7 @@
 if test -d $(@D); then \
 	echo "Building deps for $<"; \
 	touch $(_MDDEPFILE) && \
-	$(MKDEPEND) -o'.$(OBJ_SUFFIX)' -f$(_MDDEPFILE) $(DEFINES) $(ACDEFINES) $(INCLUDES) $< >/dev/null 2>&1 && \
+	$(MKDEPEND) -o'.$(OBJ_SUFFIX)' -f$(_MDDEPFILE) $(DEFINES) $(ACDEFINES) $(filter-out -I/so/env% ,$(INCLUDES)) $< >/dev/null 2>&1 && \
 	mv $(_MDDEPFILE) $(_MDDEPFILE).old && \
 	cat $(_MDDEPFILE).old | sed -e "s|^$(srcdir)/||" -e "s|^$(win_srcdir)/||" > $(_MDDEPFILE) && rm -f $(_MDDEPFILE).old ; \
 fi
@@ -1053,7 +1080,7 @@
 if test -d $(@D); then \
 	echo "Building deps for $<"; \
 	touch $(_MDDEPFILE) && \
-	$(MKDEPEND) -o'.$(OBJ_SUFFIX)' -f$(_MDDEPFILE) $(DEFINES) $(ACDEFINES) $(INCLUDES) $< >/dev/null 2>&1 && \
+	$(MKDEPEND) -o'.$(OBJ_SUFFIX)' -f$(_MDDEPFILE) $(DEFINES) $(ACDEFINES) $(filter-out -I/so/env% ,$(INCLUDES)) $< >/dev/null 2>&1 && \
 	mv $(_MDDEPFILE) $(_MDDEPFILE).old && \
 	cat $(_MDDEPFILE).old | sed -e "s|^$(<D)/||g" > $(_MDDEPFILE) && rm -f $(_MDDEPFILE).old ; \
 fi
@@ -1696,14 +1724,14 @@
 define MAKE_DEPS_NOAUTO
 	set -e ; \
 	touch $@ && \
-	$(MKDEPEND) -w1024 -o'.$(OBJ_SUFFIX)' -f$@ $(DEFINES) $(ACDEFINES) $(INCLUDES) $(srcdir)/$(<F) >/dev/null 2>&1 && \
+	$(MKDEPEND) -w1024 -o'.$(OBJ_SUFFIX)' -f$@ $(DEFINES) $(ACDEFINES) $(filter-out -I/so/env% ,$(INCLUDES)) $(srcdir)/$(<F) >/dev/null 2>&1 && \
 	mv $@ $@.old && cat $@.old | sed "s|^$(srcdir)/||g" > $@ && rm -f $@.old
 endef
 else
 define MAKE_DEPS_NOAUTO
 	set -e ; \
 	touch $@ && \
-	$(MKDEPEND) -w1024 -o'.$(OBJ_SUFFIX)' -f$@ $(DEFINES) $(ACDEFINES) $(INCLUDES) $< >/dev/null 2>&1 && \
+	$(MKDEPEND) -w1024 -o'.$(OBJ_SUFFIX)' -f$@ $(DEFINES) $(ACDEFINES) $(filter-out -I/so/env% ,$(INCLUDES)) $< >/dev/null 2>&1 && \
 	mv $@ $@.old && cat $@.old | sed "s|^$(<D)/||g" > $@ && rm -f $@.old
 endef
 endif # WINNT
--- misc/mozilla/configure	2008-10-30 23:05:30.000000000 +0100
+++ misc/build/mozilla/configure	2009-02-12 15:20:18.597579000 +0100
@@ -1068,6 +1068,8 @@
 GCONF_VERSION=1.2.1
 LIBGNOME_VERSION=2.0
 
+MSMANIFEST_TOOL=
+
 MISSING_X=
 for ac_prog in gawk mawk nawk awk
 do
@@ -3022,9 +3024,26 @@
             _CC_SUITE=7
         elif test "$_CC_MAJOR_VERSION" = "14"; then
             _CC_SUITE=8
+            CXXFLAGS="$CXXFLAGS -Zc:wchar_t-"
         else
             { echo "configure: error: This version of the MSVC compiler, $CC_VERSION , is unsupported." 1>&2; exit 1; }
         fi
+	
+	# bug #249782
+	# ensure that mt.exe is Microsoft (R) Manifest Tool and not magnetic tape manipulation utility (or something else)
+	if test "$_CC_SUITE" -ge "8"; then
+		MSMT_TOOL=`mt 2>&1|grep 'Microsoft (R) Manifest Tool'`
+		if test -n "MSMT_TOOL"; then
+			MSMANIFEST_TOOL_VERSION=`echo ${MSMANIFEST_TOOL}|grep -Po "(^|\s)[0-9]+\.[0-9]+\.[0-9]+(\.[0-9]+)?(\s|$)"`
+			if test -z "MSMANIFEST_TOOL_VERSION"; then
+				echo "configure: warning: Unknown version of the Microsoft (R) Manifest Tool." 1>&2
+			fi
+			MSMANIFEST_TOOL=1
+			unset MSMT_TOOL
+		else
+			{ echo "Microsoft (R) Manifest Tool must be in your \$PATH." 1>&2; exit 1; }
+		fi
+	fi
 
         # Check linker version
         _LD_FULL_VERSION=`"${LD}" -v 2>&1 | sed -ne "$_MSVC_VER_FILTER"`
@@ -3422,6 +3441,8 @@
 ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
 cross_compiling=$ac_cv_prog_cc_cross
 fi
+else
+  ac_cv_prog_CXXCPP="$CXXCPP"
 fi
 CXXCPP="$ac_cv_prog_CXXCPP"
 echo "$ac_t""$CXXCPP" 1>&6
@@ -5726,6 +5747,7 @@
         if test "`echo ${srcdir} | grep -c ^/ 2>/dev/null`" = 0; then
             _pwd=`pwd`
             CYGWIN_WRAPPER="${_pwd}/${srcdir}/build/cygwin-wrapper"
+	    CYGWIN_WRAPPER=`cygpath -u $CYGWIN_WRAPPER`
         fi
         if test "`${PERL} -v | grep -c cygwin  2>/dev/null`" = 0; then
             AS_PERL=1
@@ -6036,7 +6058,7 @@
     CXXFLAGS="$CXXFLAGS -fpascal-strings -no-cpp-precomp -fno-common"
     DLL_SUFFIX=".dylib"
     DSO_LDOPTS=''
-    STRIP="$STRIP -x -S"
+    STRIP="$STRIP -X -S" # MACOSX 10.5 strip -x sometimes fails
     _PLATFORM_DEFAULT_TOOLKIT='mac'
     MOZ_ENABLE_POSTSCRIPT=
     TARGET_NSPR_MDCPUCFG='\"md/_darwin.cfg\"'
@@ -6075,7 +6097,7 @@
     ;;
 
 *-freebsd*)
-    if test `test -x /usr/bin/objformat && /usr/bin/objformat || echo aout` != "elf"; then
+    if test `test -x /usr/bin/objformat && /usr/bin/objformat || echo elf` != "elf"; then
 	DLL_SUFFIX=".so.1.0"
 	DSO_LDOPTS="-shared"
     fi
@@ -6455,12 +6477,12 @@
 
 
         case "$host" in
-    *-mingw*)
-	CYGPATH_W=echo
+    *-cygwin*|*-mingw*)
+	CYGPATH_W="cygpath -u"
 	CYGPATH_S=cat
-	MOZ_BUILD_ROOT=`cd $MOZ_BUILD_ROOT && pwd -W`
+	MOZ_BUILD_ROOT=`$CYGPATH_W $MOZ_BUILD_ROOT | $CYGPATH_S`
 	;;
-    *-cygwin*|*-msvc*|*-mks*)
+    *-msvc*|*-mks*)
 	CYGPATH_W="cygpath -a -w"
 	CYGPATH_S="sed -e s|\\\\|/|g"
 	MOZ_BUILD_ROOT=`$CYGPATH_W $MOZ_BUILD_ROOT | $CYGPATH_S`
@@ -6718,7 +6740,7 @@
     MOZ_USER_DIR="Mozilla"
 
     if test "$MOZTOOLS"; then
-        MOZ_TOOLS_DIR=`echo $MOZTOOLS | sed -e 's|\\\\|/|g'`
+        MOZ_TOOLS_DIR=`echo $MOZTOOLS`
     else
         { echo "configure: error: MOZTOOLS is not set" 1>&2; exit 1; }
     fi
@@ -8614,6 +8636,8 @@
 case $target in
 *-hpux11.*)
 	;;
+*-freebsd*)
+	;;
 *)
 	echo $ac_n "checking for gethostbyname_r in -lc_r""... $ac_c" 1>&6
 echo "configure:8620: checking for gethostbyname_r in -lc_r" >&5
@@ -19233,7 +19257,8 @@
            MOZ_CAIRO_LIBS="-lmozcairo -lmozlibpixman $CAIRO_FT_LIBS"
 
            if test "$MOZ_X11"; then
-               MOZ_CAIRO_LIBS="$MOZ_CAIRO_LIBS $XLDFLAGS -lXrender $XLIBS -lfontconfig -lfreetype"
+#               MOZ_CAIRO_LIBS="$MOZ_CAIRO_LIBS $XLDFLAGS -lXrender $XLIBS -lfontconfig -lfreetype"
+               MOZ_CAIRO_LIBS="$MOZ_CAIRO_LIBS $XLDFLAGS $XLIBS -lfontconfig -lfreetype"
            fi
            if test "$MOZ_WIDGET_TOOLKIT" = "windows"; then
                MOZ_CAIRO_LIBS="$MOZ_CAIRO_LIBS -lgdi32"
@@ -20076,8 +20101,12 @@
     WIN_TOP_SRC=`cd $srcdir; pwd -W`
     ;;
 cygwin*|msvc*|mks*)
-    HOST_CC="\$(CYGWIN_WRAPPER) $HOST_CC"
-    HOST_CXX="\$(CYGWIN_WRAPPER) $HOST_CXX"
+# Don't add the wrapper for the HOST_* versions as they contain an
+# unexpanded $CC and therfore wil get the wrapper below.
+    if test -n "$GNU_CC"; then
+     HOST_CC="\$(CYGWIN_WRAPPER) $HOST_CC"
+     HOST_CXX="\$(CYGWIN_WRAPPER) $HOST_CXX"
+    fi
     CC="\$(CYGWIN_WRAPPER) $CC"
     CXX="\$(CYGWIN_WRAPPER) $CXX"
     CPP="\$(CYGWIN_WRAPPER) $CPP"
--- misc/mozilla/configure.in	2008-10-30 23:05:31.000000000 +0100
+++ misc/build/mozilla/configure.in	2009-02-05 20:12:45.456777753 +0100
@@ -126,6 +126,8 @@
 GCONF_VERSION=1.2.1
 LIBGNOME_VERSION=2.0
 
+MSMANIFEST_TOOL=
+
 dnl Set various checks
 dnl ========================================================
 MISSING_X=
@@ -425,9 +427,26 @@
             _CC_SUITE=7
         elif test "$_CC_MAJOR_VERSION" = "14"; then
             _CC_SUITE=8
+            CXXFLAGS="$CXXFLAGS -Zc:wchar_t-"
         else
             AC_MSG_ERROR([This version of the MSVC compiler, $CC_VERSION , is unsupported.])
         fi
+	
+	# bug #249782
+	# ensure that mt.exe is Microsoft (R) Manifest Tool and not magnetic tape manipulation utility (or something else)
+	if test "$_CC_SUITE" -ge "8"; then
+		MSMT_TOOL=`mt 2>&1|grep 'Microsoft (R) Manifest Tool'`
+		if test -n "MSMT_TOOL"; then
+			MSMANIFEST_TOOL_VERSION=`echo ${MSMANIFEST_TOOL}|grep -Po "(^|\s)[0-9]+\.[0-9]+\.[0-9]+(\.[0-9]+)?(\s|$)"`
+			if test -z "MSMANIFEST_TOOL_VERSION"; then
+				AC_MSG_WARN([Unknown version of the Microsoft (R) Manifest Tool.])
+			fi
+			MSMANIFEST_TOOL=1
+			unset MSMT_TOOL
+		else
+			AC_MSG_ERROR([Microsoft (R) Manifest Tool must be in your \$PATH.])
+		fi
+	fi
 
         # Check linker version
         _LD_FULL_VERSION=`"${LD}" -v 2>&1 | sed -ne "$_MSVC_VER_FILTER"`
@@ -1530,7 +1549,7 @@
     CXXFLAGS="$CXXFLAGS -fpascal-strings -no-cpp-precomp -fno-common"
     DLL_SUFFIX=".dylib"
     DSO_LDOPTS=''
-    STRIP="$STRIP -x -S"
+    STRIP="$STRIP -X -S" # MACOSX 10.5 strip -x sometimes fails
     _PLATFORM_DEFAULT_TOOLKIT='mac'
     MOZ_ENABLE_POSTSCRIPT=
     TARGET_NSPR_MDCPUCFG='\"md/_darwin.cfg\"'
@@ -1552,7 +1571,7 @@
     ;;
 
 *-freebsd*)
-    if test `test -x /usr/bin/objformat && /usr/bin/objformat || echo aout` != "elf"; then
+    if test `test -x /usr/bin/objformat && /usr/bin/objformat || echo elf` != "elf"; then
 	DLL_SUFFIX=".so.1.0"
 	DSO_LDOPTS="-shared"
     fi
@@ -1853,10 +1872,10 @@
 
     dnl MinGW/MSYS doesn't provide or need cygpath
     case "$host" in
-    *-mingw*)
-	CYGPATH_W=echo
+    *-cygwin*|*-mingw*)
+	CYGPATH_W="cygpath -u"
 	CYGPATH_S=cat
-	MOZ_BUILD_ROOT=`cd $MOZ_BUILD_ROOT && pwd -W`
+	MOZ_BUILD_ROOT=`$CYGPATH_W $MOZ_BUILD_ROOT | $CYGPATH_S`
 	;;
     *-cygwin*|*-msvc*|*-mks*)
 	CYGPATH_W="cygpath -a -w"
@@ -2749,6 +2768,8 @@
 case $target in
 *-hpux11.*)
 	;;
+*-freebsd*)
+	;;
 *)
 	AC_CHECK_LIB(c_r, gethostbyname_r)
 	;;
@@ -7321,6 +7342,7 @@
 AC_SUBST(USE_N32)
 AC_SUBST(CC_VERSION)
 AC_SUBST(CXX_VERSION)
+AC_SUBST(MSMANIFEST_TOOL)
 
 if test "$USING_HCC"; then
    CC='${topsrcdir}/build/hcc'
@@ -7416,8 +7438,12 @@
     WIN_TOP_SRC=`cd $srcdir; pwd -W`
     ;;
 cygwin*|msvc*|mks*)
-    HOST_CC="\$(CYGWIN_WRAPPER) $HOST_CC"
-    HOST_CXX="\$(CYGWIN_WRAPPER) $HOST_CXX"
+# Don't add the wrapper for the HOST_* versions as they contain an
+# unexpanded $CC and therfore wil get the wrapper below.
+    if test -n "$GNU_CC"; then
+     HOST_CC="\$(CYGWIN_WRAPPER) $HOST_CC"
+     HOST_CXX="\$(CYGWIN_WRAPPER) $HOST_CXX"
+    fi 
     CC="\$(CYGWIN_WRAPPER) $CC"
     CXX="\$(CYGWIN_WRAPPER) $CXX"
     CPP="\$(CYGWIN_WRAPPER) $CPP"
--- misc/mozilla/directory/c-sdk/build.mk	2006-02-03 15:44:29.000000000 +0100
+++ misc/build/mozilla/directory/c-sdk/build.mk	2008-08-14 16:22:21.000000000 +0200
@@ -384,7 +384,7 @@
 ifdef NS_USE_GCC
 LINK_EXE	= $(CC) -o $@ $(LDFLAGS) $(LCFLAGS) $(DEPLIBS) $(OBJS) $(EXTRA_LIBS) $(PLATFORMLIBS)
 LINK_LIB	= $(AR) cr $@ $(OBJS)
-LINK_DLL	= $(CC) -shared -Wl,--export-all-symbols -Wl,--out-implib -Wl,$(@:.$(DLL_SUFFIX)=.$(LIB_SUFFIX)) $(LLFLAGS) $(DLL_LDFLAGS) -o $@ $(OBJS) $(EXTRA_LIBS) $(EXTRA_DLL_LIBS)
+LINK_DLL	= $(CC) -shared -Wl,--enable-runtime-pseudo-reloc -Wl,--export-all-symbols -Wl,--out-implib -Wl,$(LIB_PREFIX)$(@:.$(DLL_SUFFIX)=.$(LIB_SUFFIX)) $(LLFLAGS) $(DLL_LDFLAGS) -o $@ $(OBJS) $(EXTRA_LIBS) $(EXTRA_DLL_LIBS)
 else
 DEBUG_LINK_OPT=-DEBUG
 ifeq ($(BUILD_OPT), 1)
--- misc/mozilla/directory/c-sdk/config/FreeBSD.mk	2006-02-03 15:41:11.000000000 +0100
+++ misc/build/mozilla/directory/c-sdk/config/FreeBSD.mk	2008-08-14 16:22:21.000000000 +0200
@@ -70,7 +70,7 @@
 
 ARCH			= freebsd
 
-MOZ_OBJFORMAT          := $(shell test -x /usr/bin/objformat && /usr/bin/objformat || echo aout)
+MOZ_OBJFORMAT          := $(shell test -x /usr/bin/objformat && /usr/bin/objformat || echo elf)
 
 ifeq ($(MOZ_OBJFORMAT),elf)
 DLL_SUFFIX		= so
--- misc/mozilla/directory/c-sdk/config/autoconf.mk.in	2006-02-23 00:58:25.000000000 +0100
+++ misc/build/mozilla/directory/c-sdk/config/autoconf.mk.in	2008-08-14 16:22:21.000000000 +0200
@@ -25,6 +25,7 @@
 LIB_SUFFIX	= @LIB_SUFFIX@
 LIB_PREFIX	= @LIB_PREFIX@
 DLL_SUFFIX	= @DLL_SUFFIX@
+DLL_PREFIX	= @DLL_PREFIX@
 ASM_SUFFIX	= @ASM_SUFFIX@
 PROG_SUFFIX	= @PROG_SUFFIX@
 MOD_NAME	= @NSPR_MODNAME@
--- misc/mozilla/directory/c-sdk/config/cygwin-wrapper	2004-08-19 01:18:55.000000000 +0200
+++ misc/build/mozilla/directory/c-sdk/config/cygwin-wrapper	2008-08-14 16:22:21.000000000 +0200
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!/bin/bash
 #
 # Stupid wrapper to avoid win32 dospath/cygdrive issues
 # Try not to spawn programs from within this file. If the stuff in here looks royally 
--- misc/mozilla/directory/c-sdk/configure	2006-02-23 01:58:13.000000000 +0100
+++ misc/build/mozilla/directory/c-sdk/configure	2008-08-14 16:22:21.000000000 +0200
@@ -2738,6 +2738,7 @@
 LIB_SUFFIX=a
 LIB_PREFIX=lib
 DLL_SUFFIX=so
+DLL_PREFIX=lib
 ASM_SUFFIX=s
 MKSHLIB='$(LD) $(DSO_LDOPTS) -o $@'
 PR_MD_ASFILES=
@@ -3444,7 +3445,7 @@
 EOF
 
     CFLAGS="$CFLAGS $(DSO_CFLAGS) -ansi -Wall"
-    MOZ_OBJFORMAT=`test -x /usr/bin/objformat && /usr/bin/objformat || echo aout`
+    MOZ_OBJFORMAT=`test -x /usr/bin/objformat && /usr/bin/objformat || echo elf`
     if test "$MOZ_OBJFORMAT" = "elf"; then
         DLL_SUFFIX=so
     else
@@ -3811,6 +3812,7 @@
     MKSHLIB='$(CC) $(DSO_LDOPTS) -o $@'
     DSO_CFLAGS=-fPIC
     DSO_LDOPTS='-shared -Wl,-soname -Wl,$(notdir $@)'
+    DSO_LDOPTS="$DSO_LDOPTS -Wl,-rpath,'$\$ORIGIN:$\$ORIGIN/../ure-link/lib'"
     OS_LIBS="$OS_LIBS -lc"
     _OPTIMIZE_FLAGS=-O2
     _DEBUG_FLAGS="-g -fno-inline"  # most people on linux use gcc/gdb, and that
@@ -3880,7 +3882,8 @@
         CC="$CC -mno-cygwin"
         CXX="$CXX -mno-cygwin"
         DLL_SUFFIX=dll
-        MKSHLIB='$(CC) -shared -Wl,--export-all-symbols -Wl,--out-implib -Wl,$(IMPORT_LIBRARY) -o $@'
+	DLL_PREFIX=
+        MKSHLIB='$(CC) -shared -Wl,--enable-runtime-pseudo-reloc -Wl,--export-all-symbols -Wl,--out-implib -Wl,$(IMPORT_LIBRARY) -o $@'
         # Use temp file for windres (bug 213281)
         RC="$WINDRES -O coff --use-temp-file"
     else
@@ -3897,6 +3900,7 @@
 	    LIB_SUFFIX=lib
 	    LIB_PREFIX=
 	    DLL_SUFFIX=dll
+	    DLL_PREFIX=
         
         CFLAGS="$CFLAGS -W3 -nologo -GF -Gy"
         DLLFLAGS='-OUT:"$@"'
@@ -4293,6 +4297,7 @@
     NSINSTALL=nsinstall
     LIB_PREFIX=
     LIB_SUFFIX=lib
+    DLL_PREFIX=
     DLL_SUFFIX=dll
     DLLTOOL=''
     RC=rc.exe
@@ -4660,6 +4665,7 @@
     LD=/usr/ccs/bin/ld
     RANLIB=/usr/ccs/bin/ranlib
     DSO_LDOPTS='-G -h $(notdir $@)'
+    DSO_LDOPTS="$DSO_LDOPTS -R '$\$ORIGIN'"
     if test -n "$GNU_CC"; then
         DSO_CFLAGS=-fPIC
     else
@@ -5844,6 +5850,7 @@
 s%@LIB_SUFFIX@%$LIB_SUFFIX%g
 s%@LIB_PREFIX@%$LIB_PREFIX%g
 s%@DLL_SUFFIX@%$DLL_SUFFIX%g
+s%@DLL_PREFIX@%$DLL_PREFIX%g
 s%@ASM_SUFFIX@%$ASM_SUFFIX%g
 s%@PROG_SUFFIX@%$PROG_SUFFIX%g
 s%@MKSHLIB@%$MKSHLIB%g
--- misc/mozilla/directory/c-sdk/configure.in	2007-07-15 16:41:07.000000000 +0200
+++ misc/build/mozilla/directory/c-sdk/configure.in	2008-08-14 16:22:21.000000000 +0200
@@ -549,6 +549,7 @@
 LIB_SUFFIX=a
 LIB_PREFIX=lib
 DLL_SUFFIX=so
+DLL_PREFIX=lib
 ASM_SUFFIX=s
 MKSHLIB='$(LD) $(DSO_LDOPTS) -o $@'
 PR_MD_ASFILES=
@@ -1037,7 +1038,7 @@
     AC_DEFINE(FREEBSD)
     AC_DEFINE(HAVE_BSD_FLOCK)
     CFLAGS="$CFLAGS $(DSO_CFLAGS) -ansi -Wall"
-    MOZ_OBJFORMAT=`test -x /usr/bin/objformat && /usr/bin/objformat || echo aout`
+    MOZ_OBJFORMAT=`test -x /usr/bin/objformat && /usr/bin/objformat || echo elf`
     if test "$MOZ_OBJFORMAT" = "elf"; then
         DLL_SUFFIX=so
     else
@@ -1285,6 +1286,7 @@
     MKSHLIB='$(CC) $(DSO_LDOPTS) -o $@'
     DSO_CFLAGS=-fPIC
     DSO_LDOPTS='-shared -Wl,-soname -Wl,$(notdir $@)'
+    DSO_LDOPTS="$DSO_LDOPTS -Wl,-rpath,'$\$ORIGIN:$\$ORIGIN/../ure-link/lib'"
     OS_LIBS="$OS_LIBS -lc"
     _OPTIMIZE_FLAGS=-O2
     _DEBUG_FLAGS="-g -fno-inline"  # most people on linux use gcc/gdb, and that
@@ -1336,6 +1338,8 @@
         CC="$CC -mno-cygwin"
         CXX="$CXX -mno-cygwin"
         DLL_SUFFIX=dll
+        DLL_SUFFIX=dll
+	DLL_PREFIX=
         MKSHLIB='$(CC) -shared -Wl,--export-all-symbols -Wl,--out-implib -Wl,$(IMPORT_LIBRARY) -o $@'
         # Use temp file for windres (bug 213281)
         RC="$WINDRES -O coff --use-temp-file"
@@ -1353,6 +1357,7 @@
 	    LIB_SUFFIX=lib
 	    LIB_PREFIX=
 	    DLL_SUFFIX=dll
+	    DLL_PREFIX=
         
         CFLAGS="$CFLAGS -W3 -nologo -GF -Gy"
         DLLFLAGS='-OUT:"$@"'
@@ -1820,6 +1825,7 @@
     LD=/usr/ccs/bin/ld
     RANLIB=/usr/ccs/bin/ranlib
     DSO_LDOPTS='-G -h $(notdir $@)'
+    DSO_LDOPTS="$DSO_LDOPTS -R '$\$ORIGIN'"
     if test -n "$GNU_CC"; then
         DSO_CFLAGS=-fPIC
     else
@@ -2410,6 +2416,7 @@
 AC_SUBST(LIB_SUFFIX)
 AC_SUBST(LIB_PREFIX)
 AC_SUBST(DLL_SUFFIX)
+AC_SUBST(DLL_PREFIX)
 AC_SUBST(ASM_SUFFIX)
 AC_SUBST(PROG_SUFFIX)
 AC_SUBST(MKSHLIB)
--- misc/mozilla/directory/c-sdk/ldap/include/Makefile.in	2006-02-03 15:44:33.000000000 +0100
+++ misc/build/mozilla/directory/c-sdk/ldap/include/Makefile.in	2008-11-02 21:55:34.929250000 +0100
@@ -85,6 +85,11 @@
 
 ###########################################################################
 
+ifeq ($(TERM),cygwin)
+INCLUDEDIR:=$(shell cygpath -u $(INCLUDEDIR))
+GENHEADERS:=$(shell cygpath -u $(GENHEADERS))
+endif
+
 all export::	$(INCLUDEDIR) $(GENHEADERS)
 	$(NSINSTALL) -D $(PRIVATEINCDIR)
 	$(INSTALL) $(INSTALLFLAGS) -m 644 $(HEADERS) $(INCLUDEDIR)
--- misc/mozilla/directory/c-sdk/ldap/libraries/libldap/Makefile.in	2006-02-03 15:44:42.000000000 +0100
+++ misc/build/mozilla/directory/c-sdk/ldap/libraries/libldap/Makefile.in	2008-08-14 16:22:21.000000000 +0200
@@ -109,7 +109,7 @@
 HDIR		= $(topsrcdir)/ldap/include
 
 LIBLDAP		= $(addprefix $(OBJDIR_NAME)/, $(LIB_PREFIX)$(LDAP_LIBNAME).$(LIB_SUFFIX))
-DLLLDAP		= $(addprefix $(OBJDIR_NAME)/, $(LIB_PREFIX)$(LDAP_LIBNAME).$(DLL_SUFFIX))
+DLLLDAP		= $(addprefix $(OBJDIR_NAME)/, $(DLL_PREFIX)$(LDAP_LIBNAME).$(DLL_SUFFIX))
 
 INSTALLDIR	= $(DIST)/$(OBJDIR_NAME)
 
@@ -320,6 +320,10 @@
 	-$(RM) $(SO_FILES_TO_REMOVE)
 endif
 	$(LINK_DLL) $(LDAP_EXPORT_FLAGS) $(EXTRA_LIBS)
+	if test -f $@.manifest; then \
+		mt.exe -NOLOGO -MANIFEST $@.manifest -OUTPUTRESOURCE:$@\;2; \
+		rm -f $@.manifest; \
+	fi
 
 veryclean:: clean
 
--- misc/mozilla/directory/c-sdk/ldap/libraries/libprldap/Makefile.in	2006-02-03 15:44:49.000000000 +0100
+++ misc/build/mozilla/directory/c-sdk/ldap/libraries/libprldap/Makefile.in	2008-08-14 16:22:21.000000000 +0200
@@ -62,7 +62,7 @@
 LIBPRLDAP =
 endif
 DLLPRLDAP	= $(addprefix $(OBJDIR_NAME)/, \
-			$(LIB_PREFIX)$(PRLDAP_LIBNAME).$(DLL_SUFFIX))
+			$(DLL_PREFIX)$(PRLDAP_LIBNAME).$(DLL_SUFFIX))
 
 INSTALLDIR      = $(DIST)/$(OBJDIR_NAME)
 
--- misc/mozilla/directory/c-sdk/ldap/libraries/libssldap/Makefile	2004-08-26 01:02:30.000000000 +0200
+++ misc/build/mozilla/directory/c-sdk/ldap/libraries/libssldap/Makefile	2008-08-14 16:22:21.000000000 +0200
@@ -41,7 +41,7 @@
 HDIR		= $(topsrcdir)/ldap/include
 
 LIBSSLDAP	= $(addprefix $(SSLOBJDEST)/, $(LIB_PREFIX)$(SSLDAP_LIBNAME).$(LIB_SUFFIX))
-DLLSSLDAP	= $(addprefix $(SSLOBJDEST)/, $(LIB_PREFIX)$(SSLDAP_LIBNAME).$(DLL_SUFFIX))
+DLLSSLDAP	= $(addprefix $(SSLOBJDEST)/, $(DLL_PREFIX)$(SSLDAP_LIBNAME).$(DLL_SUFFIX))
 
 INSTALLDIR      = $(DIST)/$(OBJDIR_NAME)
 
@@ -76,7 +92,7 @@
 
 # variable definitions for exported symbols
 ifeq ($(OS_ARCH), WINNT)
-        SSLDAP_EXPORT_DEFS= $(srcdir)/../msdos/winsock/nsldapssl32.def
+        SSLDAP_EXPORT_DEFS= $(win_srcdir)/../msdos/winsock/nsldapssl32.def
 else
         SSLDAP_EXPORT_DEFS= $(SSLOBJDEST)/libldap_ssl.exp
 endif
--- misc/mozilla/directory/c-sdk/ldap/libraries/libssldap/Makefile.in	2006-02-03 15:44:49.000000000 +0100
+++ misc/build/mozilla/directory/c-sdk/ldap/libraries/libssldap/Makefile.in	2008-08-14 16:22:21.000000000 +0200
@@ -56,7 +56,7 @@
 HDIR		= $(topsrcdir)/ldap/include
 
 LIBSSLDAP	= $(addprefix $(SSLOBJDEST)/, $(LIB_PREFIX)$(SSLDAP_LIBNAME).$(LIB_SUFFIX))
-DLLSSLDAP	= $(addprefix $(SSLOBJDEST)/, $(LIB_PREFIX)$(SSLDAP_LIBNAME).$(DLL_SUFFIX))
+DLLSSLDAP	= $(addprefix $(SSLOBJDEST)/, $(DLL_PREFIX)$(SSLDAP_LIBNAME).$(DLL_SUFFIX))
 
 INSTALLDIR      = $(DIST)/$(OBJDIR_NAME)
 
--- misc/mozilla/embedding/browser/gtk/src/Makefile.in	2006-03-22 19:22:41.000000000 +0100
+++ misc/build/mozilla/embedding/browser/gtk/src/Makefile.in	2008-08-14 16:22:21.000000000 +0200
@@ -112,14 +112,14 @@
 		gtkmozembed_internal.h
 
 ifdef MOZ_ENABLE_GTK
-EXTRA_DSO_LDOPTS = \
+EXTRA_DSO_LDOPTS += \
 		$(MOZ_COMPONENT_LIBS) \
 		-lgtksuperwin \
 		$(NULL)
 endif
 
 ifdef MOZ_ENABLE_GTK2
-EXTRA_DSO_LDOPTS = \
+EXTRA_DSO_LDOPTS += \
 		$(MOZ_COMPONENT_LIBS) \
 		$(NULL)
 endif
--- misc/mozilla/embedding/browser/gtk/tests/Makefile.in	2006-03-24 17:10:37.000000000 +0100
+++ misc/build/mozilla/embedding/browser/gtk/tests/Makefile.in	2008-08-14 16:22:21.000000000 +0200
@@ -63,10 +63,11 @@
 		TestGtkEmbedNotebook.cpp \
 		TestGtkEmbedSocket.cpp \
 		TestGtkEmbedChild.cpp
-endif
 
 SIMPLE_PROGRAMS = $(CPPSRCS:.cpp=)
 
+endif
+
 # ENABLE_GNOME=1
 
 ifdef ENABLE_GNOME
--- misc/mozilla/embedding/components/printingui/src/mac/printpde/Makefile.in	2005-06-20 21:24:51.000000000 +0200
+++ misc/build/mozilla/embedding/components/printingui/src/mac/printpde/Makefile.in	2009-02-19 13:11:39.000000000 +0100
@@ -68,25 +68,15 @@
 
 unexport CC CXX
 
-ABS_topsrcdir   := $(shell cd $(topsrcdir); pwd)
-ifneq ($(ABS_topsrcdir),$(MOZ_BUILD_ROOT))
-export::
-	rsync -a --exclude .DS_Store --exclude "CVS/" $(srcdir)/$(PROJECT) .
-	ln -fs $(srcdir)/src
-	ln -fs $(srcdir)/res
-	ln -fs $(srcdir)/public
-	ln -fs $(srcdir)/Info-*.plist .
-endif
-
 libs::
 # Bug 297227: The next line doesn't need to stay around forever, only
 # long enough to clean up existing depend builds from when xcodebuild
 # was being instructed to "install"
 	if test -e build/UninstalledProducts ; then $(MAKE) clean ; rm -rf $(DIST)/package/PrintPDE.plugin ; fi
 
-	$(PBBUILD) $(PROJECT_ARG) -target PrintPDE -buildstyle $(BUILDSTYLE) $(PBBUILD_ARG)
-	mkdir -p $(DIST)/package
-	$(INSTALL) $(XCODE_PRODUCT_DIR)/PrintPDE.plugin $(DIST)/package
+#	$(PBBUILD) $(PROJECT_ARG) -target PrintPDE -buildstyle $(BUILDSTYLE) $(PBBUILD_ARG)
+#	mkdir -p $(DIST)/package
+#	$(INSTALL) $(XCODE_PRODUCT_DIR)/PrintPDE.plugin $(DIST)/package
 
 clean clobber::
 	rm -rf build
--- misc/mozilla/embedding/config/Makefile.in	2007-10-08 21:08:15.000000000 +0200
+++ misc/build/mozilla/embedding/config/Makefile.in	2008-08-14 16:22:21.000000000 +0200
@@ -110,7 +110,7 @@
 	$(NSINSTALL) -t $(srcdir)/installed-chrome.txt $(DIST)/Embed/chrome
 	$(NSINSTALL) -t $(srcdir)/readme.html $(DIST)/Embed
 ifndef MINIMO
-	-$(NSINSTALL) -t $(DEPTH)/embedding/lite/$(LIB_PREFIX)embed_lite$(DLL_SUFFIX) $(DIST)/Embed/components
+	-$(NSINSTALL) -t $(DEPTH)/embedding/lite/$(DLL_PREFIX)embed_lite$(DLL_SUFFIX) $(DIST)/Embed/components
 endif
 ifeq ($(OS_ARCH),WINNT)
 ifeq ($(WINAPP),mfcembed)
--- misc/mozilla/extensions/pref/autoconfig/src/Makefile.in	2006-02-03 15:41:09.000000000 +0100
+++ misc/build/mozilla/extensions/pref/autoconfig/src/Makefile.in	2008-08-14 16:22:21.000000000 +0200
@@ -85,7 +85,7 @@
 endif
 
 
-EXTRA_DSO_LDOPTS = \
+EXTRA_DSO_LDOPTS += \
                    $(LIBS_DIR) \
                    $(MOZ_JS_LIBS) \
                    $(MOZ_COMPONENT_LIBS) \
--- misc/mozilla/extensions/sql/build/Makefile.in	2004-11-29 18:39:08.000000000 +0100
+++ misc/build/mozilla/extensions/sql/build/Makefile.in	2008-08-18 14:03:04.000000000 +0200
@@ -55,5 +55,5 @@
 	bin/components/sqlpgsql.xpt \
 	bin/components/sqlsqlite.xpt \
 	bin/components/sqlmysql.xpt \
-	bin/components/$(LIB_PREFIX)sql$(DLL_SUFFIX) \
+	bin/components/$(DLL_PREFIX)sql$(DLL_SUFFIX) \
 	bin/chrome/sql.jar
--- misc/mozilla/gfx/idl/nsIFreeType2.idl	2004-04-16 01:30:02.000000000 +0200
+++ misc/build/mozilla/gfx/idl/nsIFreeType2.idl	2008-08-14 16:22:21.000000000 +0200
@@ -76,10 +76,11 @@
 native FT_Sfnt_Tag(FT_Sfnt_Tag);
 native FT_Size(FT_Size);
 
-[ptr] native FTC_Image_Desc_p(FTC_Image_Desc);
+[ptr] native FTC_ImageType_p(FTC_ImageType);
 native FTC_Face_Requester(FTC_Face_Requester);
 native FTC_Font(FTC_Font);
-native FTC_Image_Cache(FTC_Image_Cache);
+native FTC_FaceID(FTC_FaceID);
+native FTC_ImageCache(FTC_ImageCache);
 native FTC_Manager(FTC_Manager);
 
 // #ifdef MOZ_SVG
@@ -99,7 +100,7 @@
 
     readonly attribute FT_Library library;
     readonly attribute FTC_Manager FTCacheManager;
-    readonly attribute FTC_Image_Cache ImageCache;
+    readonly attribute FTC_ImageCache ImageCache;
 
     void    doneFace(in FT_Face face);
     void    doneFreeType(in FT_Library lib);
@@ -115,16 +116,16 @@
     void    outlineDecompose(in FT_Outline_p outline,
                              in const_FT_Outline_Funcs_p funcs, in voidPtr p);
     void    setCharmap(in FT_Face face, in FT_CharMap charmap);
-    void    imageCacheLookup(in FTC_Image_Cache cache, in FTC_Image_Desc_p desc,
+    void    imageCacheLookup(in FTC_ImageCache cache, in FTC_ImageType_p desc,
                              in FT_UInt gindex, out FT_Glyph glyph);
-    void    managerLookupSize(in FTC_Manager manager, in FTC_Font font,
-                              out FT_Face face, out FT_Size size);
+    void    managerLookupFace(in FTC_Manager manager, in FTC_FaceID face_id,
+                              out FT_Face face);
     void    managerDone(in FTC_Manager manager);
     void    managerNew(in FT_Library lib, in FT_UInt max_faces,
                        in FT_UInt max_sizes, in FT_ULong max_bytes,
                        in FTC_Face_Requester requester, in FT_Pointer req_data,
                        out FTC_Manager manager);
-    void    imageCacheNew(in FTC_Manager manager, out FTC_Image_Cache cache);
+    void    imageCacheNew(in FTC_Manager manager, out FTC_ImageCache cache);
 /* #ifdef MOZ_SVG */
     void glyphTransform(in FT_Glyph glyph, in FT_Matrix_p matrix,
                         in FT_Vector_p delta);
--- misc/mozilla/gfx/src/freetype/nsFreeType.cpp	2005-07-13 20:21:10.000000000 +0200
+++ misc/build/mozilla/gfx/src/freetype/nsFreeType.cpp	2008-08-14 16:22:21.000000000 +0200
@@ -111,7 +111,7 @@
   {"FT_Outline_Decompose",    NS_FT2_OFFSET(nsFT_Outline_Decompose),    PR_TRUE},
   {"FT_Set_Charmap",          NS_FT2_OFFSET(nsFT_Set_Charmap),          PR_TRUE},
   {"FTC_Image_Cache_Lookup",  NS_FT2_OFFSET(nsFTC_Image_Cache_Lookup),  PR_TRUE},
-  {"FTC_Manager_Lookup_Size", NS_FT2_OFFSET(nsFTC_Manager_Lookup_Size), PR_TRUE},
+  {"FTC_Manager_LookupFace",  NS_FT2_OFFSET(nsFTC_Manager_LookupFace),  PR_TRUE},
   {"FTC_Manager_Done",        NS_FT2_OFFSET(nsFTC_Manager_Done),        PR_TRUE},
   {"FTC_Manager_New",         NS_FT2_OFFSET(nsFTC_Manager_New),         PR_TRUE},
   {"FTC_Image_Cache_New",     NS_FT2_OFFSET(nsFTC_Image_Cache_New),     PR_TRUE},
@@ -288,7 +288,7 @@
 } 
  
 NS_IMETHODIMP
-nsFreeType2::ImageCacheLookup(FTC_Image_Cache cache, FTC_Image_Desc *desc,
+nsFreeType2::ImageCacheLookup(FTC_ImageCache cache, FTC_ImageType *desc,
                               FT_UInt glyphID, FT_Glyph *glyph)
 { 
   // call the FreeType2 function via the function pointer
@@ -297,11 +297,11 @@
 } 
  
 NS_IMETHODIMP
-nsFreeType2::ManagerLookupSize(FTC_Manager manager, FTC_Font font,
-                               FT_Face *face, FT_Size *size)
+nsFreeType2::ManagerLookupFace(FTC_Manager manager, FTC_FaceID font,
+                               FT_Face *face)
 { 
   // call the FreeType2 function via the function pointer
-  FT_Error error = nsFTC_Manager_Lookup_Size(manager, font, face, size);
+  FT_Error error = nsFTC_Manager_LookupFace(manager, font, face);
   return error ? NS_ERROR_FAILURE : NS_OK;
 } 
  
@@ -326,7 +326,7 @@
 } 
  
 NS_IMETHODIMP
-nsFreeType2::ImageCacheNew(FTC_Manager manager, FTC_Image_Cache *cache)
+nsFreeType2::ImageCacheNew(FTC_Manager manager, FTC_ImageCache *cache)
 { 
   // call the FreeType2 function via the function pointer
   FT_Error error = nsFTC_Image_Cache_New(manager, cache);
@@ -395,7 +395,7 @@
 } 
  
 NS_IMETHODIMP
-nsFreeType2::GetImageCache(FTC_Image_Cache *aCache)
+nsFreeType2::GetImageCache(FTC_ImageCache *aCache)
 {
   *aCache = mImageCache;
   return NS_OK;
--- misc/mozilla/gfx/src/freetype/nsFreeType.h	2005-05-01 19:36:19.000000000 +0200
+++ misc/build/mozilla/gfx/src/freetype/nsFreeType.h	2008-08-14 16:22:21.000000000 +0200
@@ -120,13 +120,13 @@
 typedef FT_Error (*FT_New_Face_t)(FT_Library, const char*, FT_Long, FT_Face*);
 typedef FT_Error (*FT_Set_Charmap_t)(FT_Face face, FT_CharMap  charmap);
 typedef FT_Error (*FTC_Image_Cache_Lookup_t)
-                      (FTC_Image_Cache, FTC_Image_Desc*, FT_UInt, FT_Glyph*);
-typedef FT_Error (*FTC_Manager_Lookup_Size_t)
-                      (FTC_Manager, FTC_Font, FT_Face*, FT_Size*);
+                       (FTC_ImageCache, FTC_ImageType*, FT_UInt, FT_Glyph*);
+typedef FT_Error (*FTC_Manager_LookupFace_t)
+                       (FTC_Manager, FTC_FaceID, FT_Face*);
 typedef FT_Error (*FTC_Manager_Done_t)(FTC_Manager);
 typedef FT_Error (*FTC_Manager_New_t)(FT_Library, FT_UInt, FT_UInt, FT_ULong,
                        FTC_Face_Requester, FT_Pointer, FTC_Manager*);
-typedef FT_Error (*FTC_Image_Cache_New_t)(FTC_Manager, FTC_Image_Cache*);
+typedef FT_Error (*FTC_Image_Cache_New_t)(FTC_Manager, FTC_ImageCache*);
 // #ifdef MOZ_SVG
 typedef FT_Error (*FT_Glyph_Transform_t)(FT_Glyph, FT_Matrix*, FT_Vector*);
 typedef FT_Error (*FT_Get_Kerning_t)
@@ -181,7 +181,7 @@
   FT_Outline_Decompose_t    nsFT_Outline_Decompose;
   FT_Set_Charmap_t          nsFT_Set_Charmap;
   FTC_Image_Cache_Lookup_t  nsFTC_Image_Cache_Lookup;
-  FTC_Manager_Lookup_Size_t nsFTC_Manager_Lookup_Size;
+  FTC_Manager_LookupFace_t  nsFTC_Manager_LookupFace;
   FTC_Manager_Done_t        nsFTC_Manager_Done;
   FTC_Manager_New_t         nsFTC_Manager_New;
   FTC_Image_Cache_New_t     nsFTC_Image_Cache_New;
@@ -229,7 +229,7 @@
   PRLibrary      *mSharedLib;
   FT_Library      mFreeTypeLibrary;
   FTC_Manager     mFTCacheManager;
-  FTC_Image_Cache mImageCache;
+  FTC_ImageCache  mImageCache;
 
   static nsHashtable   *sFontFamilies;
   static nsHashtable   *sRange1CharSetNames;
--- misc/mozilla/gfx/src/gtk/Makefile.in	2006-07-20 07:12:33.000000000 +0200
+++ misc/build/mozilla/gfx/src/gtk/Makefile.in	2008-08-14 16:22:21.000000000 +0200
@@ -211,6 +211,10 @@
 CXXFLAGS	+= $(MOZ_GTK_CFLAGS) $(MOZ_GTK2_CFLAGS)
 CFLAGS		+= $(MOZ_GTK_CFLAGS) $(MOZ_GTK2_CFLAGS)
 
+ifeq ($(OS_ARCH), Darwin)
+EXTRA_DSO_LDOPTS += $(XLDFLAGS) $(XLIBS)
+endif
+
 ifeq ($(OS_ARCH), SunOS)
 ifndef GNU_CC
 # When using Sun's WorkShop compiler, including
--- misc/mozilla/gfx/src/ps/nsFontMetricsPS.cpp	2006-12-22 14:51:16.000000000 +0100
+++ misc/build/mozilla/gfx/src/ps/nsFontMetricsPS.cpp	2008-08-14 16:22:21.000000000 +0200
@@ -1870,10 +1870,10 @@
   
   mPixelSize = NSToIntRound(app2dev * mFont->size);
 
-  mImageDesc.font.face_id    = (void*)mEntry;
-  mImageDesc.font.pix_width  = mPixelSize;
-  mImageDesc.font.pix_height = mPixelSize;
-  mImageDesc.image_type = 0;
+  mImageDesc->face_id = (FTC_FaceID)&mEntry;
+  mImageDesc->width  = mPixelSize;
+  mImageDesc->height = mPixelSize;
+  mImageDesc->flags = 0;
 
   nsresult rv;
   mFt2 = do_GetService(NS_FREETYPE2_CONTRACTID, &rv);
@@ -1907,7 +1907,7 @@
   if (!face)
     return 0;
 
-  FTC_Image_Cache iCache;
+  FTC_ImageCache iCache;
   nsresult rv = mFt2->GetImageCache(&iCache);
   if (NS_FAILED(rv)) {
     NS_ERROR("Failed to get Image Cache");
@@ -1945,8 +1945,8 @@
   
   FTC_Manager cManager;
   mFt2->GetFTCacheManager(&cManager);
-  nsresult rv = mFt2->ManagerLookupSize(cManager, &mImageDesc.font,
-                                        &face, nsnull);
+  nsresult rv = mFt2->ManagerLookupFace(cManager, mImageDesc->face_id,
+                                        &face);
   NS_ASSERTION(rv==0, "failed to get face/size");
   if (rv)
     return nsnull;
@@ -2392,16 +2392,16 @@
   mEntry->GetFamilyName(fontName);
   mEntry->GetStyleName(styleName);
   
-  mImageDesc.font.face_id    = (void*)mEntry;
+  mImageDesc->face_id = (FTC_FaceID)&mEntry;
   // TT glyph has no relation to size
-  mImageDesc.font.pix_width  = 16;
-  mImageDesc.font.pix_height = 16;
-  mImageDesc.image_type = 0;
+  mImageDesc->width  = 16;
+  mImageDesc->height = 16;
+  mImageDesc->flags = 0;
   FT_Face face = nsnull;
   FTC_Manager cManager;
   mFt2->GetFTCacheManager(&cManager);
-  nsresult rv = mFt2->ManagerLookupSize(cManager, &mImageDesc.font,
-                                        &face, nsnull);
+  nsresult rv = mFt2->ManagerLookupFace(cManager, mImageDesc->face_id,
+                                        &face);
   if (NS_FAILED(rv))
     return;
  
--- misc/mozilla/gfx/src/ps/nsFontMetricsPS.h	2005-06-28 20:29:10.000000000 +0200
+++ misc/build/mozilla/gfx/src/ps/nsFontMetricsPS.h	2008-08-20 15:42:50.000000000 +0200
@@ -424,7 +424,7 @@
   nsCOMPtr<nsITrueTypeFontCatalogEntry> mFaceID;
   nsCOMPtr<nsIFreeType2> mFt2;
   PRUint16        mPixelSize;
-  FTC_Image_Desc  mImageDesc;
+  FTC_ImageType   mImageDesc;
   nsCString       mFontNameBase;   // the base name of type 1 (sub) fonts
   nscoord         mHeight; 
 
@@ -493,7 +493,7 @@
 protected:
   nsCOMPtr<nsITrueTypeFontCatalogEntry> mEntry;
   nsCOMPtr<nsIFreeType2> mFt2;
-  FTC_Image_Desc  mImageDesc;
+  FTC_ImageType   mImageDesc;
 };
 #endif   // MOZ_ENABLE_FREETYPE2
 #endif   // MOZ_ENABLE_XFT
--- misc/mozilla/gfx/src/x11shared/nsFontFreeType.cpp	2004-04-17 23:52:34.000000000 +0200
+++ misc/build/mozilla/gfx/src/x11shared/nsFontFreeType.cpp	2008-08-14 16:22:21.000000000 +0200
@@ -177,7 +177,7 @@
   FTC_Manager mgr;
   nsresult rv;
   mFt2->GetFTCacheManager(&mgr);
-  rv = mFt2->ManagerLookupSize(mgr, &mImageDesc.font, &face, nsnull);
+  rv = mFt2->ManagerLookupFace(mgr, mImageDesc->face_id, &face);
   NS_ASSERTION(NS_SUCCEEDED(rv), "failed to get face/size");
   if (NS_FAILED(rv))
     return nsnull;
@@ -191,22 +191,15 @@
   PRBool embedded_bimap = PR_FALSE;
   mFaceID = aFaceID;
   mPixelSize = aPixelSize;
-  mImageDesc.font.face_id    = (void*)mFaceID;
-  mImageDesc.font.pix_width  = aPixelSize;
-  mImageDesc.font.pix_height = aPixelSize;
-  mImageDesc.image_type = 0;
+  mImageDesc->face_id = (FTC_FaceID)&mFaceID;
+  mImageDesc->width  = aPixelSize;
+  mImageDesc->height = aPixelSize;
+  mImageDesc->flags = 0;
 
   if (aPixelSize < nsFreeType2::gAntiAliasMinimum) {
-    mImageDesc.image_type |= ftc_image_mono;
     anti_alias = PR_FALSE;
   }
 
-  if (nsFreeType2::gFreeType2Autohinted)
-    mImageDesc.image_type |= ftc_image_flag_autohinted;
-
-  if (nsFreeType2::gFreeType2Unhinted)
-    mImageDesc.image_type |= ftc_image_flag_unhinted;
-
   PRUint32  num_embedded_bitmaps, i;
   PRInt32*  embedded_bitmapheights;
   mFaceID->GetEmbeddedBitmapHeights(&num_embedded_bitmaps,
@@ -218,7 +211,6 @@
         if (embedded_bitmapheights[i] == aPixelSize) {
           embedded_bimap = PR_TRUE;
           // unhinted must be set for embedded bitmaps to be used
-          mImageDesc.image_type |= ftc_image_flag_unhinted;
           break;
         }
       }
@@ -312,7 +304,7 @@
   if (!face)
     return NS_ERROR_FAILURE;
 
-  FTC_Image_Cache icache;
+  FTC_ImageCache icache;
   mFt2->GetImageCache(&icache);
   if (!icache)
     return NS_ERROR_FAILURE;
@@ -401,7 +393,7 @@
   if (!face)
     return 0;
 
-  FTC_Image_Cache icache;
+  FTC_ImageCache icache;
   mFt2->GetImageCache(&icache);
   if (!icache)
     return 0;
@@ -723,7 +715,7 @@
     if (y%4==0) (*blendPixelFunc)(sub_image, y, ascent-1, black, 255/2);
 #endif
 
-  FTC_Image_Cache icache;
+  FTC_ImageCache icache;
   mFt2->GetImageCache(&icache);
   if (!icache)
     return 0;
--- misc/mozilla/gfx/src/x11shared/nsFontFreeType.h	2004-04-17 23:52:34.000000000 +0200
+++ misc/build/mozilla/gfx/src/x11shared/nsFontFreeType.h	2008-08-14 16:22:21.000000000 +0200
@@ -110,7 +110,7 @@
   XImage *GetXImage(PRUint32 width, PRUint32 height);
   nsITrueTypeFontCatalogEntry *mFaceID;
   PRUint16        mPixelSize;
-  FTC_Image_Desc  mImageDesc;
+  FTC_ImageType   mImageDesc;
   nsCOMPtr<nsIFreeType2> mFt2;
 };
 
--- misc/mozilla/jpeg/jmorecfg.h	2004-12-12 01:57:39.000000000 +0100
+++ misc/build/mozilla/jpeg/jmorecfg.h	2008-08-18 09:06:05.000000000 +0200
@@ -108,7 +108,7 @@
 /* Defines for MMX/SSE2 support. */
 
 #if defined(XP_WIN32) && defined(_M_IX86) && !defined(__GNUC__)
-#define HAVE_MMX_INTEL_MNEMONICS 
+//#define HAVE_MMX_INTEL_MNEMONICS 
 
 /* SSE2 code appears broken for some cpus (bug 247437) */
 /* #define HAVE_SSE2_INTEL_MNEMONICS */
--- misc/mozilla/layout/svg/renderer/src/libart/nsSVGLibartGlyphMetricsFT.cpp	2006-03-16 18:09:14.000000000 +0100
+++ misc/build/mozilla/layout/svg/renderer/src/libart/nsSVGLibartGlyphMetricsFT.cpp	2008-08-14 16:22:21.000000000 +0200
@@ -423,19 +423,19 @@
     return;
   }
 
-  FTC_Image_Desc imageDesc;
-  imageDesc.font.face_id=(void*)font_data.font_entry.get(); // XXX do we need to addref?
+  FTC_ImageType imageDesc;
+  imageDesc->face_id=(FTC_FaceID)font_data.font_entry.get(); // XXX do we need to addref?
   float twipstopixel = GetTwipsToPixels();
   float scale = GetPixelScale();
-  imageDesc.font.pix_width = (int)((float)(font_data.font.size)*twipstopixel/scale);
-  imageDesc.font.pix_height = (int)((float)(font_data.font.size)*twipstopixel/scale);
-  imageDesc.image_type |= ftc_image_grays;
+  imageDesc->width = (int)((float)(font_data.font.size)*twipstopixel/scale);
+  imageDesc->height = (int)((float)(font_data.font.size)*twipstopixel/scale);
+  imageDesc->flags |= /* ftc_image_grays */0;
 
   // get the face
   nsresult rv;
   FTC_Manager mgr;
   nsSVGLibartFreetype::ft2->GetFTCacheManager(&mgr);
-  rv = nsSVGLibartFreetype::ft2->ManagerLookupSize(mgr, &imageDesc.font, &mFace, nsnull);
+  rv = nsSVGLibartFreetype::ft2->ManagerLookupFace(mgr, imageDesc->face_id, &mFace);
   NS_ASSERTION(mFace, "failed to get face/size");
 }
 
--- misc/mozilla/mailnews/addrbook/src/Makefile.in	2007-05-03 03:39:37.000000000 +0200
+++ misc/build/mozilla/mailnews/addrbook/src/Makefile.in	2008-10-16 12:59:35.000000000 +0200
@@ -106,6 +106,7 @@
                 nsVCard.cpp \
                 nsVCardObj.cpp \
                 nsMsgVCardService.cpp \
+		nsAbMD5sum.cpp	\
                 nsAbLDIFService.cpp \
 		$(NULL)
 
@@ -114,7 +115,9 @@
 		nsDirPrefs.h \
 		nsAbCardProperty.h \
 		nsAbMDBCardProperty.h \
-                nsVCardObj.h \
+		nsVCardObj.h \
+		nsAbAddressCollecter.h \
+		nsAbDirectoryQuery.h \
 		$(NULL)
 
 ifeq ($(OS_ARCH),WINNT)
--- misc/mozilla/mailnews/addrbook/src/nsAbBoolExprToLDAPFilter.h	2005-05-11 06:16:53.000000000 +0200
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbBoolExprToLDAPFilter.h	2008-08-14 16:22:21.000000000 +0200
@@ -43,6 +43,7 @@
 #include "nsIAbBooleanExpression.h"
 #include "nsCOMPtr.h"
 #include "nsString.h"
+#include "nsAbUtils.h"
 
 class nsIAbLDAPAttributeMap;
 
@@ -74,6 +75,16 @@
         nsIAbBooleanConditionString* condition,
         nsCString& filter,
         int flags);
+    static void GenerateMultipleFilter(
+       nsAbBooleanConditionType conditionType,
+       nsCString& filter,
+       NS_ConvertUCS2toUTF8 &vUTF8,
+       CharPtrArrayGuard *pAttrs);
+    static void GenerateSingleFilter(
+       nsAbBooleanConditionType conditionType,
+       nsCString& filter,
+       NS_ConvertUCS2toUTF8 &vUTF8,
+       const char *ldapProperty);
 };
 
 #endif
--- misc/mozilla/mailnews/addrbook/src/nsAbLDAPDirectory.cpp	2007-02-18 23:18:13.000000000 +0100
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPDirectory.cpp	2008-08-20 12:16:50.000000000 +0200
@@ -126,11 +126,13 @@
 
     // use mURINoQuery to get a prefName
     nsCAutoString prefName;
-    prefName = nsDependentCString(mURINoQuery.get() + kLDAPDirectoryRootLen) + NS_LITERAL_CSTRING(".uri");
+    prefName = nsDependentCString(mURINoQuery.get() + kLDAPDirectoryRootLen);
 
     // turn moz-abldapdirectory://ldap_2.servers.nscpphonebook into -> "ldap_2.servers.nscpphonebook.uri"
     nsXPIDLCString URI;
-    rv = prefs->GetCharPref(prefName.get(), getter_Copies(URI));
+    nsCAutoString uriPrefName;
+    uriPrefName = prefName + NS_LITERAL_CSTRING(".uri");
+    rv = prefs->GetCharPref(uriPrefName.get(), getter_Copies(URI));
     if (NS_FAILED(rv))
     {
         /*
@@ -154,6 +156,27 @@
         nsCAutoString tempLDAPURL(mURINoQuery);
         tempLDAPURL.ReplaceSubstring("moz-abldapdirectory:", "ldap:");
         rv = mURL->SetSpec(tempLDAPURL);
+		NS_ENSURE_SUCCESS(rv,rv);
+    
+        nsCAutoString aHost;
+        mURL->GetHost(aHost);
+        aHost.ReplaceChar('.','_');
+        prefName = nsDependentCString("ldap_2.servers.") + aHost;
+        PRBool useSSL=0;
+        rv = prefs->GetBoolPref(
+                PromiseFlatCString(prefName
+                + NS_LITERAL_CSTRING(".UseSSL")).get(),
+                &useSSL
+            );
+        
+        // If use SSL,ldap url will look like this ldaps://host:port/.....
+        if (!NS_FAILED(rv) && useSSL)
+        {
+            tempLDAPURL.ReplaceSubstring("ldap:", "ldaps:"); 
+            rv = mURL->SetSpec(tempLDAPURL);
+        }
+        //NS_FAILED(rv) means ldap_2.servers.nscpphonebook.UseSSL not exist
+        rv = 0;
     }
     else
     {
@@ -164,24 +187,29 @@
     // get the login information, if there is any 
     //
     rv = prefs->GetCharPref(
-        PromiseFlatCString(
-            Substring(mURINoQuery, kLDAPDirectoryRootLen,
-                      mURINoQuery.Length() - kLDAPDirectoryRootLen)
+        PromiseFlatCString(prefName
             + NS_LITERAL_CSTRING(".auth.dn")).get(),
         getter_Copies(mLogin));
     if (NS_FAILED(rv)) {
         mLogin.Truncate();  // zero out mLogin
     }
 
+    // get the password information, if there is any 
+    //
+    rv = prefs->GetCharPref(
+        PromiseFlatCString(prefName
+            + NS_LITERAL_CSTRING(".auth.pwd")).get(),
+        getter_Copies(mPassword));
+    if (NS_FAILED(rv)) {
+        mPassword.Truncate();  // zero out mLogin
+    }
     // get the protocol version, if there is any.  using a string pref
     // here instead of an int, as protocol versions sometimes have names like
     // "4bis".
     //
     nsXPIDLCString protocolVersion;
     rv = prefs->GetCharPref(
-        PromiseFlatCString(
-            Substring(mURINoQuery, kLDAPDirectoryRootLen,
-                      mURINoQuery.Length() - kLDAPDirectoryRootLen)
+        PromiseFlatCString(prefName
             + NS_LITERAL_CSTRING(".protocolVersion")).get(),
         getter_Copies(protocolVersion));
 
--- misc/mozilla/mailnews/addrbook/src/nsAbLDAPDirectoryQuery.cpp	2006-12-22 14:51:38.000000000 +0100
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPDirectoryQuery.cpp	2008-08-20 15:01:16.000000000 +0200
@@ -74,7 +74,7 @@
         PRInt32 resultLimit = -1,
         PRInt32 timeOut = 0);
     virtual ~nsAbQueryLDAPMessageListener ();
-
+    void SetPassword(const nsAString& aPassword){m_sPassword = aPassword;};
 protected:
     nsresult OnLDAPMessageBind (nsILDAPMessage *aMessage);
     nsresult OnLDAPMessageSearchEntry (nsILDAPMessage *aMessage,
@@ -108,6 +108,8 @@
     PRBool mCanceled;
     PRBool mWaitingForPrevQueryToFinish;
 
+    nsAutoString m_sPassword;
+
     nsCOMPtr<nsILDAPOperation> mSearchOperation;
 
     PRLock* mLock;
@@ -272,7 +274,7 @@
 
     // If mLogin is set, we're expected to use it to get a password.
     //
-    if (!mDirectoryQuery->mLogin.IsEmpty()) {
+    if (!mDirectoryQuery->mLogin.IsEmpty() && !m_sPassword.Length()) {
 // XXX hack until nsUTF8AutoString exists
 #define nsUTF8AutoString nsCAutoString
         nsUTF8AutoString spec;
@@ -415,10 +417,13 @@
     rv = ldapOperation->Init(mConnection, proxyListener, nsnull);
     NS_ENSURE_SUCCESS(rv, rv);
 
-    // Bind
-    rv = ldapOperation->SimpleBind(NS_ConvertUCS2toUTF8(passwd));
+	
+	// Bind
+    if (m_sPassword.Length())
+		rv = ldapOperation->SimpleBind(NS_ConvertUCS2toUTF8(m_sPassword));
+	else
+	    rv = ldapOperation->SimpleBind(NS_ConvertUCS2toUTF8(passwd));
     NS_ENSURE_SUCCESS(rv, rv);
-
     return rv;
 }
 
@@ -707,7 +712,7 @@
     rv = getLdapReturnAttributes (arguments, returnAttributes);
     NS_ENSURE_SUCCESS(rv, rv);
 
-
+    
     // Get the filter
     nsCOMPtr<nsISupports> supportsExpression;
     rv = arguments->GetExpression (getter_AddRefs (supportsExpression));
@@ -828,6 +833,10 @@
       if (msgListener)
       {
         msgListener->mUrl = url;
+        msgListener->mQueryListener = listener;
+        msgListener->mResultLimit = resultLimit;
+        msgListener->mTimeOut = timeOut;
+        msgListener->mQueryArguments = arguments;
         return msgListener->DoSearch();
       }
     }
@@ -845,6 +854,11 @@
                 timeOut);
     if (_messageListener == NULL)
             return NS_ERROR_OUT_OF_MEMORY;
+
+    nsAutoString wPassword;
+    wPassword.AssignWithConversion(mPassword.get());
+    _messageListener->SetPassword(wPassword);
+
     mListener = _messageListener;
     *_retval = 1;
 
--- misc/mozilla/mailnews/addrbook/src/nsAbLDAPDirectoryQuery.h	2004-07-24 21:50:29.000000000 +0200
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPDirectoryQuery.h	2008-08-14 16:22:21.000000000 +0200
@@ -72,6 +72,7 @@
     friend class nsAbQueryLDAPMessageListener;
     nsresult Initiate ();
     nsXPIDLCString mLogin; // authenticate to the LDAP server as...
+    nsXPIDLCString mPassword; // password to the LDAP server as...
     nsCOMPtr<nsILDAPURL> mDirectoryUrl; // the URL for the server
     PRUint32 mProtocolVersion; // version of LDAP (see nsILDAPConnection.idl)
 
--- misc/mozilla/mailnews/addrbook/src/nsAbMD5sum.cpp	2008-08-14 16:30:14.000000000 +0200
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbMD5sum.cpp	2008-08-14 16:22:21.000000000 +0200
@@ -1 +1,633 @@
-dummy
+/*
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ * 
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ * 
+ * The Original Code is the Netscape security libraries.
+ * 
+ * The Initial Developer of the Original Code is Netscape
+ * Communications Corporation.	Portions created by Netscape are 
+ * Copyright (C) 1994-2000 Netscape Communications Corporation.  All
+ * Rights Reserved.
+ * 
+ * Contributor(s):
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 or later (the
+ * "GPL"), in which case the provisions of the GPL are applicable 
+ * instead of those above.	If you wish to allow use of your 
+ * version of this file only under the terms of the GPL and not to
+ * allow others to use your version of this file under the MPL,
+ * indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by
+ * the GPL.  If you do not delete the provisions above, a recipient
+ * may use your version of this file under either the MPL or the
+ * GPL.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "prerr.h"
+
+#include "prtypes.h"
+#include "prlong.h"
+#include "plstr.h"
+#include "nsMemory.h"
+
+#define MD5_HASH_LEN 16
+#define MD5_BUFFER_SIZE 64
+#define MD5_END_BUFFER (MD5_BUFFER_SIZE - 8)
+
+#define CV0_1 0x67452301
+#define CV0_2 0xefcdab89
+#define CV0_3 0x98badcfe
+#define CV0_4 0x10325476
+
+#define T1_0  0xd76aa478
+#define T1_1  0xe8c7b756
+#define T1_2  0x242070db
+#define T1_3  0xc1bdceee
+#define T1_4  0xf57c0faf
+#define T1_5  0x4787c62a
+#define T1_6  0xa8304613
+#define T1_7  0xfd469501
+#define T1_8  0x698098d8
+#define T1_9  0x8b44f7af
+#define T1_10 0xffff5bb1
+#define T1_11 0x895cd7be
+#define T1_12 0x6b901122
+#define T1_13 0xfd987193
+#define T1_14 0xa679438e
+#define T1_15 0x49b40821
+
+#define T2_0  0xf61e2562
+#define T2_1  0xc040b340
+#define T2_2  0x265e5a51
+#define T2_3  0xe9b6c7aa
+#define T2_4  0xd62f105d
+#define T2_5  0x02441453
+#define T2_6  0xd8a1e681
+#define T2_7  0xe7d3fbc8
+#define T2_8  0x21e1cde6
+#define T2_9  0xc33707d6
+#define T2_10 0xf4d50d87
+#define T2_11 0x455a14ed
+#define T2_12 0xa9e3e905
+#define T2_13 0xfcefa3f8
+#define T2_14 0x676f02d9
+#define T2_15 0x8d2a4c8a
+
+#define T3_0  0xfffa3942
+#define T3_1  0x8771f681
+#define T3_2  0x6d9d6122
+#define T3_3  0xfde5380c
+#define T3_4  0xa4beea44
+#define T3_5  0x4bdecfa9
+#define T3_6  0xf6bb4b60
+#define T3_7  0xbebfbc70
+#define T3_8  0x289b7ec6
+#define T3_9  0xeaa127fa
+#define T3_10 0xd4ef3085
+#define T3_11 0x04881d05
+#define T3_12 0xd9d4d039
+#define T3_13 0xe6db99e5
+#define T3_14 0x1fa27cf8
+#define T3_15 0xc4ac5665
+
+#define T4_0  0xf4292244
+#define T4_1  0x432aff97
+#define T4_2  0xab9423a7
+#define T4_3  0xfc93a039
+#define T4_4  0x655b59c3
+#define T4_5  0x8f0ccc92
+#define T4_6  0xffeff47d
+#define T4_7  0x85845dd1
+#define T4_8  0x6fa87e4f
+#define T4_9  0xfe2ce6e0
+#define T4_10 0xa3014314
+#define T4_11 0x4e0811a1
+#define T4_12 0xf7537e82
+#define T4_13 0xbd3af235
+#define T4_14 0x2ad7d2bb
+#define T4_15 0xeb86d391
+
+#define R1B0  0
+#define R1B1  1
+#define R1B2  2
+#define R1B3  3
+#define R1B4  4
+#define R1B5  5
+#define R1B6  6
+#define R1B7  7
+#define R1B8  8
+#define R1B9  9
+#define R1B10 10
+#define R1B11 11
+#define R1B12 12
+#define R1B13 13
+#define R1B14 14
+#define R1B15 15
+
+#define R2B0  1
+#define R2B1  6
+#define R2B2  11
+#define R2B3  0
+#define R2B4  5
+#define R2B5  10
+#define R2B6  15
+#define R2B7  4
+#define R2B8  9
+#define R2B9  14
+#define R2B10 3 
+#define R2B11 8 
+#define R2B12 13
+#define R2B13 2 
+#define R2B14 7 
+#define R2B15 12
+
+#define R3B0  5
+#define R3B1  8
+#define R3B2  11
+#define R3B3  14
+#define R3B4  1
+#define R3B5  4
+#define R3B6  7
+#define R3B7  10
+#define R3B8  13
+#define R3B9  0
+#define R3B10 3 
+#define R3B11 6 
+#define R3B12 9 
+#define R3B13 12
+#define R3B14 15
+#define R3B15 2 
+
+#define R4B0  0
+#define R4B1  7
+#define R4B2  14
+#define R4B3  5
+#define R4B4  12
+#define R4B5  3
+#define R4B6  10
+#define R4B7  1
+#define R4B8  8
+#define R4B9  15
+#define R4B10 6 
+#define R4B11 13
+#define R4B12 4 
+#define R4B13 11
+#define R4B14 2 
+#define R4B15 9 
+
+#define S1_0 7
+#define S1_1 12
+#define S1_2 17
+#define S1_3 22
+
+#define S2_0 5
+#define S2_1 9
+#define S2_2 14
+#define S2_3 20
+
+#define S3_0 4
+#define S3_1 11
+#define S3_2 16
+#define S3_3 23
+
+#define S4_0 6
+#define S4_1 10
+#define S4_2 15
+#define S4_3 21
+
+struct MD5ContextStr {
+	PRUint32      lsbInput;
+	PRUint32      msbInput;
+	PRUint32      cv[4];
+	union {
+		PRUint8 b[64];
+		PRUint32 w[16];
+	} u;
+};
+typedef struct MD5ContextStr        MD5Context;
+
+#define inBuf u.b
+
+int MD5_Hash(unsigned char *dest, const char *src);
+int MD5_HashBuf(unsigned char *dest, const unsigned char *src, uint32 src_length);
+MD5Context * MD5_NewContext(void);
+void MD5_DestroyContext(MD5Context *cx, PRBool freeit);
+void MD5_Begin(MD5Context *cx);
+static void md5_compress(MD5Context *cx);
+void MD5_Update(MD5Context *cx, const unsigned char *input, unsigned int inputLen);
+void MD5_End(MD5Context *cx, unsigned char *digest,
+        unsigned int *digestLen, unsigned int maxDigestLen);
+unsigned int MD5_FlattenSize(MD5Context *cx);
+int MD5_Flatten(MD5Context *cx, unsigned char *space);
+MD5Context * MD5_Resurrect(unsigned char *space, void *arg);
+void MD5_TraceState(MD5Context *cx);
+
+int 
+MD5_Hash(unsigned char *dest, const char *src)
+{
+	return MD5_HashBuf(dest, (unsigned char *)src, PL_strlen(src));
+}
+
+int 
+MD5_HashBuf(unsigned char *dest, const unsigned char *src, uint32 src_length)
+{
+	unsigned int len;
+	MD5Context *cx = MD5_NewContext();
+	if (cx == NULL) {
+//		PORT_SetError(PR_OUT_OF_MEMORY_ERROR);
+		return -1;
+	}
+	MD5_Begin(cx);
+	MD5_Update(cx, src, src_length);
+	MD5_End(cx, dest, &len, MD5_HASH_LEN);
+	MD5_DestroyContext(cx, PR_TRUE);
+	return 0;
+}
+
+MD5Context *
+MD5_NewContext(void)
+{
+	MD5Context *cx = (MD5Context *)malloc(sizeof(MD5Context));
+	if (cx == NULL) {
+//		PORT_SetError(PR_OUT_OF_MEMORY_ERROR);
+		return NULL;
+	}
+	return cx;
+}
+
+void 
+MD5_DestroyContext(MD5Context *cx, PRBool freeit)
+{
+	if (freeit) {
+		free(cx);
+	}
+}
+
+void 
+MD5_Begin(MD5Context *cx)
+{
+	cx->lsbInput = 0;
+	cx->msbInput = 0;
+	memset(cx->inBuf, 0, sizeof(cx->inBuf));
+	cx->cv[0] = CV0_1;
+	cx->cv[1] = CV0_2;
+	cx->cv[2] = CV0_3;
+	cx->cv[3] = CV0_4;
+}
+
+#define cls(i32, s) (tmp = i32, tmp << s | tmp >> (32 - s))
+
+#define MASK 0x00ff00ff
+#ifdef IS_LITTLE_ENDIAN
+#define lendian(i32) \
+	(i32)
+#else
+#define lendian(i32) \
+	(tmp = i32 >> 16 | i32 << 16, (tmp & MASK) << 8 | tmp >> 8 & MASK)
+#endif
+
+#if defined(SOLARIS) || defined(HPUX)
+#define addto64(sumhigh, sumlow, addend) \
+	sumlow += addend; sumhigh += (sumlow < addend);
+#else
+#define addto64(sumhigh, sumlow, addend) \
+	sumlow += addend; if (sumlow < addend) ++sumhigh;
+#endif
+
+#define F(X, Y, Z) \
+	((X & Y) | ((~X) & Z))
+
+#define G(X, Y, Z) \
+	((X & Z) | (Y & (~Z)))
+
+#define H(X, Y, Z) \
+	(X ^ Y ^ Z)
+
+#define I(X, Y, Z) \
+	(Y ^ (X | (~Z)))
+
+#define FF(a, b, c, d, bufint, s, ti) \
+	a = b + cls(a + F(b, c, d) + bufint + ti, s)
+
+#define GG(a, b, c, d, bufint, s, ti) \
+	a = b + cls(a + G(b, c, d) + bufint + ti, s)
+
+#define HH(a, b, c, d, bufint, s, ti) \
+	a = b + cls(a + H(b, c, d) + bufint + ti, s)
+
+#define II(a, b, c, d, bufint, s, ti) \
+	a = b + cls(a + I(b, c, d) + bufint + ti, s)
+
+static void
+md5_compress(MD5Context *cx)
+{
+	PRUint32 a, b, c, d;
+	PRUint32 tmp;
+	a = cx->cv[0];
+	b = cx->cv[1];
+	c = cx->cv[2];
+	d = cx->cv[3];
+#ifndef IS_LITTLE_ENDIAN
+	cx->u.w[0] = lendian(cx->u.w[0]);
+	cx->u.w[1] = lendian(cx->u.w[1]);
+	cx->u.w[2] = lendian(cx->u.w[2]);
+	cx->u.w[3] = lendian(cx->u.w[3]);
+	cx->u.w[4] = lendian(cx->u.w[4]);
+	cx->u.w[5] = lendian(cx->u.w[5]);
+	cx->u.w[6] = lendian(cx->u.w[6]);
+	cx->u.w[7] = lendian(cx->u.w[7]);
+	cx->u.w[8] = lendian(cx->u.w[8]);
+	cx->u.w[9] = lendian(cx->u.w[9]);
+	cx->u.w[10] = lendian(cx->u.w[10]);
+	cx->u.w[11] = lendian(cx->u.w[11]);
+	cx->u.w[12] = lendian(cx->u.w[12]);
+	cx->u.w[13] = lendian(cx->u.w[13]);
+	cx->u.w[14] = lendian(cx->u.w[14]);
+	cx->u.w[15] = lendian(cx->u.w[15]);
+#endif
+	FF(a, b, c, d, cx->u.w[R1B0 ], S1_0, T1_0);
+	FF(d, a, b, c, cx->u.w[R1B1 ], S1_1, T1_1);
+	FF(c, d, a, b, cx->u.w[R1B2 ], S1_2, T1_2);
+	FF(b, c, d, a, cx->u.w[R1B3 ], S1_3, T1_3);
+	FF(a, b, c, d, cx->u.w[R1B4 ], S1_0, T1_4);
+	FF(d, a, b, c, cx->u.w[R1B5 ], S1_1, T1_5);
+	FF(c, d, a, b, cx->u.w[R1B6 ], S1_2, T1_6);
+	FF(b, c, d, a, cx->u.w[R1B7 ], S1_3, T1_7);
+	FF(a, b, c, d, cx->u.w[R1B8 ], S1_0, T1_8);
+	FF(d, a, b, c, cx->u.w[R1B9 ], S1_1, T1_9);
+	FF(c, d, a, b, cx->u.w[R1B10], S1_2, T1_10);
+	FF(b, c, d, a, cx->u.w[R1B11], S1_3, T1_11);
+	FF(a, b, c, d, cx->u.w[R1B12], S1_0, T1_12);
+	FF(d, a, b, c, cx->u.w[R1B13], S1_1, T1_13);
+	FF(c, d, a, b, cx->u.w[R1B14], S1_2, T1_14);
+	FF(b, c, d, a, cx->u.w[R1B15], S1_3, T1_15);
+	GG(a, b, c, d, cx->u.w[R2B0 ], S2_0, T2_0);
+	GG(d, a, b, c, cx->u.w[R2B1 ], S2_1, T2_1);
+	GG(c, d, a, b, cx->u.w[R2B2 ], S2_2, T2_2);
+	GG(b, c, d, a, cx->u.w[R2B3 ], S2_3, T2_3);
+	GG(a, b, c, d, cx->u.w[R2B4 ], S2_0, T2_4);
+	GG(d, a, b, c, cx->u.w[R2B5 ], S2_1, T2_5);
+	GG(c, d, a, b, cx->u.w[R2B6 ], S2_2, T2_6);
+	GG(b, c, d, a, cx->u.w[R2B7 ], S2_3, T2_7);
+	GG(a, b, c, d, cx->u.w[R2B8 ], S2_0, T2_8);
+	GG(d, a, b, c, cx->u.w[R2B9 ], S2_1, T2_9);
+	GG(c, d, a, b, cx->u.w[R2B10], S2_2, T2_10);
+	GG(b, c, d, a, cx->u.w[R2B11], S2_3, T2_11);
+	GG(a, b, c, d, cx->u.w[R2B12], S2_0, T2_12);
+	GG(d, a, b, c, cx->u.w[R2B13], S2_1, T2_13);
+	GG(c, d, a, b, cx->u.w[R2B14], S2_2, T2_14);
+	GG(b, c, d, a, cx->u.w[R2B15], S2_3, T2_15);
+	HH(a, b, c, d, cx->u.w[R3B0 ], S3_0, T3_0);
+	HH(d, a, b, c, cx->u.w[R3B1 ], S3_1, T3_1);
+	HH(c, d, a, b, cx->u.w[R3B2 ], S3_2, T3_2);
+	HH(b, c, d, a, cx->u.w[R3B3 ], S3_3, T3_3);
+	HH(a, b, c, d, cx->u.w[R3B4 ], S3_0, T3_4);
+	HH(d, a, b, c, cx->u.w[R3B5 ], S3_1, T3_5);
+	HH(c, d, a, b, cx->u.w[R3B6 ], S3_2, T3_6);
+	HH(b, c, d, a, cx->u.w[R3B7 ], S3_3, T3_7);
+	HH(a, b, c, d, cx->u.w[R3B8 ], S3_0, T3_8);
+	HH(d, a, b, c, cx->u.w[R3B9 ], S3_1, T3_9);
+	HH(c, d, a, b, cx->u.w[R3B10], S3_2, T3_10);
+	HH(b, c, d, a, cx->u.w[R3B11], S3_3, T3_11);
+	HH(a, b, c, d, cx->u.w[R3B12], S3_0, T3_12);
+	HH(d, a, b, c, cx->u.w[R3B13], S3_1, T3_13);
+	HH(c, d, a, b, cx->u.w[R3B14], S3_2, T3_14);
+	HH(b, c, d, a, cx->u.w[R3B15], S3_3, T3_15);
+	II(a, b, c, d, cx->u.w[R4B0 ], S4_0, T4_0);
+	II(d, a, b, c, cx->u.w[R4B1 ], S4_1, T4_1);
+	II(c, d, a, b, cx->u.w[R4B2 ], S4_2, T4_2);
+	II(b, c, d, a, cx->u.w[R4B3 ], S4_3, T4_3);
+	II(a, b, c, d, cx->u.w[R4B4 ], S4_0, T4_4);
+	II(d, a, b, c, cx->u.w[R4B5 ], S4_1, T4_5);
+	II(c, d, a, b, cx->u.w[R4B6 ], S4_2, T4_6);
+	II(b, c, d, a, cx->u.w[R4B7 ], S4_3, T4_7);
+	II(a, b, c, d, cx->u.w[R4B8 ], S4_0, T4_8);
+	II(d, a, b, c, cx->u.w[R4B9 ], S4_1, T4_9);
+	II(c, d, a, b, cx->u.w[R4B10], S4_2, T4_10);
+	II(b, c, d, a, cx->u.w[R4B11], S4_3, T4_11);
+	II(a, b, c, d, cx->u.w[R4B12], S4_0, T4_12);
+	II(d, a, b, c, cx->u.w[R4B13], S4_1, T4_13);
+	II(c, d, a, b, cx->u.w[R4B14], S4_2, T4_14);
+	II(b, c, d, a, cx->u.w[R4B15], S4_3, T4_15);
+	cx->cv[0] += a;
+	cx->cv[1] += b;
+	cx->cv[2] += c;
+	cx->cv[3] += d;
+}
+
+void 
+MD5_Update(MD5Context *cx, const unsigned char *input, unsigned int inputLen)
+{
+	PRUint32 bytesToConsume;
+	PRUint32 inBufIndex = cx->lsbInput & 63;
+
+	/* Add the number of input bytes to the 64-bit input counter. */
+	addto64(cx->msbInput, cx->lsbInput, inputLen);
+	if (inBufIndex) {
+		/* There is already data in the buffer.  Fill with input. */
+		bytesToConsume = PR_MIN(inputLen, MD5_BUFFER_SIZE - inBufIndex);
+		memcpy(&cx->inBuf[inBufIndex], input, bytesToConsume);
+		if (inBufIndex + bytesToConsume >= MD5_BUFFER_SIZE)
+			/* The buffer is filled.  Run the compression function. */
+			md5_compress(cx);
+		/* Remaining input. */
+		inputLen -= bytesToConsume;
+		input += bytesToConsume;
+	}
+
+	/* Iterate over 64-byte chunks of the message. */
+	while (inputLen >= MD5_BUFFER_SIZE) {
+		memcpy(cx->inBuf, input, MD5_BUFFER_SIZE);
+		md5_compress(cx);
+		inputLen -= MD5_BUFFER_SIZE;
+		input += MD5_BUFFER_SIZE;
+	}
+
+	/* Tail of message (message bytes mod 64). */
+	if (inputLen)
+		memcpy(cx->inBuf, input, inputLen);
+}
+
+static const unsigned char padbytes[] = {
+	0x80, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00
+};
+
+void 
+MD5_End(MD5Context *cx, unsigned char *digest,
+        unsigned int *digestLen, unsigned int maxDigestLen)
+{
+#ifndef IS_LITTLE_ENDIAN
+	PRUint32 tmp;
+#endif
+	PRUint32 lowInput, highInput;
+	PRUint32 inBufIndex = cx->lsbInput & 63;
+
+	if (maxDigestLen < MD5_HASH_LEN) {
+//		PORT_SetError(SEC_ERROR_INVALID_ARGS);
+		return;
+	}
+
+	/* Copy out the length of bits input before padding. */
+	lowInput = cx->lsbInput; 
+	highInput = (cx->msbInput << 3) | (lowInput >> 29);
+	lowInput <<= 3;
+
+	if (inBufIndex < MD5_END_BUFFER) {
+		MD5_Update(cx, padbytes, MD5_END_BUFFER - inBufIndex);
+	} else {
+		MD5_Update(cx, padbytes, 
+		           MD5_END_BUFFER + MD5_BUFFER_SIZE - inBufIndex);
+	}
+
+	/* Store the number of bytes input (before padding) in final 64 bits. */
+	cx->u.w[14] = lendian(lowInput);
+	cx->u.w[15] = lendian(highInput);
+
+	/* Final call to compress. */
+	md5_compress(cx);
+
+	/* Copy the resulting values out of the chain variables into return buf. */
+	*digestLen = MD5_HASH_LEN;
+#ifndef IS_LITTLE_ENDIAN
+	cx->cv[0] = lendian(cx->cv[0]);
+	cx->cv[1] = lendian(cx->cv[1]);
+	cx->cv[2] = lendian(cx->cv[2]);
+	cx->cv[3] = lendian(cx->cv[3]);
+#endif
+	memcpy(digest, cx->cv, MD5_HASH_LEN);
+}
+
+unsigned int 
+MD5_FlattenSize(MD5Context *cx)
+{
+	return sizeof(*cx);
+}
+
+int 
+MD5_Flatten(MD5Context *cx, unsigned char *space)
+{
+	memcpy(space, cx, sizeof(*cx));
+	return 0;
+}
+
+MD5Context * 
+MD5_Resurrect(unsigned char *space, void *arg)
+{
+	MD5Context *cx = MD5_NewContext();
+	if (cx)
+		memcpy(cx, space, sizeof(*cx));
+	return cx;
+}
+
+void 
+MD5_TraceState(MD5Context *cx)
+{
+//	PORT_SetError(PR_NOT_IMPLEMENTED_ERROR);
+}
+
+int
+md5_stream (FILE *stream, unsigned char *dest)
+{
+  /* Important: BLOCKSIZE must be a multiple of 64.  */
+#define BLOCKSIZE 4096
+	unsigned int len;
+	MD5Context *cx = MD5_NewContext();
+	if (cx == NULL) {
+//		PORT_SetError(PR_OUT_OF_MEMORY_ERROR);
+		return -1;
+	}
+
+  unsigned char buffer[BLOCKSIZE + 72];
+  size_t sum;
+
+  /* Initialize the computation context.  */
+  MD5_Begin(cx);
+
+  /* Iterate over full file contents.  */
+  while (1)
+    {
+      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the
+	 computation function processes the whole buffer so that with the
+	 next round of the loop another block can be read.  */
+      size_t n;
+      sum = 0;
+
+      /* Read block.  Take care for partial reads.  */
+      do
+	{
+	  n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);
+
+	  sum += n;
+	}
+      while (sum < BLOCKSIZE && n != 0);
+      if (n == 0 && ferror (stream))
+        return 1;
+
+      /* If end of file is reached, end the loop.  */
+      if (n == 0)
+	break;
+
+      /* Process buffer with BLOCKSIZE bytes.  Note that
+			BLOCKSIZE % 64 == 0
+       */
+	MD5_Update(cx, buffer, BLOCKSIZE);
+    }
+
+  /* Add the last bytes if necessary.  */
+  if (sum > 0)
+	MD5_Update(cx, buffer, sum);
+
+	MD5_End(cx, dest, &len, MD5_HASH_LEN);
+	MD5_DestroyContext(cx, PR_TRUE);
+	return len;
+
+}
+
+int getMD5sum(const char * fileName,char * sum)
+{
+	unsigned char bin_sum[16];
+	int len=0;
+	if (fileName)
+	{
+		FILE *fp=fopen(fileName,"rb");
+		if (fp)
+		{
+			len=md5_stream(fp,bin_sum);
+			memset(sum,0,33);
+			for (int i = 0; i < len; ++i)
+				sprintf (sum,"%s%02x",sum, bin_sum[i]);
+			fclose(fp);
+			return 0;
+		}
+	}
+	return 1;
+}
+
+int testMD5sum(const char * fileName,char * sum)
+{
+	char newSum[33]="";
+	if (getMD5sum(fileName,newSum))
+		return 1;
+	return strcmp(newSum,sum);
+}
--- misc/mozilla/mailnews/addrbook/src/nsAbMDBCardProperty.cpp	2006-12-22 14:51:38.000000000 +0100
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbMDBCardProperty.cpp	2008-08-14 16:22:21.000000000 +0200
@@ -273,8 +273,7 @@
 	if (mCardDatabase)
 	{
 		mCardDatabase->EditCard(this, PR_TRUE);
-    mCardDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
-		return NS_OK;
+		return mCardDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
 	}
 	else
 		return NS_ERROR_FAILURE;
--- misc/mozilla/mailnews/addrbook/src/nsAbMDBDirectory.cpp	2008-01-29 20:31:58.000000000 +0100
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbMDBDirectory.cpp	2008-08-14 16:22:21.000000000 +0200
@@ -561,7 +561,7 @@
         }
       }
     }
-    mDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
+    rv = mDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
   }
   return rv;
 }
@@ -707,6 +707,7 @@
     return NS_ERROR_NOT_IMPLEMENTED;
 
   nsresult rv = NS_OK;
+
   if (!mDatabase)
     rv = GetAbDatabase();
 
@@ -736,10 +737,11 @@
     mDatabase->CreateNewListCardAndAddToDB(this, m_dbRowID, newCard, PR_TRUE /* notify */);
   else
     mDatabase->CreateNewCardAndAddToDB(newCard, PR_TRUE);
-  mDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
+  rv = mDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
 
+  NS_ENSURE_SUCCESS(rv, rv);
   NS_IF_ADDREF(*addedCard = newCard);
-  return NS_OK;
+  return rv;
 }
 
 NS_IMETHODIMP nsAbMDBDirectory::DropCard(nsIAbCard* aCard, PRBool needToCopyCard)
--- misc/mozilla/mailnews/addrbook/src/nsAbOutlookCard.cpp	2004-07-31 20:04:18.000000000 +0200
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbOutlookCard.cpp	2008-08-14 16:22:21.000000000 +0200
@@ -94,6 +94,7 @@
 {
     index_DisplayName = 0,
     index_EmailAddress,
+    index_SecondEmailAddress,
     index_FirstName,
     index_LastName,
     index_NickName,
@@ -121,32 +122,34 @@
 
 static const ULONG OutlookCardMAPIProps [] = 
 {
-    PR_DISPLAY_NAME_W,
-    PR_EMAIL_ADDRESS_W,
-    PR_GIVEN_NAME_W,
-    PR_SURNAME_W,
-    PR_NICKNAME_W,
-    PR_BUSINESS_TELEPHONE_NUMBER_W,
-    PR_HOME_TELEPHONE_NUMBER_W,
-    PR_BUSINESS_FAX_NUMBER_W,
-    PR_PAGER_TELEPHONE_NUMBER_W,
-    PR_MOBILE_TELEPHONE_NUMBER_W,
-    PR_HOME_ADDRESS_CITY_W,
-    PR_HOME_ADDRESS_STATE_OR_PROVINCE_W,
-    PR_HOME_ADDRESS_POSTAL_CODE_W,
-    PR_HOME_ADDRESS_COUNTRY_W,
-    PR_BUSINESS_ADDRESS_CITY_W,
-    PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE_W,
-    PR_BUSINESS_ADDRESS_POSTAL_CODE_W,
-    PR_BUSINESS_ADDRESS_COUNTRY_W,
-    PR_TITLE_W,
-    PR_DEPARTMENT_NAME_W,
-    PR_COMPANY_NAME_W,
-    PR_BUSINESS_HOME_PAGE_W,
-    PR_PERSONAL_HOME_PAGE_W,
-    PR_COMMENT_W
+    PR_DISPLAY_NAME_A,//0x8035001E
+    PR_EMAIL_ADDRESS_A,//0x8034001E
+    PR_SECOND_EMAIL_ADDRESS_A,//Second Email Address
+    PR_GIVEN_NAME_A,
+    PR_SURNAME_A,
+    PR_NICKNAME_A,
+    PR_BUSINESS_TELEPHONE_NUMBER_A,
+    PR_HOME_TELEPHONE_NUMBER_A,
+    PR_BUSINESS_FAX_NUMBER_A,
+    PR_PAGER_TELEPHONE_NUMBER_A,
+    PR_MOBILE_TELEPHONE_NUMBER_A,
+    PR_HOME_ADDRESS_CITY_A,
+    PR_HOME_ADDRESS_STATE_OR_PROVINCE_A,
+    PR_HOME_ADDRESS_POSTAL_CODE_A,
+    PR_HOME_ADDRESS_COUNTRY_A,
+    PR_BUSINESS_ADDRESS_CITY_A,
+    PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE_A,
+    PR_BUSINESS_ADDRESS_POSTAL_CODE_A,
+    PR_BUSINESS_ADDRESS_COUNTRY_A,
+    PR_TITLE_A,
+    PR_DEPARTMENT_NAME_A,
+    PR_COMPANY_NAME_A,
+    PR_BUSINESS_HOME_PAGE_A,
+    PR_PERSONAL_HOME_PAGE_A,
+    PR_COMMENT_A
 } ;
 
+
 nsresult nsAbOutlookCard::Init(const char *aUri)
 {
     nsresult retCode = nsRDFResource::Init(aUri) ;
@@ -173,6 +176,7 @@
         SetDisplayName(unichars [index_DisplayName]->get()) ;
         SetNickName(unichars [index_NickName]->get()) ;
         SetPrimaryEmail(unichars [index_EmailAddress]->get()) ;
+        SetSecondEmail(unichars [index_SecondEmailAddress]->get()) ;
         SetWorkPhone(unichars [index_WorkPhoneNumber]->get()) ;
         SetHomePhone(unichars [index_HomePhoneNumber]->get()) ;
         SetFaxNumber(unichars [index_WorkFaxNumber]->get()) ;
@@ -207,12 +211,12 @@
     nsAutoString unichar ;
     nsAutoString unicharBis ;
 
-    if (mapiAddBook->GetPropertyUString(*mMapiData, PR_HOME_ADDRESS_STREET_W, unichar)) {
+    if (mapiAddBook->GetPropertyUString(*mMapiData, PR_HOME_ADDRESS_STREET_A, unichar)) {
         splitString(unichar, unicharBis) ;
         SetHomeAddress(unichar.get()) ;
         SetHomeAddress2(unicharBis.get()) ;
     }
-    if (mapiAddBook->GetPropertyUString(*mMapiData, PR_BUSINESS_ADDRESS_STREET_W, unichar)) {
+    if (mapiAddBook->GetPropertyUString(*mMapiData, PR_BUSINESS_ADDRESS_STREET_A, unichar)) {
         splitString(unichar, unicharBis) ;
         SetWorkAddress(unichar.get()) ;
         SetWorkAddress2(unicharBis.get()) ;
@@ -290,6 +294,7 @@
     SetDisplayName(properties [index_DisplayName]) ;
     GetNickName(getter_Copies(properties [index_NickName])) ;
     GetPrimaryEmail(getter_Copies(properties [index_EmailAddress])) ;
+    GetSecondEmail(getter_Copies(properties [index_SecondEmailAddress])) ;
     GetWorkPhone(getter_Copies(properties [index_WorkPhoneNumber])) ;
     GetHomePhone(getter_Copies(properties [index_HomePhoneNumber])) ;
     GetFaxNumber(getter_Copies(properties [index_WorkFaxNumber])) ;
@@ -309,9 +314,16 @@
     GetWebPage1(getter_Copies(properties [index_WorkWebPage])) ;
     GetWebPage2(getter_Copies(properties [index_HomeWebPage])) ;
     GetNotes(getter_Copies(properties [index_Comments])) ;
-    if (!mapiAddBook->SetPropertiesUString(*mMapiData, OutlookCardMAPIProps, 
-        index_LastProp, properties)) {
-        PRINTF(("Cannot set general properties.\n")) ;
+
+    int i=0;
+    for (i=0;i<index_LastProp;i++)
+    {
+        if (!mapiAddBook->SetPropertyUString(*mMapiData,
+                                            OutlookCardMAPIProps[i],
+                                            properties[i]))
+        {
+            PRINTF(("Cannot set properties:%d.\n",OutlookCardMAPIProps[i])) ;
+    }
     }
     delete [] properties ;
     nsXPIDLString unichar ;
--- misc/mozilla/mailnews/addrbook/src/nsAbOutlookDirFactory.cpp	2004-04-17 20:32:14.000000000 +0200
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbOutlookDirFactory.cpp	2008-08-14 16:22:21.000000000 +0200
@@ -124,8 +124,8 @@
     nsCAutoString uri ;
     nsCOMPtr<nsIRDFResource> resource ;
 
-    for (ULONG i = 0 ; i < folders.mNbEntries ; ++ i) {
-        folders.mEntries [i].ToString(entryId) ;
+    for (ULONG i = 0 ; i < folders.GetSize() ; ++ i) {
+        folders[i].ToString(entryId) ;
         buildAbWinUri(kOutlookDirectoryScheme, abType, uri) ;
         uri.Append(entryId) ;
         
--- misc/mozilla/mailnews/addrbook/src/nsAbOutlookDirectory.cpp	2006-12-22 14:51:38.000000000 +0100
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbOutlookDirectory.cpp	2008-08-14 16:22:21.000000000 +0200
@@ -126,7 +126,7 @@
         PRINTF(("Cannot get type.\n")) ;
         return NS_ERROR_FAILURE ;
     }
-    if (!mapiAddBook->GetPropertyUString(*mMapiData, PR_DISPLAY_NAME_W, unichars)) {
+    if (!mapiAddBook->GetPropertyUString(*mMapiData, PR_DISPLAY_NAME_A, unichars)) {
         PRINTF(("Cannot get name.\n")) ;
         return NS_ERROR_FAILURE ;
     }
@@ -163,45 +163,85 @@
     return retCode;
 }
 
+nsresult nsAbOutlookDirectory::BuildCardFromURI(const nsCString& uriName,nsIAbCard **aNewCard, 
+                                                PRBool aSearchForOld, PRBool& aIsNewCard)
+{   
+    nsresult retCode = NS_OK ;
+    if (aSearchForOld) {
+        nsCStringKey key(uriName) ;
+        nsCOMPtr<nsISupports> existingCard = mCardList.Get(&key) ;
+        
+        if (existingCard) {
+            nsCOMPtr<nsIAbCard> card(do_QueryInterface(existingCard, &retCode)) ;
+            
+            NS_ENSURE_SUCCESS(retCode, retCode) ;
+            NS_IF_ADDREF(*aNewCard = card) ;
+            aIsNewCard = PR_FALSE ;
+            return retCode ;
+        }
+    }
+    aIsNewCard = PR_TRUE ;
+    nsCOMPtr<nsIRDFResource> resource ;
+
+    nsCOMPtr<nsIAbCard> childCard = do_CreateInstance(NS_ABOUTLOOKCARD_CONTRACTID, &retCode);
+    NS_ENSURE_SUCCESS(retCode, retCode) ;
+    resource = do_QueryInterface(childCard, &retCode) ;
+    NS_ENSURE_SUCCESS(retCode, retCode) ;
+    retCode = resource->Init(uriName.get()) ;
+    NS_ENSURE_SUCCESS(retCode, retCode) ;
+    NS_IF_ADDREF(*aNewCard = childCard);
+    return retCode ;
+}
+
 NS_IMETHODIMP nsAbOutlookDirectory::GetChildCards(nsIEnumerator **aCards)
 {
     if (!aCards) { return NS_ERROR_NULL_POINTER ; }
     *aCards = nsnull ;
     nsCOMPtr<nsISupportsArray> cardList ;
+    nsCStringArray uriList ;
+    nsAbWinHelperGuard mapiAddBook (mAbWinType) ;
     nsresult retCode ;
     
-    mCardList.Reset() ;
     if (mIsQueryURI) {
         retCode = StartSearch() ;
-        NS_NewISupportsArray(getter_AddRefs(cardList)) ;
     }
     else {
-        retCode = GetChildCards(getter_AddRefs(cardList), nsnull) ;
+        retCode = GetChildCards(uriList, nsnull) ;
     }
+    NS_NewISupportsArray(getter_AddRefs(cardList)) ;
     if (NS_SUCCEEDED(retCode)) {
         // Fill the results array and update the card list
         // Also update the address list and notify any changes.
         PRUint32 nbCards = 0 ;
-        nsCOMPtr<nsISupports> element ;
+        nsCAutoString uriName;
+        nsCOMPtr <nsIAbCard> childCard;
+        PRBool searchForOldCards = 0; //(mCardList.Count() != 0) ;
+
+        nbCards = uriList.Count();
+		NS_NewISupportsArray(getter_AddRefs(m_AddressList));
         
-        cardList->Enumerate(aCards) ;
-        cardList->Count(&nbCards) ;
         for (PRUint32 i = 0 ; i < nbCards ; ++ i) {
-            cardList->GetElementAt(i, getter_AddRefs(element)) ;
-            nsVoidKey newKey (NS_STATIC_CAST(void *, element)) ;
-            nsCOMPtr<nsISupports> oldElement = mCardList.Get(&newKey) ;
+            PRBool isNewCard = PR_FALSE ;
 
-            if (!oldElement) {
+            uriList.CStringAt(i,uriName);
+            retCode = BuildCardFromURI(uriName,getter_AddRefs(childCard), searchForOldCards, isNewCard);
+            NS_ENSURE_SUCCESS(retCode, retCode) ;
+            cardList->AppendElement(childCard);
+
+            if (isNewCard) {
                 // We are dealing with a new element (probably directly
                 // added from Outlook), we may need to sync m_AddressList
-                mCardList.Put(&newKey, element) ;
-                nsCOMPtr<nsIAbCard> card (do_QueryInterface(element, &retCode)) ;
+                nsCStringKey newKey(uriName) ;
+
+                mCardList.Put(&newKey, childCard) ;
+                nsCOMPtr<nsIAbCard> card (do_QueryInterface(childCard, &retCode)) ;
 
                 NS_ENSURE_SUCCESS(retCode, retCode) ;
                 PRBool isMailList = PR_FALSE ;
 
                 retCode = card->GetIsMailList(&isMailList) ;
                 NS_ENSURE_SUCCESS(retCode, retCode) ;
+
                 if (isMailList) {
                     // We can have mailing lists only in folder, 
                     // we must add the directory to m_AddressList
@@ -224,18 +264,33 @@
                     NotifyItemAddition(card) ;
                 }
             }
-            else {
-                NS_ASSERTION(oldElement == element, "Different card stored") ;
             }
         }
+    return cardList->Enumerate(aCards) ;
     }
+
+static nsresult ExtractUriFromCard(nsIAbCard *aCard, nsCString& aUri) {
+    nsresult retCode = NS_OK ;
+    nsCOMPtr<nsIRDFResource> resource (do_QueryInterface(aCard, &retCode)) ;
+    
+    // Receiving a non-RDF card is accepted
+    if (NS_FAILED(retCode)) { return NS_OK ; }
+    nsXPIDLCString uri ;
+    
+    retCode = resource->GetValue(getter_Copies(uri)) ;
+    NS_ENSURE_SUCCESS(retCode, retCode) ;
+    aUri = uri.get() ;
     return retCode ;
 }
 
 NS_IMETHODIMP nsAbOutlookDirectory::HasCard(nsIAbCard *aCard, PRBool *aHasCard)
 {
     if (!aCard || !aHasCard) { return NS_ERROR_NULL_POINTER ; }
-    nsVoidKey key (NS_STATIC_CAST(void *, aCard)) ;
+    *aHasCard = PR_FALSE ;
+    nsCString uri ;
+
+    ExtractUriFromCard(aCard, uri) ;
+    nsCStringKey key(uri) ;
 
     *aHasCard = mCardList.Exists(&key) ;
     return NS_OK ;
@@ -317,7 +372,10 @@
                 PRINTF(("Cannot delete card %s.\n", entryString.get())) ;
             }
             else {
-                nsVoidKey key (NS_STATIC_CAST(void *, element)) ;
+                nsCString uri ;
+
+                ExtractUriFromCard(card, uri) ;
+                nsCStringKey key(uri) ;
                 
                 mCardList.Remove(&key) ;
                 if (m_IsMailList) { m_AddressList->RemoveElement(element) ; }
@@ -386,7 +444,10 @@
     }
     retCode = CreateCard(aData, addedCard) ;
     NS_ENSURE_SUCCESS(retCode, retCode) ;
-    nsVoidKey newKey (NS_STATIC_CAST(void *, *addedCard)) ;
+    nsCString uri ;
+
+    ExtractUriFromCard(*addedCard, uri) ;
+    nsCStringKey newKey(uri) ;
     
     mCardList.Put(&newKey, *addedCard) ;
     if (m_IsMailList) { m_AddressList->AppendElement(*addedCard) ; }
@@ -457,7 +518,7 @@
     if (!mapiAddBook->IsOK()) { return NS_ERROR_FAILURE ; }
     retCode = GetDirName(getter_Copies(name)) ;
     NS_ENSURE_SUCCESS(retCode, retCode) ;
-    if (!mapiAddBook->SetPropertyUString(*mMapiData, PR_DISPLAY_NAME_W, name.get())) {
+    if (!mapiAddBook->SetPropertyUString(*mMapiData, PR_DISPLAY_NAME_A, name.get())) {
         return NS_ERROR_FAILURE ;
     }
     retCode = CommitAddressList() ;
@@ -518,6 +579,7 @@
     {"DisplayName", PR_DISPLAY_NAME_A},
     {"NickName", PR_NICKNAME_A},
     {"PrimaryEmail", PR_EMAIL_ADDRESS_A},
+    {"SecondEmail",PR_SECOND_EMAIL_ADDRESS_A},
     {"WorkPhone", PR_BUSINESS_TELEPHONE_NUMBER_A},
     {"HomePhone", PR_HOME_TELEPHONE_NUMBER_A},
     {"FaxNumber", PR_BUSINESS_FAX_NUMBER_A},
@@ -1027,7 +1089,10 @@
 
 nsresult nsAbOutlookDirectory::OnSearchFoundCard(nsIAbCard *aCard) 
 {
-    nsVoidKey newKey (NS_STATIC_CAST(void *, aCard)) ;
+    nsCString uri ;
+
+    ExtractUriFromCard(aCard, uri) ;
+    nsCStringKey newKey(uri) ;
     nsresult retCode = NS_OK ;
     
     mCardList.Put(&newKey, aCard) ;
@@ -1051,14 +1116,14 @@
     retCode = BuildRestriction(aArguments, arguments) ;
     NS_ENSURE_SUCCESS(retCode, retCode) ;
     nsCOMPtr<nsISupportsArray> resultsArray ;
+    nsCStringArray uriArray ;
     PRUint32 nbResults = 0 ;
     
-    retCode = GetChildCards(getter_AddRefs(resultsArray), 
+    retCode = GetChildCards(uriArray, 
                             arguments.rt == RES_COMMENT ? nsnull : &arguments) ;
     DestroyRestriction(arguments) ;
     NS_ENSURE_SUCCESS(retCode, retCode) ;
-    retCode = resultsArray->Count(&nbResults) ;
-    NS_ENSURE_SUCCESS(retCode, retCode) ;
+    nbResults = uriArray.Count() ;
     nsCOMPtr<nsIAbDirectoryQueryResult> result ;
     nsAbDirectoryQueryResult *newResult = nsnull ;
 
@@ -1066,15 +1131,18 @@
         nbResults = NS_STATIC_CAST(PRUint32, aResultLimit) ; 
     }
     PRUint32 i = 0 ;
-    nsCOMPtr<nsISupports> element ;
     nsCOMPtr<nsISupportsArray> propertyValues ;
     
+    nsCAutoString uriName;
+    nsCOMPtr <nsIAbCard> card;
+
     for (i = 0 ; i < nbResults ; ++ i) {
-        retCode = resultsArray->GetElementAt(i, getter_AddRefs(element)) ;
-        NS_ENSURE_SUCCESS(retCode, retCode) ;
-        nsCOMPtr<nsIAbCard> card (do_QueryInterface(element, &retCode)) ;
+        PRBool isNewCard = PR_FALSE ;
         
+        uriArray.CStringAt(i,uriName);
+        retCode = BuildCardFromURI(uriName,getter_AddRefs(card), PR_FALSE, isNewCard);
         NS_ENSURE_SUCCESS(retCode, retCode) ;
+        
         FillPropertyValues(card, aArguments, getter_AddRefs(propertyValues)) ;
         newResult = new nsAbDirectoryQueryResult(0, aArguments,
                                                  nsIAbDirectoryQueryResult::queryResultMatch, 
@@ -1099,13 +1167,43 @@
     if (!aCards) { return NS_ERROR_NULL_POINTER ; }
     *aCards = nsnull ;
     nsresult retCode = NS_OK ;
-    nsCOMPtr<nsISupportsArray> cards ;
+
+    nsCOMPtr<nsISupportsArray> cards;
+    retCode = NS_NewISupportsArray(getter_AddRefs(cards));
+    NS_ENSURE_SUCCESS(retCode, retCode) ;
+
+    nsCStringArray uriList;
+    retCode = GetChildCards(uriList,aRestriction);
+    NS_ENSURE_SUCCESS(retCode, retCode) ;
+    
+    nsCAutoString uriName;
+    nsCOMPtr <nsIAbCard> childCard;
+    PRUint32 nbURIs = 0 ;
+    nbURIs = uriList.Count();
+    PRUint32 i = 0 ;
+        
+    for (i = 0 ; i < nbURIs ; ++ i) {
+        PRBool isNewCard = PR_FALSE ;
+
+        uriList.CStringAt(i,uriName);
+        retCode = BuildCardFromURI(uriName,getter_AddRefs(childCard), PR_TRUE, isNewCard);
+        NS_ENSURE_SUCCESS(retCode, retCode) ;
+        cards->AppendElement(childCard);
+    }        
+    
+    NS_IF_ADDREF(*aCards = cards);
+    return retCode ;
+}
+
+nsresult nsAbOutlookDirectory::GetChildCards(nsCStringArray& aURI, 
+                                             void *aRestriction)
+{
+    nsresult retCode = NS_OK ;
     nsAbWinHelperGuard mapiAddBook (mAbWinType) ;
     nsMapiEntryArray cardEntries ;
     LPSRestriction restriction = (LPSRestriction) aRestriction ;
 
     if (!mapiAddBook->IsOK()) { return NS_ERROR_FAILURE ; }
-    retCode = NS_NewISupportsArray(getter_AddRefs(cards)) ;
     NS_ENSURE_SUCCESS(retCode, retCode) ;
     if (!mapiAddBook->GetCards(*mMapiData, restriction, cardEntries)) {
         PRINTF(("Cannot get cards.\n")) ;
@@ -1114,22 +1212,14 @@
     nsCAutoString entryId ;
     nsCAutoString uriName ;
     nsCOMPtr<nsIRDFResource> resource ;
-    nsCOMPtr <nsIAbCard> childCard;
-        
-    for (ULONG card = 0 ; card < cardEntries.mNbEntries ; ++ card) {
-        cardEntries.mEntries [card].ToString(entryId) ;
+    aURI.Clear();
+    
+    for (ULONG card = 0 ; card < cardEntries.GetSize() ; ++ card) {
+        cardEntries [card].ToString(entryId) ;
         buildAbWinUri(kOutlookCardScheme, mAbWinType, uriName) ;
         uriName.Append(entryId) ;
-        childCard = do_CreateInstance(NS_ABOUTLOOKCARD_CONTRACTID, &retCode);
-        NS_ENSURE_SUCCESS(retCode, retCode) ;
-        resource = do_QueryInterface(childCard, &retCode) ;
-        NS_ENSURE_SUCCESS(retCode, retCode) ;
-        retCode = resource->Init(uriName.get()) ;
-        NS_ENSURE_SUCCESS(retCode, retCode) ;
-        cards->AppendElement(childCard) ;
+        aURI.AppendCString(uriName);
     }
-    *aCards = cards ;
-    NS_ADDREF(*aCards) ;
     return retCode ;
 }
 
@@ -1153,8 +1243,8 @@
     nsCAutoString uriName ;
     nsCOMPtr <nsIRDFResource> resource ;
 
-    for (ULONG node = 0 ; node < nodeEntries.mNbEntries ; ++ node) {
-        nodeEntries.mEntries [node].ToString(entryId) ;
+    for (ULONG node = 0 ; node < nodeEntries.GetSize() ; ++ node) {
+        nodeEntries [node].ToString(entryId) ;
         buildAbWinUri(kOutlookDirectoryScheme, mAbWinType, uriName) ;
         uriName.Append(entryId) ;
         retCode = gRDFService->GetResource(uriName, getter_AddRefs(resource)) ;
@@ -1275,7 +1365,7 @@
         // In the case of a mailing list, we cannot directly create a new card,
         // we have to create a temporary one in a real folder (to be able to use
         // templates) and then copy it to the mailing list.
-        if (m_IsMailList) {
+        if (m_IsMailList && mAbWinType == nsAbWinType_OutlookExp) {
             nsMapiEntry parentEntry ;
             nsMapiEntry temporaryEntry ;
 
--- misc/mozilla/mailnews/addrbook/src/nsAbOutlookDirectory.h	2004-04-17 20:32:14.000000000 +0200
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbOutlookDirectory.h	2008-08-14 16:22:21.000000000 +0200
@@ -46,6 +46,7 @@
 #include "nsHashtable.h"
 
 #include "nsISupportsArray.h"
+#include "nsVoidArray.h"
 
 struct nsMapiEntry ;
 
@@ -92,6 +93,8 @@
 protected:
     // Retrieve hierarchy as cards, with an optional restriction
     nsresult GetChildCards(nsISupportsArray **aCards, void *aRestriction) ;
+    // Retrieve hierarchy as URIs, with an optional restriction
+    nsresult GetChildCards(nsCStringArray& aURI, void *aRestriction) ;
     // Retrieve hierarchy as directories
     nsresult GetChildNodes(nsISupportsArray **aNodes) ;
     // Create a new card
@@ -103,6 +106,9 @@
     nsresult CommitAddressList(void) ;
     // Read MAPI repository
     nsresult UpdateAddressList(void) ;
+    // Search for an existing card or build a new one
+    nsresult BuildCardFromURI(const nsCString& uriName,nsIAbCard **aNewCard, 
+                              PRBool aSearchForOld, PRBool& aIsNewCard) ;
 
     nsMapiEntry *mMapiData ;
     // Container for the query threads
--- misc/mozilla/mailnews/addrbook/src/nsAbWinHelper.cpp	2005-05-07 08:11:28.000000000 +0200
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbWinHelper.cpp	2008-08-14 16:22:21.000000000 +0200
@@ -42,6 +42,9 @@
 #define USES_IID_IABContainer
 #define USES_IID_IMAPITable
 #define USES_IID_IDistList
+#define USES_IID_IMsgStore
+#define USES_IID_IMessage
+#define USES_IID_IMAPIFolder
 
 #include "nsAbWinHelper.h"
 #include "nsMapiAddressBook.h"
@@ -59,19 +62,6 @@
 
 #define PRINTF(args) PR_LOG(gAbWinHelperLog, PR_LOG_DEBUG, args)
 
-// Small utility to ensure release of all MAPI interfaces
-template <class tInterface> struct nsMapiInterfaceWrapper
-{
-    tInterface mInterface ;
-
-    nsMapiInterfaceWrapper(void) : mInterface(NULL) {}
-    ~nsMapiInterfaceWrapper(void) {
-        if (mInterface != NULL) { mInterface->Release() ; }
-    }
-    operator LPUNKNOWN *(void) { return NS_REINTERPRET_CAST(LPUNKNOWN *, &mInterface) ; }
-    tInterface operator -> (void) const { return mInterface ; }
-    operator tInterface *(void) { return &mInterface ; }
-} ;
 
 static void assignEntryID(LPENTRYID& aTarget, LPENTRYID aSource, ULONG aByteCount)
 {
@@ -249,24 +239,28 @@
 MOZ_DECL_CTOR_COUNTER(nsMapiEntryArray)
 
 nsMapiEntryArray::nsMapiEntryArray(void)
-: mEntries(NULL), mNbEntries(0)
 {
     MOZ_COUNT_CTOR(nsMapiEntryArray) ;
 }
 
 nsMapiEntryArray::~nsMapiEntryArray(void)
 {
-    if (mEntries) { delete [] mEntries ; }
+    CleanUp();
     MOZ_COUNT_DTOR(nsMapiEntryArray) ;
 }
-
+void  nsMapiEntryArray::AddItem(nsMapiEntry * aEntries)
+{
+    m_array.AppendElement(aEntries);
+}
 void nsMapiEntryArray::CleanUp(void)
 {
-    if (mEntries != NULL) { 
-        delete [] mEntries ;
-        mEntries = NULL ;
-        mNbEntries = 0 ;
+    nsMapiEntry *pEntries;
+    for (int i = 0; i < m_array.Count(); i++)
+    {
+        pEntries = (nsMapiEntry *)m_array.ElementAt( i);
+        delete pEntries;
     }
+    m_array.Clear();
 }
 
 MOZ_DECL_CTOR_COUNTER(nsAbWinHelper)
@@ -280,100 +274,55 @@
 // same protection (MAPI is supposed to be thread-safe).
 PRLock *nsAbWinHelper::mMutex = PR_NewLock() ;
 
+int            nsAbWinHelper::m_clients = 0;
+
+PRUnichar *    nsAbWinHelper::m_pUniBuff = NULL;
+int            nsAbWinHelper::m_uniBuffLen = 0;
+char      *    nsAbWinHelper::m_pCStrBuff = NULL;
+int            nsAbWinHelper::m_cstrBuffLen = 0;
+
 nsAbWinHelper::nsAbWinHelper(void)
-: mAddressBook(NULL), mLastError(S_OK)
+:mLastError(S_OK)
 {
     MOZ_COUNT_CTOR(nsAbWinHelper) ;
+    m_clients++;
 }
 
 nsAbWinHelper::~nsAbWinHelper(void)
 {
     MOZ_COUNT_DTOR(nsAbWinHelper) ;
-}
-
-BOOL nsAbWinHelper::GetFolders(nsMapiEntryArray& aFolders)
+    m_clients--;
+    if (!m_clients)
 {
-    aFolders.CleanUp() ;
-    nsMapiInterfaceWrapper<LPABCONT> rootFolder ;
-    nsMapiInterfaceWrapper<LPMAPITABLE> folders ;
-    ULONG objType = 0 ;
-    ULONG rowCount = 0 ;
-    SRestriction restriction ;
-    SPropTagArray folderColumns ;
-
-    mLastError = mAddressBook->OpenEntry(0, NULL, NULL, 0, &objType, 
-                                         rootFolder) ;
-    if (HR_FAILED(mLastError)) { 
-        PRINTF(("Cannot open root %08x.\n", mLastError)) ;
-        return FALSE ; 
+        delete [] m_pUniBuff;
+        m_pUniBuff = NULL;
+        m_uniBuffLen = 0;
+        delete [] m_pCStrBuff;
+        m_pCStrBuff = NULL;
+        m_cstrBuffLen = 0;
     }
-    mLastError = rootFolder->GetHierarchyTable(0, folders) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot get hierarchy %08x.\n", mLastError)) ;
-        return FALSE ; 
     }
-    // We only take into account modifiable containers, 
-    // otherwise, we end up with all the directory services...
-    restriction.rt = RES_BITMASK ;
-    restriction.res.resBitMask.ulPropTag = PR_CONTAINER_FLAGS ;
-    restriction.res.resBitMask.relBMR = BMR_NEZ ;
-    restriction.res.resBitMask.ulMask = AB_MODIFIABLE ;
-    mLastError = folders->Restrict(&restriction, 0) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot restrict table %08x.\n", mLastError)) ;
-    }
-    folderColumns.cValues = 1 ;
-    folderColumns.aulPropTag [0] = PR_ENTRYID ;
-    mLastError = folders->SetColumns(&folderColumns, 0) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
-        return FALSE ;
-    }
-    mLastError = folders->GetRowCount(0, &rowCount) ;
-    if (HR_SUCCEEDED(mLastError)) {
-        aFolders.mEntries = new nsMapiEntry [rowCount] ;
-        aFolders.mNbEntries = 0 ;
-        do {
-            LPSRowSet rowSet = NULL ;
-
-            rowCount = 0 ;
-            mLastError = folders->QueryRows(1, 0, &rowSet) ;
-            if (HR_SUCCEEDED(mLastError)) {
-                rowCount = rowSet->cRows ;
-                if (rowCount > 0) {
-                    nsMapiEntry& current = aFolders.mEntries [aFolders.mNbEntries ++] ;
-                    SPropValue& currentValue = rowSet->aRow->lpProps [0] ;
-                    
-                    current.Assign(currentValue.Value.bin.cb,
-                                   NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
-                }
-                MyFreeProws(rowSet) ;
-            }
-            else {
-                PRINTF(("Cannot query rows %08x.\n", mLastError)) ;
-            }
-        } while (rowCount > 0) ;
-    }
-    return HR_SUCCEEDED(mLastError) ;
-}
+
 
 BOOL nsAbWinHelper::GetCards(const nsMapiEntry& aParent, LPSRestriction aRestriction,
                              nsMapiEntryArray& aCards)
 {
     aCards.CleanUp() ;
-    return GetContents(aParent, aRestriction, &aCards.mEntries, aCards.mNbEntries, 0) ;
+    return GetContents(aParent, aRestriction, &aCards, 0) ;
 }
  
 BOOL nsAbWinHelper::GetNodes(const nsMapiEntry& aParent, nsMapiEntryArray& aNodes)
 { 
     aNodes.CleanUp() ;
-    return GetContents(aParent, NULL, &aNodes.mEntries, aNodes.mNbEntries, MAPI_DISTLIST) ;
+    return GetContents(aParent, NULL, &aNodes, MAPI_DISTLIST) ;
 }
 
 BOOL nsAbWinHelper::GetCardsCount(const nsMapiEntry& aParent, ULONG& aNbCards) 
 {
-    aNbCards = 0 ;
-    return GetContents(aParent, NULL, NULL, aNbCards, 0) ;
+    nsMapiEntryArray aCards;
+    BOOL ret=GetContents(aParent, NULL, &aCards,  0) ;
+    aNbCards=aCards.GetSize();
+    return ret;
 }
 
 BOOL nsAbWinHelper::GetPropertyString(const nsMapiEntry& aObject,
@@ -390,7 +339,7 @@
             aName = values->Value.lpszA ;
         }
         else if (PROP_TYPE(values->ulPropTag) == PT_UNICODE) {
-            aName.AssignWithConversion(values->Value.lpszW) ;
+            UnicodeToCStr(values->Value.lpszW,aName) ;
         }
     }
     FreeBuffer(values) ;
@@ -410,7 +359,7 @@
             aName = values->Value.lpszW ;
         }
         else if (PROP_TYPE(values->ulPropTag) == PT_STRING8) {
-            aName.AssignWithConversion(values->Value.lpszA) ;
+            CStrToUnicode(values->Value.lpszA,aName) ;
         }
     }
     FreeBuffer(values) ;
@@ -431,16 +380,22 @@
         ULONG i = 0 ;
 
         for (i = 0 ; i < valueCount ; ++ i) {
-            if (PROP_ID(values [i].ulPropTag) == PROP_ID(aPropertyTags [i])) {
+            if (PROP_TYPE( values [i].ulPropTag) != PT_ERROR && values [i].Value.l != MAPI_E_NOT_FOUND){
                 if (PROP_TYPE(values [i].ulPropTag) == PT_STRING8) {
                     nsAutoString temp ;
 
-                    temp.AssignWithConversion (values [i].Value.lpszA) ;
+                    CStrToUnicode(values [i].Value.lpszA,temp) ;
                     aNames.AppendString(temp) ;
                 }
                 else if (PROP_TYPE(values [i].ulPropTag) == PT_UNICODE) {
                     aNames.AppendString(nsAutoString (values [i].Value.lpszW)) ;
                 }
+                else if (aPropertyTags [i] == PR_EMAIL_ADDRESS_A) {
+                    nsAutoString temp ;
+
+                    CStrToUnicode (values [i].Value.lpszA,temp) ;
+                    aNames.AppendString(temp) ;
+                }
                 else {
                     aNames.AppendString(nsAutoString((const PRUnichar *) "")) ;
                 }
@@ -466,7 +421,6 @@
     if (!GetMAPIProperties(aObject, &aPropertyTag, 1, values, valueCount)) { return FALSE ; }
     if (valueCount == 1 && values != NULL && PROP_TYPE(values->ulPropTag) == PT_SYSTIME) {
         SYSTEMTIME readableTime ;
-
         if (FileTimeToSystemTime(&values->Value.ft, &readableTime)) {
             aYear = readableTime.wYear ;
             aMonth = readableTime.wMonth ;
@@ -518,7 +472,7 @@
     nsMapiInterfaceWrapper<LPMAPIPROP> subObject ;
     ULONG objType = 0 ;
     
-    mLastError = mAddressBook->OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+    mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
                                          &IID_IMAPIContainer, 0, &objType, 
                                          container) ;
     if (HR_FAILED(mLastError)) {
@@ -537,7 +491,7 @@
     SBinary entry ;
     SBinaryArray entryArray ;
 
-    mLastError = mAddressBook->OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+    mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
                                          &IID_IABContainer, MAPI_MODIFY, &objType, 
                                          container) ;
     if (HR_FAILED(mLastError)) {
@@ -567,14 +521,15 @@
         value.Value.lpszW = NS_CONST_CAST(WCHAR *, aValue) ;
     }
     else if (PROP_TYPE(aPropertyTag) == PT_STRING8) {
-        alternativeValue.AssignWithConversion(aValue) ;
+        UnicodeToCStr(aValue,alternativeValue) ;
         value.Value.lpszA = NS_CONST_CAST(char *, alternativeValue.get()) ;
     }
     else {
         PRINTF(("Property %08x is not a string.\n", aPropertyTag)) ;
         return TRUE ;
     }
-    return SetMAPIProperties(aObject, 1, &value) ;
+    LPSPropValue values=&value;
+    return SetMAPIProperties(aObject, 1, values) ;
 }
 
 BOOL nsAbWinHelper::SetPropertiesUString(const nsMapiEntry& aObject, const ULONG *aPropertiesTag,
@@ -595,7 +550,7 @@
             values [currentValue ++].Value.lpszW = NS_CONST_CAST(WCHAR *, aValues [i].get()) ;
         }
         else if (PROP_TYPE(aPropertiesTag [i]) == PT_STRING8) {
-            alternativeValue.AssignWithConversion(aValues [i].get()) ;
+            UnicodeToCStr(aValues [i].get(),alternativeValue) ;
             char *av = nsCRT::strdup(alternativeValue.get()) ;
             if (!av) {
                 retCode = FALSE ;
@@ -633,7 +588,8 @@
         readableTime.wSecond = 0 ;
         readableTime.wMilliseconds = 0 ;
         if (SystemTimeToFileTime(&readableTime, &value.Value.ft)) {
-            return SetMAPIProperties(aObject, 1, &value) ;
+            LPSPropValue values=&value;
+            return SetMAPIProperties(aObject, 1, values) ;
         }
         return TRUE ;
     }
@@ -645,7 +601,7 @@
     nsMapiInterfaceWrapper<LPABCONT> container ;
     ULONG objType = 0 ;
 
-    mLastError = mAddressBook->OpenEntry(aParent.mByteCount, aParent.mEntryId,
+    mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
                                          &IID_IABContainer, MAPI_MODIFY, &objType,
                                          container) ;
     if (HR_FAILED(mLastError)) { 
@@ -708,7 +664,7 @@
     nsMapiInterfaceWrapper<LPABCONT> container ;
     ULONG objType = 0 ;
 
-    mLastError = mAddressBook->OpenEntry(aParent.mByteCount, aParent.mEntryId,
+    mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
                                          &IID_IABContainer, MAPI_MODIFY, &objType,
                                          container) ;
     if (HR_FAILED(mLastError)) {
@@ -773,7 +729,7 @@
     nsMapiInterfaceWrapper<LPABCONT> container ;
     ULONG objType = 0 ;
 
-    mLastError = mAddressBook->OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+    mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
                                          &IID_IABContainer, MAPI_MODIFY, &objType,
                                          container) ;
     if (HR_FAILED(mLastError)) { 
@@ -810,194 +766,77 @@
     return TRUE ;
 }
 
-BOOL nsAbWinHelper::GetDefaultContainer(nsMapiEntry& aContainer)
-{
-    LPENTRYID entryId = NULL ; 
-    ULONG byteCount = 0 ;
-
-    mLastError = mAddressBook->GetPAB(&byteCount, &entryId) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot get PAB %08x.\n", mLastError)) ;
-        return FALSE ;
-    }
-    aContainer.Assign(byteCount, entryId) ;
-    FreeBuffer(entryId) ;
-    return TRUE ;
-}
 
-enum
-{
-    ContentsColumnEntryId = 0,
-    ContentsColumnObjectType,
-    ContentsColumnsSize
-} ;
 
-static const SizedSPropTagArray(ContentsColumnsSize, ContentsColumns) =
-{
-    ContentsColumnsSize,
-    {
-        PR_ENTRYID,
-        PR_OBJECT_TYPE
-    }
-} ;
 
-BOOL nsAbWinHelper::GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction,
-                                nsMapiEntry **aList, ULONG& aNbElements, ULONG aMapiType)
+void nsAbWinHelper::MyFreeProws(LPSRowSet aRowset)
 {
-    if (aList != NULL) { *aList = NULL ; }
-    aNbElements = 0 ;
-    nsMapiInterfaceWrapper<LPMAPICONTAINER> parent ;
-    nsMapiInterfaceWrapper<LPMAPITABLE> contents ;
-    ULONG objType = 0 ;
-    ULONG rowCount = 0 ;
+    if (aRowset == NULL) { return ; }
+    ULONG i = 0 ;
 
-    mLastError = mAddressBook->OpenEntry(aParent.mByteCount, aParent.mEntryId, 
-                                         &IID_IMAPIContainer, 0, &objType, 
-                                         parent) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot open parent %08x.\n", mLastError)) ;
-        return FALSE ; 
-    }
-    // Here, flags for WAB and MAPI could be different, so this works
-    // only as long as we don't want to use any flag in GetContentsTable
-    mLastError = parent->GetContentsTable(0, contents) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot get contents %08x.\n", mLastError)) ;
-        return FALSE ; 
+    for (i = 0 ; i < aRowset->cRows ; ++ i) {
+        FreeBuffer(aRowset->aRow [i].lpProps) ;
     }
-    if (aRestriction != NULL) {
-        mLastError = contents->Restrict(aRestriction, 0) ;
-        if (HR_FAILED(mLastError)) {
-            PRINTF(("Cannot set restriction %08x.\n", mLastError)) ;
-            return FALSE ;
-        }
-    }
-    mLastError = contents->SetColumns((LPSPropTagArray) &ContentsColumns, 0) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
-        return FALSE ;
-    }
-    mLastError = contents->GetRowCount(0, &rowCount) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot get result count %08x.\n", mLastError)) ;
-        return FALSE ;
-    }
-    if (aList != NULL) { *aList = new nsMapiEntry [rowCount] ; }
-    aNbElements = 0 ;
-    do {
-        LPSRowSet rowSet = NULL ;
-        
-        rowCount = 0 ;
-        mLastError = contents->QueryRows(1, 0, &rowSet) ;
-        if (HR_FAILED(mLastError)) {
-            PRINTF(("Cannot query rows %08x.\n", mLastError)) ;
-            return FALSE ;
-        }
-        rowCount = rowSet->cRows ;
-        if (rowCount > 0 &&
-            (aMapiType == 0 ||
-            rowSet->aRow->lpProps[ContentsColumnObjectType].Value.ul == aMapiType)) {
-            if (aList != NULL) {
-                nsMapiEntry& current = (*aList) [aNbElements] ;
-                SPropValue& currentValue = rowSet->aRow->lpProps[ContentsColumnEntryId] ;
-                
-                current.Assign(currentValue.Value.bin.cb,
-                    NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
+    FreeBuffer(aRowset) ;
+        }
+void nsAbWinHelper::CStrToUnicode( const char *pStr, nsString& result)
+{
+    result.Truncate( 0);
+    int wLen = MultiByteToWideChar( CP_ACP, 0, pStr, -1, m_pUniBuff, 0);
+    if (wLen >= m_uniBuffLen)
+    {
+        delete [] m_pUniBuff;
+        m_pUniBuff = new PRUnichar[wLen + 64];
+        m_uniBuffLen = wLen + 64;
             }
-            ++ aNbElements ;
+    if (wLen)
+    {
+        MultiByteToWideChar( CP_ACP, 0, pStr, -1, m_pUniBuff, m_uniBuffLen);
+        result = m_pUniBuff;
         }
-        MyFreeProws(rowSet) ;
-    } while (rowCount > 0) ;
-    return TRUE ;
 }
-
-BOOL nsAbWinHelper::GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
-                                      ULONG aNbProperties, LPSPropValue& aValue, 
-                                      ULONG& aValueCount)
+void nsAbWinHelper::UnicodeToCStr( const  PRUnichar *pUStr,nsCString& result)
 {
-    nsMapiInterfaceWrapper<LPMAPIPROP> object ;
-    ULONG objType = 0 ;
-    LPSPropTagArray properties = NULL ;
-    ULONG i = 0 ;
-    
-    mLastError = mAddressBook->OpenEntry(aObject.mByteCount, aObject.mEntryId,
-                                         &IID_IMAPIProp, 0, &objType, 
-                                         object) ;
-    if (HR_FAILED(mLastError)) { 
-        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
-        return FALSE ; 
+    result.Truncate( 0);
+    int cLen = WideCharToMultiByte( CP_ACP, 0, pUStr, -1, m_pCStrBuff, 0,NULL,NULL);
+    if (cLen >= m_cstrBuffLen) {
+        if (m_pCStrBuff)
+            delete [] m_pCStrBuff;
+        m_pCStrBuff = new char[cLen + 64];
+        m_cstrBuffLen = cLen + 64;
     }
-    AllocateBuffer(CbNewSPropTagArray(aNbProperties), 
-                   NS_REINTERPRET_CAST(void **, &properties)) ;
-    properties->cValues = aNbProperties ;
-    for (i = 0 ; i < aNbProperties ; ++ i) {
-        properties->aulPropTag [i] = aPropertyTags [i] ;
-    }
-    mLastError = object->GetProps(properties, 0, &aValueCount, &aValue) ;
-    FreeBuffer(properties) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot get props %08x.\n", mLastError)) ;
+    if (cLen) {
+        WideCharToMultiByte( CP_ACP, 0, pUStr, -1, m_pCStrBuff, m_cstrBuffLen,NULL,NULL);
+        result = m_pCStrBuff;
     }
-    return HR_SUCCEEDED(mLastError) ;
 }
 
-BOOL nsAbWinHelper::SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
-                                      const LPSPropValue& aValues)
-{
-    nsMapiInterfaceWrapper<LPMAPIPROP> object ;
-    ULONG objType = 0 ;
-    LPSPropProblemArray problems = NULL ;
+static nsAbWinHelper *getOutlookAddressBook(void) {
+    static nsMapiAddressBook *addressBook = NULL ;
 
-    mLastError = mAddressBook->OpenEntry(aObject.mByteCount, aObject.mEntryId,
-                                         &IID_IMAPIProp, MAPI_MODIFY, &objType, 
-                                         object) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
-        return FALSE ;
-    }
-    mLastError = object->SetProps(aNbProperties, aValues, &problems) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot update the object %08x.\n", mLastError)) ;
-        return FALSE ;
-    }
-    if (problems != NULL) {
-        for (ULONG i = 0 ; i < problems->cProblem ; ++ i) {
-            PRINTF(("Problem %d: index %d code %08x.\n", i, 
-                problems->aProblem [i].ulIndex, 
-                problems->aProblem [i].scode)) ;
-        }
-    }
-    mLastError = object->SaveChanges(0) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot commit changes %08x.\n", mLastError)) ;
-    }
-    return HR_SUCCEEDED(mLastError) ;
+    if (addressBook == NULL) { addressBook = new nsMapiAddressBook ; } 
+    return addressBook ;
 }
 
-void nsAbWinHelper::MyFreeProws(LPSRowSet aRowset)
-{
-    if (aRowset == NULL) { return ; }
-    ULONG i = 0 ; 
+static nsAbWinHelper *getOutlookExpAddressBook(void) {
+    static nsWabAddressBook *addressBook = NULL ;
 
-    for (i = 0 ; i < aRowset->cRows ; ++ i) {
-        FreeBuffer(aRowset->aRow [i].lpProps) ;
-    }
-    FreeBuffer(aRowset) ;
+    if (addressBook == NULL) { addressBook = new nsWabAddressBook ; } 
+    return addressBook ;
 }
 
 nsAbWinHelperGuard::nsAbWinHelperGuard(PRUint32 aType)
 : mHelper(NULL) 
 {
     switch(aType) {
-    case nsAbWinType_Outlook: mHelper = new nsMapiAddressBook ; break ;
-    case nsAbWinType_OutlookExp: mHelper = new nsWabAddressBook ; break ;
+    case nsAbWinType_Outlook: mHelper = getOutlookAddressBook() ; break ;
+    case nsAbWinType_OutlookExp: mHelper = getOutlookExpAddressBook() ; break ;
     default: break ;
     }
 }
 
 nsAbWinHelperGuard::~nsAbWinHelperGuard(void)
 {
-    delete mHelper ;
 }
 
 const char *kOutlookDirectoryScheme = "moz-aboutlookdirectory://" ;
--- misc/mozilla/mailnews/addrbook/src/nsAbWinHelper.h	2004-04-17 20:32:14.000000000 +0200
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbWinHelper.h	2008-08-14 16:22:21.000000000 +0200
@@ -45,6 +45,24 @@
 #include "nsVoidArray.h"
 #include "nsXPIDLString.h"
  
+#define PR_SECOND_EMAIL_ADDRESS_A  0x8033001E
+#define PR_SCREEN_NAME_A           0x805B001E
+ 
+
+// Small utility to ensure release of all MAPI interfaces
+template <class tInterface> struct nsMapiInterfaceWrapper
+{
+    tInterface mInterface ;
+
+    nsMapiInterfaceWrapper(void) : mInterface(NULL) {}
+    ~nsMapiInterfaceWrapper(void) {
+        if (mInterface ) { mInterface->Release() ; }
+    }
+    operator LPUNKNOWN *(void) { return NS_REINTERPRET_CAST(LPUNKNOWN *, &mInterface) ; }
+    tInterface operator -> (void) const { return mInterface ; }
+    operator tInterface *(void) { return &mInterface ; }
+} ;
+
 struct nsMapiEntry
 {
     ULONG     mByteCount ;
@@ -62,14 +80,28 @@
 
 struct nsMapiEntryArray 
 {
-    nsMapiEntry *mEntries ;
-    ULONG      mNbEntries ;
 
     nsMapiEntryArray(void) ;
     ~nsMapiEntryArray(void) ;
 
-    const nsMapiEntry& operator [] (int aIndex) const { return mEntries [aIndex] ; }
+    void  AddItem(nsMapiEntry * aEntries);
+    void  AddItem(    ULONG     mByteCount , LPENTRYID mEntryId )
+    {
+        nsMapiEntry * aEntries=new nsMapiEntry();
+        aEntries->Assign(mByteCount,mEntryId);
+        AddItem(aEntries);
+    }
+
+    ULONG        GetSize( void) { return( m_array.Count());}
+    nsMapiEntry& operator [] (int aIndex)  { return *(nsMapiEntry*)m_array.ElementAt(aIndex); }
+    nsMapiEntry* ElementAt(int aIndex)  { return (nsMapiEntry*)m_array.ElementAt(aIndex); }
     void CleanUp(void) ;
+    void Remove(nsMapiEntry * aEntries){ m_array.RemoveElement(aEntries); }
+    void Remove(int index){ m_array.RemoveElementAt(index); }
+    ULONG IndexOf(nsMapiEntry * aEntries){return m_array.IndexOf(aEntries);};
+private:
+    nsVoidArray        m_array;
+
 } ;
 
 class nsAbWinHelper
@@ -79,7 +111,7 @@
     virtual ~nsAbWinHelper(void) ;
 
     // Get the top address books
-    BOOL GetFolders(nsMapiEntryArray& aFolders) ;
+    virtual BOOL GetFolders(nsMapiEntryArray& aFolders) =0;
     // Get a list of entries for cards/mailing lists in a folder/mailing list
     BOOL GetCards(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
                   nsMapiEntryArray& aCards) ;
@@ -97,18 +129,14 @@
     BOOL GetPropertiesUString(const nsMapiEntry& aObject, const ULONG *aPropertiesTag, 
                               ULONG aNbProperties, nsStringArray& aValues) ;
     // Get the value of a MAPI property of type SYSTIME
-    BOOL GetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag, 
+    virtual BOOL GetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag, 
                          WORD& aYear, WORD& aMonth, WORD& aDay) ;
-    // Get the value of a MAPI property of type LONG
-    BOOL GetPropertyLong(const nsMapiEntry& aObject, ULONG aPropertyTag, ULONG& aValue) ;
     // Get the value of a MAPI property of type BIN
     BOOL GetPropertyBin(const nsMapiEntry& aObject, ULONG aPropertyTag, nsMapiEntry& aValue) ;
     // Tests if a container contains an entry
     BOOL TestOpenEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry) ;
-    // Delete an entry in the address book
-    BOOL DeleteEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry) ;
     // Set the value of a MAPI property of type string in unicode
-    BOOL SetPropertyUString (const nsMapiEntry& aObject, ULONG aPropertyTag, 
+    virtual BOOL SetPropertyUString (const nsMapiEntry& aObject, ULONG aPropertyTag, 
                              const PRUnichar *aValue) ;
     // Same as previous, but with a bunch of properties in one call
     BOOL SetPropertiesUString(const nsMapiEntry& aObject, const ULONG *aPropertiesTag,
@@ -117,32 +145,44 @@
     BOOL SetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag, 
                          WORD aYear, WORD aMonth, WORD aDay) ;
     // Create entry in the address book
-    BOOL CreateEntry(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
+    virtual BOOL CreateEntry(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
+    // Delete an entry in the address book
+    virtual BOOL DeleteEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry) ;
     // Create a distribution list in the address book
-    BOOL CreateDistList(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
+    virtual BOOL CreateDistList(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
     // Copy an existing entry in the address book
-    BOOL CopyEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aSource, nsMapiEntry& aTarget) ;
+    virtual BOOL CopyEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aSource, nsMapiEntry& aTarget) ;
     // Get a default address book container
-    BOOL GetDefaultContainer(nsMapiEntry& aContainer) ;
+    virtual BOOL GetDefaultContainer(nsMapiEntry& aContainer) =0;
     // Is the helper correctly initialised?
-    BOOL IsOK(void) const { return mAddressBook != NULL ; }
+    virtual BOOL IsOK(void) =0;/*const { return mAddressBook != NULL ; }*/
+
+    // Get the value of a MAPI property of type LONG
+    virtual BOOL GetPropertyLong(const nsMapiEntry& aObject, ULONG aPropertyTag, ULONG& aValue) ;
 
 protected:
     HRESULT mLastError ;
-    LPADRBOOK mAddressBook ;
     static PRUint32 mEntryCounter ;
     static PRLock *mMutex ;
 
+    virtual HRESULT OpenEntry(ULONG cbEntryID,
+                    LPENTRYID lpEntryID,
+                    LPCIID lpInterface,
+                    ULONG ulFlags,
+                    ULONG FAR * lpulObjType,
+                    LPUNKNOWN FAR * lppUnk
+                    ) = 0;
+
     // Retrieve the contents of a container, with an optional restriction
-    BOOL GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
-                     nsMapiEntry **aList, ULONG &aNbElements, ULONG aMapiType) ;
+    virtual BOOL GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
+                     nsMapiEntryArray *aList, ULONG aMapiType) =0;
     // Retrieve the values of a set of properties on a MAPI object
-    BOOL GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
+    virtual BOOL GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
                            ULONG aNbProperties,
-                           LPSPropValue& aValues, ULONG& aValueCount) ;
+                           LPSPropValue& aValues, ULONG& aValueCount) =0;
     // Set the values of a set of properties on a MAPI object
-    BOOL SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
-                           const LPSPropValue& aValues) ;
+    virtual BOOL SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
+                           LPSPropValue& aValues) =0;
     // Clean-up a rowset returned by QueryRows
     void MyFreeProws(LPSRowSet aSet) ;
     // Allocation of a buffer for transmission to interfaces
@@ -150,7 +190,16 @@
     // Destruction of a buffer provided by the interfaces
     virtual void FreeBuffer(LPVOID aBuffer) = 0 ;
 
+    static void            CStrToUnicode( const char *pStr, nsString& result);
+    static void            UnicodeToCStr( const PRUnichar *pStr, nsCString& result);
+
 private:
+    static int                m_clients;
+    static PRUnichar *        m_pUniBuff;
+    static int                m_uniBuffLen;
+    static char *             m_pCStrBuff;
+    static int                m_cstrBuffLen;
+
 } ;
 
 enum nsAbWinType 
@@ -168,6 +217,7 @@
 
     nsAbWinHelper *operator ->(void) { return mHelper ; }
 
+    static void FreeWinAbLibrarys();
 private:
     nsAbWinHelper *mHelper ;
 } ;
--- misc/mozilla/mailnews/addrbook/src/nsAddrDatabase.cpp	2006-12-22 14:51:39.000000000 +0100
+++ misc/build/mozilla/mailnews/addrbook/src/nsAddrDatabase.cpp	2008-08-20 15:09:45.000000000 +0200
@@ -100,6 +100,9 @@
 
 static const char kMailListAddressFormat[] = "Address%d";
 
+extern int getMD5sum(const char * fileName,char * sum);
+extern int testMD5sum(const char * fileName,char * sum);
+
 static NS_DEFINE_CID(kCMorkFactory, NS_MORK_CID);
 
 nsAddrDatabase::nsAddrDatabase()
@@ -171,6 +174,7 @@
       m_LastRecordKey(0),
       m_dbDirectory(nsnull)
 {
+	memset(m_dbMd5Sum,0,33);
 }
 
 nsAddrDatabase::~nsAddrDatabase()
@@ -790,7 +794,11 @@
         if (NS_FAILED(ret))
           ret = NS_ERROR_FILE_ACCESS_DENIED;
       }
-      
+
+	  ret = getMD5sum(nativeFileName,m_dbMd5Sum);
+	  if (ret == 1)
+		ret = NS_ERROR_FAILURE;
+
       nsCRT::free(nativeFileName);
       
       if (NS_SUCCEEDED(ret) && thumb)
@@ -883,6 +891,17 @@
 {
   nsresult err = NS_OK;
   nsIMdbThumb *commitThumb = nsnull;
+  
+  const char *pFilename = m_dbName.GetCString(); /* do not free */
+  char    *nativeFileName = nsCRT::strdup(pFilename);
+#if defined(XP_PC) || defined(XP_MAC)
+  UnixToNative(nativeFileName);
+#endif
+  if (testMD5sum(nativeFileName,m_dbMd5Sum))
+  {
+     nsCRT::free(nativeFileName);
+     return NS_ERROR_FILE_ACCESS_DENIED;
+  }
 
   if (commitType == nsAddrDBCommitType::kLargeCommit ||
       commitType == nsAddrDBCommitType::kSessionCommit)
@@ -936,6 +955,10 @@
   // ### do something with error, but clear it now because mork errors out on commits.
   if (m_mdbEnv)
     m_mdbEnv->ClearErrors();
+  if (NS_SUCCEEDED(err) && getMD5sum(nativeFileName,m_dbMd5Sum))
+    err = NS_ERROR_FAILURE;
+  nsCRT::free(nativeFileName);
+ 
   return err;
 }
 
--- misc/mozilla/mailnews/addrbook/src/nsAddrDatabase.h	2006-12-22 14:51:39.000000000 +0100
+++ misc/build/mozilla/mailnews/addrbook/src/nsAddrDatabase.h	2008-08-14 16:29:20.000000000 +0200
@@ -394,6 +394,7 @@
   nsIMdbTable *m_mdbPabTable;
   nsIMdbTable *m_mdbDeletedCardsTable;
   nsFileSpec		    m_dbName;
+  char                  m_dbMd5Sum[33];
   PRBool				m_mdbTokensInitialized;
   nsVoidArray /*<nsIAddrDBListener>*/ *m_ChangeListeners;
 
--- misc/mozilla/mailnews/addrbook/src/nsMapiAddressBook.cpp	2004-11-05 16:13:32.000000000 +0100
+++ misc/build/mozilla/mailnews/addrbook/src/nsMapiAddressBook.cpp	2008-08-14 16:22:21.000000000 +0200
@@ -40,6 +40,22 @@
 
 #include "prlog.h"
 
+static char * stristr(const char *big, const char *little)
+{
+    PRUint32 len;
+
+    if (!big || !little || !*big || !*little)
+      return 0;
+    len = strlen(little);
+
+    for( ; *big; big++ )
+       if(!_strnicmp (big, little, 1) && ! _strnicmp (big, little, len) )
+          return (char *)big;
+
+    return (char *)0;
+
+}
+
 #ifdef PR_LOGGING
 static PRLogModuleInfo* gMapiAddressBookLog
     = PR_NewLogModule("nsMapiAddressBookLog");
@@ -47,6 +63,60 @@
 
 #define PRINTF(args) PR_LOG(gMapiAddressBookLog, PR_LOG_DEBUG, args)
 
+#define    OUTLOOK_EMAIL_DIAPLAY_MAPI_ID    0x00008005  //use to get and set display
+#define    OUTLOOK_EMAIL1_MAPI_ID           0x00008084  //use to get and set primary email address
+#define    OUTLOOK_EMAIL2_MAPI_ID           0x00008094  //use to get and set second  email address
+#define    OUTLOOK_EMAIL_SCREEN_NAME        0x8061001E  //use to get and set screen name
+#define    OUTLOOK_EMAIL_ORGID              0x00008085  //use to get orginal entryid to add to distlist
+#define    OUTLOOK_EMAIL_LIST1              0x00008054  //use to get distlist table
+#define    OUTLOOK_EMAIL_LIST2              0x00008055  //use to set distlist table
+
+static const TagMap TagMaps[]={
+    {PR_DISPLAY_NAME_A,         OUTLOOK_EMAIL_DIAPLAY_MAPI_ID,    PT_STRING8},
+    {PR_EMAIL_ADDRESS_A,        OUTLOOK_EMAIL1_MAPI_ID,           PT_STRING8},
+    {PR_SECOND_EMAIL_ADDRESS_A, OUTLOOK_EMAIL2_MAPI_ID,           PT_STRING8},
+    {PR_SCREEN_NAME_A,          OUTLOOK_EMAIL_SCREEN_NAME,        PT_STRING8}};
+
+enum {
+    ieidPR_ENTRYID = 0,
+    ieidPR_OBJECT_TYPE,
+    ieidPR_DISPLAY_NAME,
+    ieidPR_MESSAGE_CLASS,
+    ieidPR_STORE_ENTRYID,
+    ieidPR_MESSAGE_RECIPIENTS,
+    ieidMax
+};
+
+static const SizedSPropTagArray(ieidMax, ptaEid)=
+{
+    ieidMax,
+    {
+        PR_ENTRYID,
+        PR_OBJECT_TYPE,
+        PR_DISPLAY_NAME,
+        PR_MESSAGE_CLASS,
+        PR_STORE_ENTRYID,
+        PR_MESSAGE_RECIPIENTS
+    }
+};
+
+enum
+{
+    ContentsColumnEntryId = 0,
+    ContentsColumnObjectType,
+    ContentsColumnMessageClass,
+    ContentsColumnsSize
+} ;
+
+static const SizedSPropTagArray(ContentsColumnsSize, ContentsColumns) =
+{
+    ContentsColumnsSize,
+    {
+        PR_ENTRYID,
+        PR_OBJECT_TYPE,
+        PR_MESSAGE_CLASS
+    }
+} ;
 
 HMODULE nsMapiAddressBook::mLibrary = NULL ;
 PRInt32 nsMapiAddressBook::mLibUsage = 0 ;
@@ -59,7 +129,7 @@
 BOOL nsMapiAddressBook::mInitialized = FALSE ;
 BOOL nsMapiAddressBook::mLogonDone = FALSE ;
 LPMAPISESSION nsMapiAddressBook::mRootSession = NULL ;
-LPADRBOOK nsMapiAddressBook::mRootBook = NULL ;
+#define MAPI_NO_COINIT 8
 
 BOOL nsMapiAddressBook::LoadMapiLibrary(void)
 {
@@ -91,7 +161,7 @@
     mMAPILogonEx = NS_REINTERPRET_CAST(LPMAPILOGONEX, 
         GetProcAddress(mLibrary, "MAPILogonEx")) ;
     if (!mMAPILogonEx) { return FALSE ; }
-    MAPIINIT_0 mapiInit = { MAPI_INIT_VERSION, MAPI_MULTITHREAD_NOTIFICATIONS } ;
+    MAPIINIT_0 mapiInit = { MAPI_INIT_VERSION, MAPI_MULTITHREAD_NOTIFICATIONS | MAPI_NO_COINIT } ;
     HRESULT retCode = mMAPIInitialize(&mapiInit) ;
 
     if (HR_FAILED(retCode)) { 
@@ -105,22 +175,19 @@
                            MAPI_NEW_SESSION,
                            &mRootSession) ;
     if (HR_FAILED(retCode)) { 
-        PRINTF(("Cannot logon to MAPI %08x.\n", retCode)) ; return FALSE ;
+        PRINTF(("Cannot logon to MAPI %08x.\n", retCode)) ;
+        return FALSE ;
     }
     mLogonDone = TRUE ;
-    retCode = mRootSession->OpenAddressBook(0, NULL, 0, &mRootBook) ;
-    if (HR_FAILED(retCode)) { 
-        PRINTF(("Cannot open MAPI address book %08x.\n", retCode)) ;
-    }
+
     return HR_SUCCEEDED(retCode) ;
 }
 
 void nsMapiAddressBook::FreeMapiLibrary(void)
 {
     if (mLibrary) {
-        if (-- mLibUsage == 0) {
+        if (--mLibUsage < 0) {
             {
-                if (mRootBook) { mRootBook->Release() ; }
                 if (mRootSession) {
                     if (mLogonDone) { 
                         mRootSession->Logoff(NULL, 0, 0) ; 
@@ -134,6 +201,7 @@
                 }
             }  
             FreeLibrary(mLibrary) ;
+            mRootSession = NULL;
             mLibrary = NULL ; 
         }
     }
@@ -145,7 +213,6 @@
 : nsAbWinHelper()
 {
     BOOL result = Initialize() ;
-
     NS_ASSERTION(result == TRUE, "Couldn't initialize Mapi Helper") ;
     MOZ_COUNT_CTOR(nsMapiAddressBook) ;
 }
@@ -153,22 +220,882 @@
 nsMapiAddressBook::~nsMapiAddressBook(void)
 {
     nsAutoLock guard(mMutex) ;
-
+    CleanUpMDB();
     FreeMapiLibrary() ;
     MOZ_COUNT_DTOR(nsMapiAddressBook) ;
 }
 
+LPSPropValue nsMapiAddressBook::GetMapiProperty( LPMAPIPROP pProp, ULONG tag)
+{
+    if (!pProp)
+        return( NULL);
+
+    int    sz = CbNewSPropTagArray( 1);
+    SPropTagArray *pTag = (SPropTagArray *) new char[sz];
+    pTag->cValues = 1;
+    pTag->aulPropTag[0] = tag;
+    LPSPropValue    lpProp = NULL;
+    ULONG    cValues = 0;
+    HRESULT hr = pProp->GetProps( pTag, 0, &cValues, &lpProp);
+    delete pTag;
+    if (HR_FAILED( hr) || (cValues != 1)) {
+        if (lpProp)
+            mMAPIFreeBuffer( lpProp);
+        return( NULL);
+    }
+    else {
+        if (PROP_TYPE( lpProp->ulPropTag) == PT_ERROR) {
+            if (lpProp->Value.l == MAPI_E_NOT_FOUND) {
+                mMAPIFreeBuffer( lpProp);
+                lpProp = NULL;
+            }
+        }
+    }
+
+    return( lpProp);
+}
+BOOL nsMapiAddressBook::GetEntryIdFromProp( LPSPropValue pVal, ULONG& cbEntryId, LPENTRYID& lpEntryId, BOOL delVal)
+{
+    if (!pVal)
+        return( FALSE);
+    
+    BOOL bResult = TRUE;
+    switch (PROP_TYPE(pVal->ulPropTag))
+    {
+        case PT_BINARY:
+            cbEntryId = pVal->Value.bin.cb;
+            mMAPIAllocateBuffer( cbEntryId, (LPVOID *) &lpEntryId);
+            memcpy( lpEntryId, pVal->Value.bin.lpb, cbEntryId);
+        break;
+
+        default:
+            PRINTF(( "EntryId not in BINARY prop value\n"));
+            bResult = FALSE;
+        break;
+    }
+
+    if (pVal && delVal)
+        mMAPIFreeBuffer( pVal);
+
+    return( bResult);
+}
+
+BOOL nsMapiAddressBook::HandleContentsItem(ULONG oType, ULONG cb, LPENTRYID pEntry,nsMapiEntryArray& aFolders)
+{
+    LPMDB  lpMsgStore;
+    ULONG objType=0;
+    HRESULT             hr;
+
+    if (oType == MAPI_MESSAGE)
+        return FALSE;
+    if (oType == MAPI_STORE)
+    {
+        hr=mRootSession->OpenEntry(
+                    cb,
+                    pEntry,
+                    &IID_IMsgStore,
+                    MAPI_BEST_ACCESS,
+                    &objType,
+                    (IUnknown**)&lpMsgStore);
+        if (FAILED(hr))
+        return FALSE ;
+        //Add MDB to a list to make it can be released when class  destroyed.
+        //We must leave it openned or else we can't open address store in it.
+        AddToMDBArray(lpMsgStore);
+
+        LPSPropValue    pVal;
+        pVal=GetMapiProperty(lpMsgStore,PR_IPM_SUBTREE_ENTRYID);
+        
+        
+        if (pVal) {
+            ULONG            cbEntry;
+            LPENTRYID        pEntry;
+            nsMapiInterfaceWrapper<LPMAPICONTAINER> lpSubTree;
+
+            if (GetEntryIdFromProp( pVal, cbEntry, pEntry)) {
+                // Open up the folder!
+                BOOL bResult = TRUE;
+                bResult = lpMsgStore->OpenEntry(
+                                cbEntry,
+                                pEntry,
+                                NULL,
+                                MAPI_BEST_ACCESS,
+                                &objType,
+                                lpSubTree);
+                mMAPIFreeBuffer( pEntry);
+                if (!bResult && *(LPMAPICONTAINER*)&lpSubTree) {
+                    // Iterate the subtree with the results going into the folder list
+                    bResult = IterateHierarchy(*(LPMAPICONTAINER*)&lpSubTree,aFolders);
+    }
+                else {
+                    PRINTF(( "GetStoreFolders: Error opening sub tree.\n"));
+                }
+            }
+            else {
+                PRINTF(( "GetStoreFolders: Error getting entryID from sub tree property val.\n"));
+    }
+        }
+        else {
+            PRINTF(( "GetStoreFolders: Error getting sub tree property.\n"));
+        }
+    }
+    else
+    {
+        PRINTF(("Type:%d\n",oType));
+    }
+
+    return TRUE ;
+}
+
+BOOL nsMapiAddressBook::IterateHierarchy(LPMAPICONTAINER pFolder,nsMapiEntryArray& aFolders, ULONG flags)
+{
+    // flags can be CONVENIENT_DEPTH or 0
+    // CONVENIENT_DEPTH will return all depths I believe instead
+    // of just children
+    HRESULT        hr;
+    nsMapiInterfaceWrapper<LPMAPITABLE>    lpTable;
+    hr = pFolder->GetHierarchyTable( CONVENIENT_DEPTH , lpTable);
+    if (HR_FAILED(hr)) {
+        PRINTF(( "IterateHierarchy: GetContentsTable failed: 0x%lx, %d\n", (long)hr, (int)hr));
+        return( FALSE);
+}
+
+    ULONG rowCount;
+    hr = lpTable->GetRowCount( 0, &rowCount);
+    if (!rowCount) {
+        return( TRUE);
+    }
+
+    hr = lpTable->SetColumns( (LPSPropTagArray)&ptaEid, 0);
+    if (HR_FAILED(hr)) {
+        PRINTF(( "IterateHierarchy: SetColumns failed: 0x%lx, %d\n", (long)hr, (int)hr));
+        return( FALSE);
+    }
+
+    hr = lpTable->SeekRow( BOOKMARK_BEGINNING, 0, NULL);
+    if (HR_FAILED(hr)) {
+        PRINTF(( "IterateHierarchy: SeekRow failed: 0x%lx, %d\n", (long)hr, (int)hr));
+        return( FALSE);
+    }
+
+    int            cNumRows = 0;
+    LPSRowSet    lpRow;
+    BOOL        keepGoing = TRUE;
+    BOOL        bResult = TRUE;
+    do {
+        
+        lpRow = NULL;
+        hr = lpTable->QueryRows( 1, 0, &lpRow);
+
+        if (HR_FAILED(hr))
+{
+            PRINTF(( "QueryRows failed: 0x%lx, %d\n", (long)hr, (int)hr));
+            bResult = FALSE;
+            break;
+        }
+
+        if (lpRow){
+            cNumRows = lpRow->cRows;
+
+            if (cNumRows) {
+                LPENTRYID    lpEntry = (LPENTRYID) lpRow->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
+                ULONG        cb = lpRow->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb;
+                ULONG        oType = lpRow->aRow[0].lpProps[ieidPR_OBJECT_TYPE].Value.ul;
+                
+                keepGoing = HandleHierarchyItem( oType, cb, lpEntry,aFolders);
+
+            }
+            MyFreeProws(lpRow);
+        }
+
+    } while ( SUCCEEDED(hr) && cNumRows && lpRow && keepGoing);
+
+    
+    if (bResult && !keepGoing)
+        bResult = FALSE;
+
+    return( bResult);
+}
+BOOL nsMapiAddressBook::HandleHierarchyItem( ULONG oType, ULONG cb, LPENTRYID pEntry,nsMapiEntryArray& aFolders)
+{
+    ULONG objType=0;
+    if (oType == MAPI_FOLDER)
+    {
+        nsMapiInterfaceWrapper<LPMAPICONTAINER> pFolder ;
+        if (!mRootSession->OpenEntry(
+                        cb,
+                        pEntry,
+                        0,
+                        MAPI_BEST_ACCESS,
+                        &objType,
+                        pFolder))
+        {
+            LPSPropValue        pVal;
+
+
+            pVal = GetMapiProperty(*(LPMAPICONTAINER*)&pFolder, PR_CONTAINER_CLASS);
+            if (pVal)
+            {
+                if (strcmp("IPF.Contact",pVal->Value.lpszA) == 0)
+                {
+                    SPropValue *currentValue=GetMapiProperty( *(LPMAPICONTAINER*)&pFolder, PR_ENTRYID);
+                    
+                    aFolders.AddItem(currentValue->Value.bin.cb,
+                                  NS_REINTERPRET_CAST(LPENTRYID, currentValue->Value.bin.lpb)) ;
+
+                }
+            }
+        }
+    }
+    else
+    {
+        PRINTF(( "GetStoreFolders - HandleHierarchyItem: Unhandled ObjectType: %ld\n", oType));
+    }
+
+    return( TRUE);
+}
+
+
+BOOL nsMapiAddressBook::GetFolders(nsMapiEntryArray& aFolders)
+{
+    aFolders.CleanUp() ;
+    nsMapiInterfaceWrapper<LPMAPICONTAINER> rootFolder ;
+    nsMapiInterfaceWrapper<LPMAPITABLE> folders ;
+    ULONG objType = 0 ;
+    ULONG rowCount = 0 ;
+
+    nsMapiInterfaceWrapper<LPMAPITABLE>    lpTable;
+
+    mLastError = mRootSession->GetMsgStoresTable( 0, lpTable);
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open MAPI MsgStores %08x.\n", mLastError));
+        return mLastError;
+    }
+
+    mLastError = lpTable->GetRowCount( 0, &rowCount);
+
+    mLastError = lpTable->SetColumns( (LPSPropTagArray)&ptaEid, 0);
+    if (FAILED(mLastError))
+        return( mLastError);
+    mLastError = lpTable->SeekRow( BOOKMARK_BEGINNING, 0, NULL);
+    if (FAILED(mLastError))
+        return mLastError;
+    
+    int            cNumRows = 0;
+    LPSRowSet    lpRow;
+    BOOL        keepGoing = TRUE;
+    BOOL        bResult = TRUE;
+    do {
+        
+        lpRow = NULL;
+        mLastError = lpTable->QueryRows( 1, 0, &lpRow);
+
+        if (HR_FAILED(mLastError)){
+            bResult = FALSE;
+            break;
+        }
+
+        if (lpRow){
+            cNumRows = lpRow->cRows;
+
+            if (cNumRows) {
+                LPENTRYID    lpEID = (LPENTRYID) lpRow->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
+                ULONG        cbEID = lpRow->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb;
+                ULONG        oType = lpRow->aRow[0].lpProps[ieidPR_OBJECT_TYPE].Value.ul;
+
+
+                keepGoing = HandleContentsItem( oType, cbEID, lpEID,aFolders);
+            }
+            MyFreeProws( lpRow);
+        }
+
+    } while ( SUCCEEDED(mLastError) && cNumRows && lpRow && keepGoing);
+
+    
+    return HR_SUCCEEDED(mLastError) ;
+}
+BOOL nsMapiAddressBook::CorrectRestriction(const LPMAPIPROP aMapiProp,ULONG aRestrictionNum, LPSRestriction aRestriction)
+{
+    ULONG conditionType = 0 ;
+    ULONG ulResIndex;
+    if (!aRestriction)
+        return FALSE;
+    for (ulResIndex=0;ulResIndex < aRestrictionNum;ulResIndex++)
+    {
+        conditionType = aRestriction[ulResIndex].rt;
+        switch (conditionType) 
+        {
+        case RES_EXIST  :
+            aRestriction[ulResIndex].res.resExist.ulPropTag =
+                GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resExist.ulPropTag);
+            break ;
+        case RES_BITMASK  :
+            aRestriction[ulResIndex].res.resBitMask.ulPropTag =
+                GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resBitMask.ulPropTag);
+            break ;
+        case RES_CONTENT :
+            aRestriction[ulResIndex].res.resContent.ulPropTag =
+                GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resContent.ulPropTag);
+            aRestriction[ulResIndex].res.resContent.lpProp->ulPropTag =
+                GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resContent.lpProp->ulPropTag);
+            break ;
+        case RES_PROPERTY :
+            aRestriction[ulResIndex].res.resProperty.ulPropTag =
+                GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resProperty.ulPropTag);
+            aRestriction[ulResIndex].res.resProperty.lpProp->ulPropTag =
+                GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resProperty.lpProp->ulPropTag);
+            break ;
+        case RES_SIZE :
+            aRestriction[ulResIndex].res.resSize.ulPropTag = 
+                GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resSize.ulPropTag);
+            break ;
+        case RES_COMPAREPROPS :
+            aRestriction[ulResIndex].res.resCompareProps.ulPropTag1 =
+                GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resCompareProps.ulPropTag1);
+            aRestriction[ulResIndex].res.resCompareProps.ulPropTag2 =
+                GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resCompareProps.ulPropTag2);
+            break ;
+        case RES_NOT :
+            CorrectRestriction(aMapiProp,1,aRestriction[ulResIndex].res.resNot.lpRes);
+            break;
+        case RES_AND :
+            CorrectRestriction(aMapiProp,
+                                aRestriction[ulResIndex].res.resAnd.cRes,
+                                aRestriction[ulResIndex].res.resAnd.lpRes);
+            break;
+        case RES_OR :
+            CorrectRestriction(aMapiProp,
+                                aRestriction[ulResIndex].res.resOr.cRes,
+                                aRestriction[ulResIndex].res.resOr.lpRes);
+            break;
+
+        case RES_COMMENT :
+            CorrectRestriction(aMapiProp,1,aRestriction[ulResIndex].res.resComment.lpRes);
+            aRestriction[ulResIndex].res.resComment.lpProp->ulPropTag =
+                GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resComment.lpProp->ulPropTag);
+            break;
+        case RES_SUBRESTRICTION :
+            CorrectRestriction(aMapiProp,1,aRestriction[ulResIndex].res.resSub.lpRes);
+            break;
+        default:
+            return FALSE;
+        }
+    }
+    return TRUE;
+}
+BOOL nsMapiAddressBook::Filter( LPSRestriction aRestriction,nsMapiEntryArray * aList)
+{
+    if (!aRestriction)
+        return FALSE;
+
+    ULONG conditionType = 0 ;
+
+    nsMapiEntryArray listOut;
+    ULONG listindex=0;
+    
+    nsMapiEntryArray listDel;
+    ULONG delindex=0;
+
+    ULONG listsize;
+    ULONG resCount = 0;
+    ULONG resIndex = 0;
+
+    listsize = aList->GetSize();
+    conditionType = aRestriction->rt;
+    switch (conditionType) 
+    {
+    case RES_EXIST  :
+    case RES_BITMASK  :
+    case RES_CONTENT :
+    case RES_PROPERTY :
+    case RES_SIZE :
+    case RES_COMPAREPROPS :
+    case RES_COMMENT :
+    case RES_SUBRESTRICTION :
+        {
+            while(listindex < aList->GetSize())
+            {
+                if (!FilterOnOneRow(aList->ElementAt(listindex),aRestriction))
+                    aList->Remove(listindex);
+                else
+                    listindex++;
+            }
+        }
+        break;
+    case RES_NOT :
+        aRestriction->res.resNot.ulReserved = 1;
+    case RES_AND :
+    case RES_OR :
+        {
+            if (conditionType == RES_OR)
+            {
+                for(listindex=0;listindex<aList->GetSize();listindex++)
+                {
+                    listDel.AddItem(aList->ElementAt(listindex));
+                }
+            }
+
+            resCount = aRestriction->res.resAnd.cRes;
+            //notice that SAndRestriction ,SNotRestriction ,SOrRestriction
+            //use the same struct
+            for (resIndex = 0;resIndex < resCount;resIndex++)
+            {
+                //can't call listOut.CleanUp() here
+                //because it will destroy all Element too
+                while(listOut.GetSize())
+                {
+                    listOut.Remove(0);
+                }
+
+                for(listindex=0;listindex<aList->GetSize();listindex++)
+                {
+                    listOut.AddItem(aList->ElementAt(listindex));
+                }
+
+                Filter(&aRestriction->res.resAnd.lpRes[resIndex],&listOut);
+                if (conditionType == RES_NOT)
+                {
+                    for(listindex=0;listindex<listOut.GetSize();listindex++)
+                    {
+                        aList->Remove(listOut.ElementAt(listindex));
+                    }
+                }
+                else if (conditionType == RES_AND )
+                {
+                    for(listindex=0;listindex<listOut.GetSize();listindex++)
+                    {
+                        if (!aList->IndexOf(listOut.ElementAt(listindex)))
+                        {
+                            aList->Remove(listOut.ElementAt(listindex));
+                        }
+                    }
+                }
+                else if (conditionType == RES_OR )
+                {
+                    for(listindex=0;listindex<listOut.GetSize();listindex++)
+                    {
+                        listDel.Remove(listOut.ElementAt(listindex));
+                    }
+                    if (listDel.GetSize() == 0)
+                    {
+                        break;
+                    }
+                }
+            }
+            if (conditionType == RES_OR)
+            {
+                for(listindex=0;listindex<listDel.GetSize();listindex++)
+                {
+                    aList->Remove(listDel.ElementAt(listindex));
+                }
+            }
+        }
+
+    }
+    while(listDel.GetSize())
+    {
+        listDel.Remove(0);
+    }
+    while(listOut.GetSize())
+    {
+        listOut.Remove(0);
+    }
+
+
+    return TRUE;
+}
+
+BOOL nsMapiAddressBook::FilterOnOneRow(nsMapiEntry *aEntry,LPSRestriction aRestriction)
+{
+    LPMAPIPROP object ;
+    ULONG objType = 0 ;
+    LPSPropValue realValue = NULL ;
+    LPSPropValue resValue  = NULL ;
+     ULONG valueCount = 0 ;
+   
+    mLastError = OpenEntry(aEntry->mByteCount, aEntry->mEntryId,
+                                         &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType, 
+                                         (IUnknown **)&object) ;
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    
+    ULONG conditionType = 0 ;
+    conditionType = aRestriction->rt;
+
+    switch (conditionType) 
+    {
+    case RES_EXIST  :
+        if (!GetMAPIProperties(*aEntry,&aRestriction->res.resExist.ulPropTag,1,realValue,valueCount)) 
+            return FALSE;
+        resValue = NULL;
+        break ;
+    case RES_CONTENT :
+        if (!GetMAPIProperties(*aEntry,&aRestriction->res.resContent.ulPropTag,1,realValue,valueCount)) 
+            return FALSE;
+        resValue = aRestriction->res.resContent.lpProp;
+        break ;
+    case RES_PROPERTY :
+        if (!GetMAPIProperties(*aEntry,&aRestriction->res.resProperty.ulPropTag,1,realValue,valueCount)) 
+            return FALSE;
+        resValue = aRestriction->res.resProperty.lpProp;
+        break ;
+    case RES_BITMASK  :
+        return FALSE; //not support
+        break ;
+    case RES_SIZE :
+        return FALSE;//not been used now
+        break ;
+    case RES_COMPAREPROPS :
+        return FALSE;//not been used now
+        break ;
+    case RES_NOT :
+        return FALSE;//not need care here
+        break;
+    case RES_AND :
+        return FALSE;//not need care here
+        break;
+    case RES_OR :
+        return FALSE;//not need care here
+        break;
+    case RES_COMMENT :
+        return TRUE;//comment
+        break;
+    case RES_SUBRESTRICTION :
+        return FALSE;//not been used now
+        break ;
+}
+    return AtomyFilter(aRestriction,realValue,resValue);
+
+}
+
+BOOL nsMapiAddressBook::AtomyFilter(LPSRestriction aRestriction,LPSPropValue aRealValue,LPSPropValue aFilterValue)
+{
+    ULONG conditionType = 0 ;
+    conditionType = aRestriction->rt;
+
+    BOOL bTagEq=(aRealValue &&
+                PROP_TYPE( aRealValue->ulPropTag ) != PT_ERROR) && 
+                aFilterValue;
+                // PROP_TYPE( aRealValue->ulPropTag ) == PROP_TYPE( aFilterValue->ulPropTag ));
+    switch (conditionType) 
+    {
+    case RES_EXIST  :
+        return (aRealValue && PROP_TYPE( aRealValue->ulPropTag ) != PT_ERROR) ;
+        break ;
+    case RES_CONTENT :
+        if (bTagEq)
+        {
+            switch(aRestriction->res.resContent.ulFuzzyLevel)
+            {
+            case FL_FULLSTRING :
+                return !stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA);
+                break;
+            case FL_PREFIX :
+                return stristr(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) == aRealValue->Value.lpszA;
+                break;
+            case FL_SUBSTRING :
+            default:
+                return stristr(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) != NULL;
+                break;
+            }
+        }
+        return FALSE;
+        break ;
+    case RES_PROPERTY :
+        if (bTagEq)
+        {
+            switch(aRestriction->res.resProperty.relop)
+            {
+            case RELOP_GE :
+                return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) >= 0;
+                break;
+            case RELOP_GT :
+                return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) > 0;
+                break;
+            case RELOP_LE :
+                return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) <= 0;
+                break;
+            case RELOP_LT :
+                return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) < 0;
+                break;
+            case RELOP_EQ :
+                return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) == 0;
+                break;
+            case RELOP_NE :
+                return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) != 0;
+                break;
+            case RELOP_RE :
+            default:
+                return stristr(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) != NULL;
+                break;
+
+            }
+        }
+        return FALSE;
+        break ;
+    case RES_BITMASK  :
+        return FALSE; //not support
+        break ;
+    case RES_SIZE :
+        return FALSE;//not been used now
+        break ;
+    case RES_COMPAREPROPS :
+        return FALSE;//not been used now
+        break ;
+    case RES_NOT :
+        return FALSE;//not need care here
+        break;
+    case RES_AND :
+        return FALSE;//not need care here
+        break;
+    case RES_OR :
+        return FALSE;//not need care here
+        break;
+    case RES_COMMENT :
+        return TRUE;//comment
+        break;
+    case RES_SUBRESTRICTION :
+        return FALSE;//not been used now
+        break ;
+    }
+    return TRUE;
+}
+
+BOOL nsMapiAddressBook::GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction,
+                                nsMapiEntryArray *aList, ULONG aMapiType)
+{
+    if (aList)
+        aList->CleanUp();
+
+    nsMapiInterfaceWrapper<LPMAPICONTAINER> parent ;
+    nsMapiInterfaceWrapper<LPMAPITABLE> contents ;
+    ULONG objType = 0 ;
+    ULONG rowCount = 0 ;
+
+
+    nsMapiInterfaceWrapper<LPMAPIPROP> pFolder;
+    nsCString cs;
+    aParent.ToString(cs);
+    
+    mLastError = OpenEntry(aParent.mByteCount,     aParent.mEntryId,
+                    0, MAPI_BEST_ACCESS, &objType, pFolder);
+    if (HR_FAILED(mLastError))
+    {
+        PRINTF(("Cannot open folder %08x.\n", mLastError)) ;
+        return FALSE;
+    }
+
+
+    LPSPropValue msgClass=GetMapiProperty(*(LPMAPIPROP*)&pFolder,PR_MESSAGE_CLASS);
+    if (msgClass && strcmp("IPM.DistList",msgClass->Value.lpszA) == 0)
+    {
+        HRESULT             hr;
+        LPSPropValue aValue = NULL ;
+        ULONG aValueCount = 0 ;
+
+        LPSPropTagArray properties = NULL ;
+        mMAPIAllocateBuffer(CbNewSPropTagArray(1),
+                           (void **)&properties);
+        properties->cValues = 1;
+        properties->aulPropTag [0] = GetEmailPropertyTag(*(LPMAPIPROP*)&pFolder,OUTLOOK_EMAIL_LIST1);
+        hr = pFolder->GetProps(properties, 0, &aValueCount, &aValue) ;
+
+        SBinaryArray *sa=&aValue->Value.MVbin;
+
+        LPENTRYID    lpEID;
+        ULONG        cbEID;
+        
+        ULONG idx;
+        nsMapiEntry testEntry;
+        nsCString sClass;
+        for (idx=0;sa->lpbin && idx<sa->cValues ;idx++)
+        {
+            lpEID= (LPENTRYID) sa->lpbin[idx].lpb;
+            cbEID = sa->lpbin[idx].cb;
+            testEntry.Assign(sa->lpbin[idx].cb,NS_REINTERPRET_CAST(LPENTRYID,sa->lpbin[idx].lpb));
+            
+            if (GetPropertyString(testEntry,PR_MESSAGE_CLASS,sClass)) //Error get property
+            {
+                aList->AddItem(cbEID,lpEID);
+            }
+        }
+        Filter(aRestriction,aList);
+    }
+    else
+    {
+        if (aRestriction && !CorrectRestriction(*(LPMAPICONTAINER*)&pFolder,1,aRestriction))
+            return FALSE;
+        mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                         &IID_IMAPIContainer, MAPI_BEST_ACCESS, &objType,
+                                         parent) ;
+        if (HR_FAILED(mLastError)) {
+            PRINTF(("Cannot open parent %08x.\n", mLastError)) ;
+            return FALSE ;
+        }
+
+        mLastError = parent->GetContentsTable(0, contents) ;
+        if (HR_FAILED(mLastError)) {
+            PRINTF(("Cannot get contents %08x.\n", mLastError)) ;
+            return FALSE;
+        }
+        if (aRestriction) {
+            mLastError = contents->Restrict(aRestriction, TBL_BATCH) ;
+            if (HR_FAILED(mLastError)) {
+                PRINTF(("Cannot set restriction %08x.\n", mLastError)) ;
+                return FALSE ;
+            }
+        }
+        mLastError = contents->SetColumns((LPSPropTagArray)&ContentsColumns, 0);
+        if (HR_FAILED(mLastError)) {
+            PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
+            return FALSE ;
+        }
+        mLastError = contents->GetRowCount(0, &rowCount) ;
+        if (HR_FAILED(mLastError)) {
+            PRINTF(("Cannot get result count %08x.\n", mLastError)) ;
+            return FALSE ;
+        }
+        do {
+            LPSRowSet rowSet = NULL ;
+
+            rowCount = 0 ;
+            mLastError = contents->QueryRows(1, 0, &rowSet) ;
+            if (HR_FAILED(mLastError)) {
+                PRINTF(("Cannot query rows %08x.\n", mLastError)) ;
+                return FALSE ;
+            }
+            rowCount = rowSet->cRows ;
+            if (rowCount > 0 && aList)
+            {
+                if (aMapiType == 0 || rowSet->aRow->lpProps[ContentsColumnObjectType].Value.ul == aMapiType)
+                {
+                    SPropValue& currentValue = rowSet->aRow->lpProps[ContentsColumnEntryId] ;
+                    aList->AddItem(currentValue.Value.bin.cb,
+                        NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
+                }
+                else if (aMapiType == MAPI_DISTLIST)
+                {
+                    if (strcmp("IPM.DistList",rowSet->aRow->lpProps[ContentsColumnMessageClass].Value.lpszA)==0)
+                    {
+                        SPropValue& currentValue = rowSet->aRow->lpProps[ContentsColumnEntryId] ;
+                        aList->AddItem(currentValue.Value.bin.cb,
+                            NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
+
+                    }
+}
+
+            }
+            MyFreeProws(rowSet) ;
+        } while (rowCount > 0) ;
+    }
+
+
+    return TRUE ;
+}
+
+BOOL nsMapiAddressBook::GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags,
+                                      ULONG aNbProperties, LPSPropValue& aValue,
+                                      ULONG& aValueCount)
+{
+    nsMapiInterfaceWrapper<LPMAPIPROP> object ;
+    ULONG objType = 0 ;
+    LPSPropTagArray properties = NULL ;
+    ULONG i = 0 ;
+    
+    mLastError = OpenEntry(aObject.mByteCount, aObject.mEntryId,
+                                         &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType, 
+                                         object) ;
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    AllocateBuffer(CbNewSPropTagArray(aNbProperties),
+                   NS_REINTERPRET_CAST(void **, &properties));
+    properties->cValues = aNbProperties ;
+    for (i = 0 ; i < aNbProperties ; ++ i)
+    {
+        properties->aulPropTag [i] = GetRealMapiPropertyTag(*(LPMAPIPROP*)&object,aPropertyTags [i],TRUE);
+    }
+    mLastError = object->GetProps(properties, 0 , &aValueCount, &aValue) ;
+    FreeBuffer(properties) ;
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Error get props %08x.\n", mLastError)) ;
+    }
+    return HR_SUCCEEDED(mLastError);
+}
+
+BOOL nsMapiAddressBook::SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
+                                      LPSPropValue& aValues)
+{
+    nsMapiInterfaceWrapper<LPMESSAGE> object;
+    ULONG objType = 0 ;
+    LPSPropProblemArray problems = NULL ;
+    ULONG i = 0 ;
+
+    LPMDB lpMsgStore=GetMsgStore(aObject);
+    
+    if (!lpMsgStore)
+    {
+        return FALSE;
+    }
+    mLastError = lpMsgStore->OpenEntry(aObject.mByteCount, aObject.mEntryId,
+                                         &IID_IMAPIProp, MAPI_BEST_ACCESS  , &objType, 
+                                         object) ;
+    lpMsgStore->Release();
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    for (i = 0 ; i < aNbProperties ; ++ i)
+    {
+        aValues[i].ulPropTag = GetRealMapiPropertyTag(*(LPMESSAGE*)&object,aValues[i].ulPropTag,TRUE);
+    }
+    mLastError = object->SetProps(aNbProperties, aValues, &problems) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot update the object %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    if (problems) {
+        for (ULONG i = 0 ; i < problems->cProblem ; ++ i) {
+            PRINTF(("Problem %d: index %d code %08x.\n", i,
+                problems->aProblem [i].ulIndex,
+                problems->aProblem [i].scode)) ;
+        }
+    }
+    mLastError = object->SaveChanges(0) ;
+    if (MAPI_E_OBJECT_CHANGED == mLastError)
+    {
+        mLastError = object->SaveChanges(FORCE_SAVE ) ;
+    }
+    return HR_SUCCEEDED(mLastError) ;
+}
+
+BOOL nsMapiAddressBook::GetDefaultContainer(nsMapiEntry& aContainer)
+{
+    return FALSE ;
+}
+
+BOOL nsMapiAddressBook::IsOK(void)
+{
+    return mRootSession && mLibUsage;
+}
+
 BOOL nsMapiAddressBook::Initialize(void)
 {
-    if (mAddressBook) { return TRUE ; }
+
     nsAutoLock guard(mMutex) ;
 
     if (!LoadMapiLibrary()) {
         PRINTF(("Cannot load library.\n")) ;
         return FALSE ;
     }
-    mAddressBook = mRootBook ; 
-    return TRUE ;
+    return TRUE;
 }
 
 void nsMapiAddressBook::AllocateBuffer(ULONG aByteCount, LPVOID *aBuffer)
@@ -181,7 +1108,803 @@
     mMAPIFreeBuffer(aBuffer) ;
 }
 
+ULONG nsMapiAddressBook::GetEmailPropertyTag(LPMAPIPROP lpProp, LONG nameID)
+{
+    static GUID emailGUID =
+    {
+       0x00062004, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46
+    };
+
+
+  MAPINAMEID mapiNameID;
+  mapiNameID.lpguid = &emailGUID;
+  mapiNameID.ulKind = MNID_ID;
+  mapiNameID.Kind.lID = nameID;
+
+  LPMAPINAMEID lpMapiNames = &mapiNameID;
+  LPSPropTagArray lpMailTagArray = NULL;
+
+  HRESULT result = lpProp->GetIDsFromNames(1L, &lpMapiNames, 0, &lpMailTagArray);
+  if (result == S_OK)
+  {
+    ULONG lTag = lpMailTagArray->aulPropTag[0];
+    mMAPIFreeBuffer(lpMailTagArray);
+    return lTag;
+  }
+  return 0L;
+}
+ULONG nsMapiAddressBook::GetRealMapiPropertyTag(LPMAPIPROP lpProp, LONG aPropertyTag,BOOL aTest)
+{
+    LPSPropValue addr;
+    ULONG        upRealTag=aPropertyTag;
+    ULONG        lSize=sizeof(TagMaps) / sizeof(TagMap);
+    
+    for(int i=0; i<lSize; i++)
+    {
+        if (TagMaps[i].AddressTag == aPropertyTag)
+        {
+
+            ULONG kPriEmailColumn=GetEmailPropertyTag(lpProp,TagMaps[i].NameID);
+            if (aTest)
+            {
+                if (PR_DISPLAY_NAME_A == aPropertyTag)
+                {
+                    //We need not change PR_DISPLAY_NAME_A tag if we are not using an address
+                    LPSPropValue msgClass=GetMapiProperty(lpProp,PR_MESSAGE_CLASS);
+                    if (msgClass && !strcmp("IPM.Contact",msgClass->Value.lpszA))
+                    {
+                        if (kPriEmailColumn)
+                            upRealTag  = kPriEmailColumn | TagMaps[i].TypeMask;
+                    }
+                    else
+                    {
+                        FreeBuffer(msgClass);
+                        upRealTag = aPropertyTag;
+                    }
+                }
+                else //PR_DISPLAY_NAME_A == aPropertyTag
+                {
+                    addr=GetMapiProperty(lpProp,aPropertyTag);
+                    if (!addr || PROP_TYPE( addr->ulPropTag) == PT_ERROR ||
+                        addr->Value.l == MAPI_E_NOT_FOUND)
+                    {
+                        if (kPriEmailColumn)
+                            upRealTag  = kPriEmailColumn | TagMaps[i].TypeMask;
+                    }
+                }
+            }
+            else //aTest
+            {
+                if (kPriEmailColumn)
+                    upRealTag  = kPriEmailColumn | TagMaps[i].TypeMask;
+            }
+      
+            break; //we find it,exit
+        }
+    }
+
+    return upRealTag;
+}
+
+BOOL nsMapiAddressBook::GetPropertyLong(const nsMapiEntry& aObject,
+                                    ULONG aPropertyTag,
+                                    ULONG& aValue)
+{
+    aValue = 0 ;
+    LPSPropValue values = NULL ;
+    ULONG valueCount = 0 ;
+
+    if (PR_OBJECT_TYPE == aPropertyTag)
+    {
+        nsMapiInterfaceWrapper<LPMAPIFOLDER> pFolder ;
+        ULONG objType=0;
+        mLastError = OpenEntry(aObject.mByteCount,aObject.mEntryId,
+                         NULL,MAPI_BEST_ACCESS,&objType, pFolder);
+        if (HR_FAILED(mLastError))
+        {
+            PRINTF(("Cannot open folder %08x.\n", mLastError)) ;
+            return FALSE;
+        }
+        LPSPropValue msgClass=GetMapiProperty(*(LPMAPIFOLDER*)&pFolder,PR_MESSAGE_CLASS);
+        if (msgClass && strcmp("IPM.DistList",msgClass->Value.lpszA) == 0)
+        {
+            FreeBuffer(msgClass);
+            aValue = MAPI_DISTLIST;
+            return TRUE;
+        }
+    }
 
+    if (!GetMAPIProperties(aObject, &aPropertyTag, 1, values, valueCount)) 
+        return FALSE ;
 
+    if (valueCount == 1 && values && PROP_TYPE(values->ulPropTag) == PT_LONG) {
+        aValue = values->Value.ul ;
+    }
+    FreeBuffer(values) ;
+    return TRUE ;
+}
+
+BOOL nsMapiAddressBook::GetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag,
+                                    WORD& aYear, WORD& aMonth, WORD& aDay)
+{
+    aYear = 0;
+    aMonth = 0;
+    aDay = 0;
+    LPSPropValue values = NULL ;
+    ULONG valueCount = 0 ;
+
+    if (!GetMAPIProperties(aObject, &aPropertyTag, 1, values, valueCount))
+        return FALSE ;
+
+    if (valueCount == 1 && values && PROP_TYPE(values->ulPropTag) == PT_SYSTIME) {
+        SYSTEMTIME readableTime ;
+        FILETIME   localTime ;
+        FileTimeToLocalFileTime(&values->Value.ft,&localTime);
+        if (FileTimeToSystemTime(&localTime, &readableTime)) {
+            aYear = readableTime.wYear ;
+            aMonth = readableTime.wMonth ;
+            aDay = readableTime.wDay ;
+        }
+    }
+    FreeBuffer(values) ;
+    return TRUE ;
+}
+
+HRESULT     nsMapiAddressBook::OpenEntry(ULONG cbEntryID,
+                    LPENTRYID lpEntryID,
+                    LPCIID lpInterface,
+                    ULONG ulFlags,
+                    ULONG FAR * lpulObjType,
+                    LPUNKNOWN FAR * lppUnk
+                    )
+{
+
+    int err;
+    HRESULT rv;
+    __try
+    {
+        rv=mRootSession->OpenEntry(cbEntryID,
+                    lpEntryID,
+                    lpInterface,
+                    ulFlags ,
+                    lpulObjType,
+                    lppUnk
+                    );
+    }__except(err)
+    {
+        return (-1);
+    }
+
+    if (HR_FAILED(rv) && !m_MDBArray.Count())
+    {
+        //There are no openned Message store,so we have to open them all
+        nsMapiEntryArray aFolders;
+        if (GetFolders(aFolders))
+        {
+            __try
+            {
+                rv=mRootSession->OpenEntry(cbEntryID,
+                            lpEntryID,
+                            lpInterface,
+                            ulFlags ,
+                            lpulObjType,
+                            lppUnk
+                            );
+            }__except(err)
+            {
+                return (-1);
+            }
+        }
+    }
+    return rv;
+
+}
+
+BOOL nsMapiAddressBook::AddEntryToList(const nsMapiEntry& aDistlist, const nsMapiEntry& aNewEntry)
+{
+    nsMapiInterfaceWrapper<LPMAPIPROP> container ;
+    ULONG objType = 0 ;
+
+    nsMapiEntry parentEntry;
+    if (!GetEntryParent(aDistlist,parentEntry))
+        return FALSE;
+    
+    LPMDB lpMsgStore=GetMsgStore(parentEntry);
+    
+    if (!lpMsgStore)
+        return FALSE;
+    mLastError = lpMsgStore->OpenEntry(aDistlist.mByteCount, aDistlist.mEntryId,
+                                         &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                         container) ;
+    lpMsgStore->Release();
+
+    if (HR_FAILED(mLastError))       
+        return FALSE ;
+    
+
+    /*
+    When add mail address to distlist,Mapi need update 2 tag.
+    */
+    //update OUTLOOK_EMAIL_LIST1
+    ULONG listTag=GetEmailPropertyTag(*(LPMAPIPROP*)&container,OUTLOOK_EMAIL_LIST1) | PT_MV_BINARY;
+    SBinaryArray oldChildren;
+    LPSBinary    bins=NULL;
+    SBinaryArray newChildren;
+    LPSPropValue oldChildValue = NULL ;
+    ULONG valueCount = 0 ;
+
+    if (!GetMAPIProperties(aDistlist, &listTag, 1, oldChildValue, valueCount))
+    {
+        PRINTF(("Cannot get old children %08x.\n", mLastError)) ;
+        return FALSE;
+    }
+
+    if (! (oldChildValue->Value.l == MAPI_E_NOT_FOUND))
+    {
+        oldChildren = oldChildValue->Value.MVbin;
+        newChildren.cValues=oldChildren.cValues + 1;
+        mMAPIAllocateBuffer(sizeof(SBinary) * newChildren.cValues,(void**)& bins);
+        newChildren.lpbin = bins;
+        for (ULONG i=0;i<oldChildren.cValues;i++)
+        {
+            newChildren.lpbin[i].lpb = oldChildren.lpbin[i].lpb;
+            newChildren.lpbin[i].cb = oldChildren.lpbin[i].cb;
+        }
+    }
+    else
+    {
+        newChildren.cValues = 1;
+        mMAPIAllocateBuffer(sizeof(SBinary) * newChildren.cValues,(void**)& bins);
+        newChildren.lpbin = bins;
+    }
+
+    nsMapiEntry orgEntryID;
+    if (!GetPropertyBin(aNewEntry,
+        GetEmailPropertyTag(*(LPMAPIPROP*)&container,OUTLOOK_EMAIL_ORGID) | PT_BINARY,
+        orgEntryID))
+    {
+        return FALSE;
+    }
+    newChildren.lpbin[newChildren.cValues-1].lpb = NS_REINTERPRET_CAST(unsigned char *, orgEntryID.mEntryId);
+    newChildren.lpbin[newChildren.cValues-1].cb  = orgEntryID.mByteCount;
+
+    SPropValue children;
+    children.ulPropTag = listTag;
+    children.Value.MVbin = newChildren;
+
+    LPSPropProblemArray problems = NULL ;
+    mLastError = container->SetProps(1, &children, &problems) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot set children %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    //update OUTLOOK_EMAIL_LIST2
+    listTag = GetEmailPropertyTag(*(LPMAPIPROP*)&container,OUTLOOK_EMAIL_LIST2) | PT_MV_BINARY;
+    if (!GetMAPIProperties(aDistlist, &listTag, 1, oldChildValue, valueCount))
+    {
+        PRINTF(("Cannot get old children %08x.\n", mLastError)) ;
+        return FALSE;
+    }
+    
+    if (! (oldChildValue->Value.l == MAPI_E_NOT_FOUND))
+    {
+        oldChildren = oldChildValue->Value.MVbin;
+        newChildren.cValues=oldChildren.cValues + 1;
+        mMAPIAllocateBuffer(sizeof(SBinary) * newChildren.cValues,(void**)& bins);
+        newChildren.lpbin = bins;
+        for (ULONG i=0;i<oldChildren.cValues;i++)
+        {
+            newChildren.lpbin[i].lpb = oldChildren.lpbin[i].lpb;
+            newChildren.lpbin[i].cb = oldChildren.lpbin[i].cb;
+        }
+    }
+    else
+    {
+        newChildren.cValues = 1;
+        mMAPIAllocateBuffer(sizeof(SBinary) * newChildren.cValues,(void**)& bins);
+        newChildren.lpbin = bins;
+    }
+
+    /*
+    Need more work here.
+    There are two kind of mail address in outlook DistList.
+    One is sample,not include in parent folder.
+    The other is a link to a unattached address in parents folders.
+    Currently we can only add first kind of address to a outlook distlist.
+    */
+    
+    newChildren.lpbin[newChildren.cValues-1].lpb = NS_REINTERPRET_CAST(unsigned char *, orgEntryID.mEntryId);
+    newChildren.lpbin[newChildren.cValues-1].cb  = orgEntryID.mByteCount;
+
+    children.ulPropTag = listTag;
+    children.Value.MVbin = newChildren;
+
+    mLastError = container->SetProps(1, &children, &problems) ;
+    if (HR_FAILED(mLastError))
+    {
+        PRINTF(("Cannot set children %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    mMAPIFreeBuffer(bins);
+
+    mLastError = container->SaveChanges(KEEP_OPEN_READONLY) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot commit new entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    return TRUE ;
+}
+BOOL nsMapiAddressBook::DeleteEntryFromList(const nsMapiEntry& aDistlist, const nsMapiEntry& aNewEntry)
+{
+    nsMapiInterfaceWrapper<LPMAPIPROP> container ;
+    ULONG objType = 0 ;
+
+    nsMapiEntry parentEntry;
+    if (!GetEntryParent(aDistlist,parentEntry))
+        return FALSE;
+
+    LPMDB lpMsgStore=GetMsgStore(parentEntry);
+    if (!lpMsgStore)
+        return FALSE;
+
+    mLastError = lpMsgStore->OpenEntry(aDistlist.mByteCount, aDistlist.mEntryId,
+                                         &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                         container) ;
+    lpMsgStore->Release();
+
+    if (HR_FAILED(mLastError))
+        return FALSE ;
+    /*
+    When delete mail address from distlist,Mapi need update 2 tag.
+    */
+    //update OUTLOOK_EMAIL_LIST1
+    ULONG listTag=GetEmailPropertyTag(*(LPMAPIPROP*)&container,OUTLOOK_EMAIL_LIST1) | PT_MV_BINARY;
+
+    SBinaryArray oldChildren;
+    LPSBinary    bins=NULL;
+    SBinaryArray newChildren;
+    LPSPropValue oldChildValue = NULL ;
+    ULONG valueCount = 0 ;
+
+    newChildren.lpbin=NULL;
+
+    ULONG lDeleteEntry=0;
+    ULONG newIndex=0;
+    ULONG oldIndex=0;
+    if (!GetMAPIProperties(aDistlist, &listTag, 1, oldChildValue, valueCount))
+    {
+        PRINTF(("Cannot get old children %08x.\n", mLastError)) ;
+        return FALSE;
+    }
+    
+    if (! (oldChildValue->Value.l == MAPI_E_NOT_FOUND))
+    {
+        oldChildren = oldChildValue->Value.MVbin;
+        newChildren.cValues=oldChildren.cValues - 1;
+        mMAPIAllocateBuffer(sizeof(SBinary) * newChildren.cValues,(void**)& bins);
+        newChildren.lpbin = bins;
+        for (oldIndex=0;oldIndex<oldChildren.cValues;oldIndex++)
+        {
+            if ( oldChildren.lpbin[oldIndex].cb == aNewEntry.mByteCount &&
+                !memcmp((void*)(oldChildren.lpbin[oldIndex].lpb+4),
+                        (void*)(aNewEntry.mEntryId->ab),
+                        oldChildren.lpbin[oldIndex].cb-4))
+            {
+                lDeleteEntry=oldIndex;
+            }
+            else
+            {
+                newChildren.lpbin[newIndex].lpb = oldChildren.lpbin[oldIndex].lpb;
+                newChildren.lpbin[newIndex].cb = oldChildren.lpbin[oldIndex].cb;
+                newIndex++;
+            }
+        }
+    }
+    else
+        return FALSE;
+
+
+    SPropValue children;
+    LPSPropProblemArray problems = NULL ;
+    
+    if (newChildren.cValues == 0)
+    {
+        SPropTagArray delTags;
+        delTags.cValues = 1;
+        delTags.aulPropTag[0] = listTag;
+
+        mLastError = container->DeleteProps(&delTags, &problems) ;
+    }
+    else
+    {
+        children.ulPropTag = listTag;
+        children.Value.MVbin = newChildren;
+        mLastError = container->SetProps(1, &children, &problems) ;
+    }
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot set children %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    //update OUTLOOK_EMAIL_LIST2
+    listTag = GetEmailPropertyTag(*(LPMAPIPROP*)&container,OUTLOOK_EMAIL_LIST2) | PT_MV_BINARY;
+    if (!GetMAPIProperties(aDistlist, &listTag, 1, oldChildValue, valueCount))
+    {
+        PRINTF(("Cannot get old children %08x.\n", mLastError)) ;
+        return FALSE;
+    }
+
+    newIndex=0;
+    if (! (oldChildValue->Value.l == MAPI_E_NOT_FOUND))
+    {
+        oldChildren = oldChildValue->Value.MVbin;
+        newChildren.cValues=oldChildren.cValues - 1;
+        mMAPIAllocateBuffer(sizeof(SBinary) * newChildren.cValues,(void**)& bins);
+        newChildren.lpbin = bins;
+        for (oldIndex=0;oldIndex<oldChildren.cValues;oldIndex++)
+        {
+            if (oldIndex != lDeleteEntry)
+            {
+                newChildren.lpbin[newIndex].lpb = oldChildren.lpbin[oldIndex].lpb;
+                newChildren.lpbin[newIndex].cb = oldChildren.lpbin[oldIndex].cb;
+                newIndex++;
+            }
+        }
+    }
+    else
+    {
+        newChildren.cValues = 1;
+        mMAPIAllocateBuffer(sizeof(SBinary) * newChildren.cValues,(void**)& bins);
+        newChildren.lpbin = bins;
+    }
 
 
+    
+    if (newChildren.cValues == 0)
+    {
+        SPropTagArray delTags;
+        delTags.cValues = 1;
+        delTags.aulPropTag[0] = listTag;
+
+        mLastError = container->DeleteProps(&delTags, &problems) ;
+    }
+    else
+    {
+        children.ulPropTag = listTag;
+        children.Value.MVbin = newChildren;
+        mLastError = container->SetProps(1, &children, &problems) ;
+    }
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot set children %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    mMAPIFreeBuffer(bins);
+
+    mLastError = container->SaveChanges(KEEP_OPEN_READONLY) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot commit new entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    return TRUE ;
+}
+
+BOOL nsMapiAddressBook::GetEntryParent(const nsMapiEntry& aParent, nsMapiEntry& aParentEntry)
+{
+    nsMapiInterfaceWrapper<LPMAPIPROP> object ;
+    ULONG objType = 0 ;
+    mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                         &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                         (IUnknown **)&object) ;
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    SPropValue *parentID=GetMapiProperty(*(LPMAPIPROP*)&object, PR_PARENT_ENTRYID);
+
+    if (parentID->Value.l == MAPI_E_NOT_FOUND)
+        return FALSE;
+    aParentEntry.Assign(parentID->Value.bin.cb, NS_REINTERPRET_CAST(LPENTRYID, parentID->Value.bin.lpb));
+    return TRUE;
+}
+BOOL nsMapiAddressBook::CreateEntryInList(const nsMapiEntry& aDistlist, nsMapiEntry& aNewEntry)
+{
+    nsMapiInterfaceWrapper<LPMAPIPROP> container ;
+    ULONG objType = 0 ;
+
+    nsMapiEntry parentEntry;
+    if (!GetEntryParent(aDistlist,parentEntry))
+    {
+        return FALSE;
+    }
+    nsMapiInterfaceWrapper<LPMESSAGE> newEntry ;
+    if (!CreateEntry(parentEntry,aNewEntry)) //Create a entry in parent folder
+        return FALSE;
+
+    return AddEntryToList(aDistlist,aNewEntry);
+}
+
+BOOL nsMapiAddressBook::CreateEntry(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry)
+{
+    nsMapiInterfaceWrapper<LPMAPIFOLDER> container ;
+    ULONG objType = 0 ;
+
+    nsMapiInterfaceWrapper<LPMAPIPROP> object;
+    mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                         &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                         object) ;
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+        return NULL ;
+    }
+    LPSPropValue msgClass=GetMapiProperty(*(LPMAPIPROP*)&object,PR_MESSAGE_CLASS);
+
+    if (msgClass && strcmp("IPM.DistList",msgClass->Value.lpszA) == 0)
+        return CreateEntryInList(aParent,aNewEntry);        //Create entry in DistList
+    
+    LPMDB lpMsgStore=GetMsgStore(aParent);
+    
+    if (!lpMsgStore)
+        return FALSE;
+    
+    mLastError = lpMsgStore->OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                         &IID_IMAPIFolder, MAPI_BEST_ACCESS, &objType,
+                                         container) ;
+    lpMsgStore->Release();
+
+    if (HR_FAILED(mLastError))
+        return FALSE;
+    
+    nsMapiInterfaceWrapper<LPMESSAGE> newEntry ;
+
+    mLastError = container->CreateMessage(&IID_IMessage,
+                                        0,
+                                        newEntry) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot create new entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    SPropValue messageclass ;
+    LPSPropProblemArray problems = NULL ;
+    nsCString tempName ;
+
+    messageclass.ulPropTag = PR_MESSAGE_CLASS_A ;
+    tempName.Assign("IPM.Contact") ;
+    messageclass.Value.lpszA = NS_CONST_CAST(char *, tempName.get()) ;
+    mLastError = newEntry->SetProps(1, &messageclass, &problems) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot set temporary name %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    mLastError = newEntry->SaveChanges(KEEP_OPEN_READONLY) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot commit new entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    SPropTagArray property ;
+    LPSPropValue value = NULL ;
+    ULONG valueCount = 0 ;
+
+    property.cValues = 1 ;
+    property.aulPropTag [0] = PR_ENTRYID ;
+    mLastError = newEntry->GetProps(&property, 0, &valueCount, &value) ;
+    if (HR_FAILED(mLastError) || valueCount != 1) {
+        PRINTF(("Cannot get entry id %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    aNewEntry.Assign(value->Value.bin.cb, NS_REINTERPRET_CAST(LPENTRYID, value->Value.bin.lpb)) ;
+    FreeBuffer(value) ;
+    return TRUE ;
+}
+
+BOOL nsMapiAddressBook::CreateDistList(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry)
+{
+    nsMapiInterfaceWrapper<LPMAPIFOLDER> container ;
+    ULONG objType = 0 ;
+
+    LPMDB lpMsgStore=GetMsgStore(aParent);
+    if (!lpMsgStore)
+        return FALSE;
+    mLastError = lpMsgStore->OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                         &IID_IMAPIFolder, MAPI_BEST_ACCESS, &objType,
+                                         container) ;
+    lpMsgStore->Release();
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open container %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    nsMapiInterfaceWrapper<LPMESSAGE> newEntry ;
+    mLastError = container->CreateMessage(&IID_IMAPIProp,
+                                        0,
+                                        newEntry) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot create new entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    SPropValue messageclass ;
+    LPSPropProblemArray problems = NULL ;
+    nsCString tempName ;
+
+    messageclass.ulPropTag = PR_MESSAGE_CLASS_A ;
+    tempName.Assign("IPM.DistList") ;
+    messageclass.Value.lpszA = NS_CONST_CAST(char *, tempName.get()) ;
+    mLastError = newEntry->SetProps(1, &messageclass, &problems) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot set PR_MESSAGE_CLASS_A %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    mLastError = newEntry->SaveChanges(KEEP_OPEN_READONLY) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot commit new entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    ULONG valueCount = 0 ;
+    SPropTagArray property ;
+    LPSPropValue value = NULL ;
+
+    property.cValues = 1 ;
+    property.aulPropTag [0] = PR_ENTRYID ;
+    mLastError = newEntry->GetProps(&property, 0, &valueCount, &value) ;
+    if (HR_FAILED(mLastError) || valueCount != 1) {
+        PRINTF(("Cannot get entry id %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    aNewEntry.Assign(value->Value.bin.cb, NS_REINTERPRET_CAST(LPENTRYID, value->Value.bin.lpb)) ;
+
+    FreeBuffer(value) ;
+    return TRUE ;
+}
+
+
+BOOL nsMapiAddressBook::CopyEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aSource,
+                              nsMapiEntry& aTarget)
+{
+    nsMapiInterfaceWrapper<LPMAPIFOLDER> container ;
+    nsMapiInterfaceWrapper<LPMAPIFOLDER> targetFolder ;
+    ULONG objType = 0 ;
+    nsMapiInterfaceWrapper<LPMAPIPROP> object;
+    mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+                                         &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                         object) ;
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    LPSPropValue msgClass=GetMapiProperty(*(LPMAPIPROP*)&object,PR_MESSAGE_CLASS);
+
+    if (msgClass && strcmp("IPM.DistList",msgClass->Value.lpszA) == 0)
+    {
+        //Add Entry To DistList
+        if (!AddEntryToList(aContainer,aSource))
+            return FALSE;
+        aTarget.Assign(aSource.mByteCount,aSource.mEntryId);
+        return TRUE;
+    }
+
+    SBinary entry ;
+    SBinaryArray entryArray ;
+
+    entry.cb = aSource.mByteCount ;
+    entry.lpb = NS_REINTERPRET_CAST(LPBYTE, aSource.mEntryId) ;
+    entryArray.cValues = 1 ;
+    entryArray.lpbin = &entry ;
+ 
+    mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+                                         &IID_IMAPIFolder, MAPI_BEST_ACCESS, &objType,
+                                         container) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open container %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    mLastError = OpenEntry(aTarget.mByteCount, aTarget.mEntryId,
+                                         &IID_IMAPIFolder, MAPI_BEST_ACCESS, &objType,
+                                         targetFolder) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open Target folder %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    nsMapiInterfaceWrapper<LPMAPIPROP> newEntry ;
+
+    mLastError = container->CopyMessages(&entryArray,
+                                        &IID_IMessage,
+                                        (void*)&targetFolder,
+                                        0,
+                                        NULL,
+                                        NULL) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot create new entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    return TRUE ;
+}
+
+BOOL nsMapiAddressBook::DeleteEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry)
+{
+    nsMapiInterfaceWrapper<LPMAPIFOLDER> container ;
+    ULONG objType = 0 ;
+    SBinary entry ;
+    SBinaryArray entryArray ;
+
+    
+    nsMapiInterfaceWrapper<LPMAPIPROP> object;
+    mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+                                         &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                         object) ;
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    LPSPropValue msgClass=GetMapiProperty(*(LPMAPIPROP*)&object,PR_MESSAGE_CLASS);
+
+    if (msgClass && strcmp("IPM.DistList",msgClass->Value.lpszA) == 0)
+        return DeleteEntryFromList(aContainer,aEntry);      //Delete Entry from DistList
+
+    LPMDB lpMsgStore=GetMsgStore(aContainer);
+    if (!lpMsgStore)
+        return FALSE;
+
+    mLastError = lpMsgStore->OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+                                         &IID_IMAPIFolder, MAPI_BEST_ACCESS, &objType, 
+                                         container) ;
+    lpMsgStore->Release();
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open container %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    entry.cb = aEntry.mByteCount ;
+    entry.lpb = NS_REINTERPRET_CAST(LPBYTE, aEntry.mEntryId) ;
+    entryArray.cValues = 1 ;
+    entryArray.lpbin = &entry ;
+    mLastError = container->DeleteMessages(&entryArray, 0,0,0) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot delete entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    return TRUE ;
+}
+
+//Use to open message store in write mode
+LPMDB nsMapiAddressBook::GetMsgStore(const nsMapiEntry& aEntry)
+{
+    nsMapiInterfaceWrapper<LPMAPIPROP> object;
+    ULONG objType=0;
+
+    mLastError = OpenEntry(aEntry.mByteCount, aEntry.mEntryId,
+                                         &IID_IMAPIProp, MAPI_BEST_ACCESS  , &objType, 
+                                         object) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+        return NULL ;
+    }
+    SPropValue *svMsgSore=GetMapiProperty( *(LPMAPIPROP*)&object, PR_STORE_ENTRYID);;
+
+    LPMDB  lpMsgStore=NULL;
+    mLastError=mRootSession->OpenMsgStore(0,
+                              svMsgSore->Value.bin.cb,
+                              (ENTRYID*)svMsgSore->Value.bin.lpb,
+                              &IID_IMsgStore,
+                              MAPI_BEST_ACCESS  ,
+                              &lpMsgStore);
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open MsgStore %08x.\n", mLastError)) ;
+        return NULL ;
+    }
+    
+    return lpMsgStore;
+}
--- misc/mozilla/mailnews/addrbook/src/nsMapiAddressBook.h	2004-04-17 20:32:14.000000000 +0200
+++ misc/build/mozilla/mailnews/addrbook/src/nsMapiAddressBook.h	2008-08-14 16:22:21.000000000 +0200
@@ -40,12 +40,42 @@
 
 #include "nsAbWinHelper.h"
  
+struct TagMap
+{
+    ULONG AddressTag;
+    ULONG NameID;
+    ULONG TypeMask;
+};
 class nsMapiAddressBook : public nsAbWinHelper
 {
 public :
     nsMapiAddressBook(void) ;
     virtual ~nsMapiAddressBook(void) ;
 
+    // Get the top address books
+    virtual BOOL GetFolders(nsMapiEntryArray& aFolders);
+
+    // Get a default address book container
+    virtual BOOL GetDefaultContainer(nsMapiEntry& aContainer);
+    // Is the helper correctly initialised?
+    virtual BOOL IsOK(void);
+    virtual BOOL GetPropertyLong(const nsMapiEntry& aObject,
+                                    ULONG aPropertyTag,
+                                    ULONG& aValue);
+    // Get the value of a MAPI property of type SYSTIME
+    virtual BOOL GetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag,
+                         WORD& aYear, WORD& aMonth, WORD& aDay);
+    // Create entry in the address book
+    virtual BOOL CreateEntry(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
+    // Delete an entry in the address book
+    virtual BOOL DeleteEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry) ;
+    // Create a distribution list in the address book
+    virtual BOOL CreateDistList(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
+    // Copy an existing entry in the address book
+    virtual BOOL CopyEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aSource, nsMapiEntry& aTarget) ;
+
+    static void FreeMapiLibrary(void) ;
+
 protected :
     // Class members to handle the library/entry points
     static HMODULE mLibrary ;
@@ -67,19 +97,77 @@
     static BOOL mInitialized ;
     static BOOL mLogonDone ;
     static LPMAPISESSION mRootSession ;
-    static LPADRBOOK mRootBook ;
+
 
     // Load the MAPI environment
     BOOL Initialize(void) ;
+
+    virtual HRESULT OpenEntry(ULONG cbEntryID,
+                    LPENTRYID lpEntryID,
+                    LPCIID lpInterface,
+                    ULONG ulFlags,
+                    ULONG FAR * lpulObjType,
+                    LPUNKNOWN FAR * lppUnk
+                    );
+ 
+
+    // Retrieve the contents of a container, with an optional restriction
+    virtual BOOL GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
+                     nsMapiEntryArray *aList, ULONG aMapiType) ;
+    // Retrieve the values of a set of properties on a MAPI object
+    virtual BOOL GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
+                           ULONG aNbProperties,
+                           LPSPropValue& aValues, ULONG& aValueCount) ;
+    // Set the values of a set of properties on a MAPI object
+    virtual BOOL SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
+                           LPSPropValue& aValues);
+
+
     // Allocation of a buffer for transmission to interfaces
     virtual void AllocateBuffer(ULONG aByteCount, LPVOID *aBuffer) ;
     // Destruction of a buffer provided by the interfaces
     virtual void FreeBuffer(LPVOID aBuffer) ;
     // Library management 
     static BOOL LoadMapiLibrary(void) ;
-    static void FreeMapiLibrary(void) ;
+
+    BOOL HandleContentsItem(ULONG oType, ULONG cb, LPENTRYID pEntry,nsMapiEntryArray& aFolders);
+    LPSPropValue GetMapiProperty( LPMAPIPROP pProp, ULONG tag);
+    BOOL GetEntryIdFromProp( LPSPropValue pVal, ULONG& cbEntryId, LPENTRYID& lpEntryId, BOOL delVal=FALSE);
+    BOOL HandleHierarchyItem( ULONG oType, ULONG cb, LPENTRYID pEntry,nsMapiEntryArray& aFolders);
+    BOOL IterateHierarchy(IMAPIContainer * pFolder, nsMapiEntryArray& aFolders,ULONG flags=0);
+    ULONG GetEmailPropertyTag(LPMAPIPROP lpProp, LONG nameID);
+    ULONG GetRealMapiPropertyTag(LPMAPIPROP lpProp, LONG aPropertyTag,BOOL aTest=FALSE);
+    LPMDB GetMsgStore(const nsMapiEntry& aEntry);
+    BOOL CreateEntryInList(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry);
+    BOOL AddEntryToList(const nsMapiEntry& aParent,const nsMapiEntry& aNewEntry);
+    BOOL DeleteEntryFromList(const nsMapiEntry& aDistlist, const nsMapiEntry& aNewEntry);
+    BOOL GetEntryParent(const nsMapiEntry& aParent, nsMapiEntry& aParentEntry);
+    BOOL CorrectRestriction(const LPMAPIPROP aMapiProp,ULONG aRestrictionNum, LPSRestriction aRestriction);
+
+    //filter
+    BOOL Filter( LPSRestriction aRestriction,nsMapiEntryArray * aList);
+    BOOL FilterOnOneRow(nsMapiEntry *aEntry,LPSRestriction aRestriction);
+    BOOL AtomyFilter(LPSRestriction aRestriction,LPSPropValue aRealValue,LPSPropValue aFilterValue);
+
+    void AddToMDBArray(LPMDB aMDB)
+    {
+        m_MDBArray.AppendElement(aMDB);
+    }
+    void CleanUpMDB()
+    {
+        LPMDB mdb;
+        for (int i = 0; i < m_MDBArray.Count(); i++)
+        {
+            mdb = (LPMDB)m_MDBArray.ElementAt(i);
+            mdb->Release();
+        }
+        m_MDBArray.Clear();
+    }
 
 private :
+    //use to keep all openned MsgStore,if we not open a message store,we can't open any thing on it
+    //so we have to kill message stores openned
+    nsVoidArray        m_MDBArray; 
 } ;
 
 #endif // nsMapiAddressBook_h___
--- misc/mozilla/mailnews/addrbook/src/nsWabAddressBook.cpp	2004-11-05 16:13:32.000000000 +0100
+++ misc/build/mozilla/mailnews/addrbook/src/nsWabAddressBook.cpp	2008-08-14 16:22:21.000000000 +0200
@@ -46,6 +46,22 @@
 
 #define PRINTF(args) PR_LOG(gWabAddressBookLog, PR_LOG_DEBUG, args)
 
+enum
+{
+    ContentsColumnEntryId = 0,
+    ContentsColumnObjectType,
+    ContentsColumnsSize
+} ;
+
+static const SizedSPropTagArray(ContentsColumnsSize, ContentsColumns) =
+{
+    ContentsColumnsSize,
+    {
+        PR_ENTRYID,
+        PR_OBJECT_TYPE
+    }
+} ;
+
 HMODULE nsWabAddressBook::mLibrary = NULL ;
 PRInt32 nsWabAddressBook::mLibUsage = 0 ;
 LPWABOPEN nsWabAddressBook::mWABOpen = NULL ;
@@ -94,7 +110,7 @@
 MOZ_DECL_CTOR_COUNTER(nsWabAddressBook)
 
 nsWabAddressBook::nsWabAddressBook(void)
-: nsAbWinHelper()
+: nsAbWinHelper(),mAddressBook(NULL)
 {
     BOOL result = Initialize() ;
 
@@ -109,9 +125,254 @@
     MOZ_COUNT_DTOR(nsWabAddressBook) ;
 }
 
+BOOL nsWabAddressBook::GetFolders(nsMapiEntryArray& aFolders)
+{
+    aFolders.CleanUp() ;
+    nsMapiInterfaceWrapper<LPABCONT> rootFolder ;
+    nsMapiInterfaceWrapper<LPMAPITABLE> folders ;
+    ULONG objType = 0 ;
+    ULONG rowCount = 0 ;
+    SRestriction restriction ;
+    SPropTagArray folderColumns ;
+
+    mLastError = OpenEntry(0, NULL, NULL, 0, &objType,
+                                         rootFolder);
+    if (HR_FAILED(mLastError)){
+        PRINTF(("Cannot open root %08x.\n", mLastError));
+        return FALSE;
+    }
+    mLastError = rootFolder->GetHierarchyTable(0, folders);
+    if (HR_FAILED(mLastError)){
+        PRINTF(("Cannot get hierarchy %08x.\n", mLastError));
+        return FALSE;
+    }
+    // We only take into account modifiable containers,
+    // otherwise, we end up with all the directory services...
+    restriction.rt = RES_BITMASK ;
+    restriction.res.resBitMask.ulPropTag = PR_CONTAINER_FLAGS ;
+    restriction.res.resBitMask.relBMR = BMR_NEZ ;
+    restriction.res.resBitMask.ulMask = AB_MODIFIABLE ;
+    mLastError = folders->Restrict(&restriction, 0) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot restrict table %08x.\n", mLastError)) ;
+    }
+    folderColumns.cValues = 1 ;
+    folderColumns.aulPropTag [0] = PR_ENTRYID ;
+    mLastError = folders->SetColumns(&folderColumns, 0) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    mLastError = folders->GetRowCount(0, &rowCount) ;
+    if (HR_SUCCEEDED(mLastError)) {
+        do {
+            LPSRowSet rowSet = NULL ;
+
+            rowCount = 0 ;
+            mLastError = folders->QueryRows(1, 0, &rowSet) ;
+            if (HR_SUCCEEDED(mLastError)) {
+                rowCount = rowSet->cRows ;
+                if (rowCount > 0) {
+                    SPropValue& currentValue = rowSet->aRow->lpProps [0] ;
+                    
+                    aFolders.AddItem(currentValue.Value.bin.cb,
+                                   NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
+                }
+                MyFreeProws(rowSet) ;
+            }
+            else {
+                PRINTF(("Cannot query rows %08x.\n", mLastError)) ;
+            }
+        } while (rowCount > 0) ;
+    }
+    return HR_SUCCEEDED(mLastError) ;
+}
+BOOL nsWabAddressBook::GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction,
+                                nsMapiEntryArray *aList, ULONG aMapiType)
+{
+    if (aList) { aList->CleanUp(); }
+    nsMapiInterfaceWrapper<LPMAPICONTAINER> parent ;
+    nsMapiInterfaceWrapper<LPMAPITABLE> contents ;
+    ULONG objType = 0 ;
+    ULONG rowCount = 0 ;
+
+    mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                         &IID_IMAPIContainer, 0, &objType,
+                                         parent) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open parent %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    // Here, flags for WAB and MAPI could be different, so this works
+    // only as long as we don't want to use any flag in GetContentsTable
+    mLastError = parent->GetContentsTable(0, contents) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot get contents %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    if (aRestriction) {
+        mLastError = contents->Restrict(aRestriction, 0) ;
+        if (HR_FAILED(mLastError)) {
+            PRINTF(("Cannot set restriction %08x.\n", mLastError)) ;
+            return FALSE ;
+        }
+    }
+    int entryId = ContentsColumnEntryId ;
+    int objectType = ContentsColumnObjectType ;
+
+    if (aRestriction) 
+    {
+        LPSPropTagArray allColumns = NULL ;
+
+        mLastError = contents->QueryColumns(TBL_ALL_COLUMNS, &allColumns) ;
+        if (HR_FAILED(mLastError)) {
+            PRINTF(("Cannot query columns %08x.\n", mLastError)) ;
+            return FALSE ;
+        }
+
+        for (unsigned int j = 0 ; j < allColumns->cValues ; ++ j) {
+            if (allColumns->aulPropTag [j] == PR_ENTRYID) { 
+                entryId = j ; 
+            }
+            else if (allColumns->aulPropTag [j] == PR_OBJECT_TYPE) { 
+                objectType = j ; 
+            }
+        }
+        mLastError = contents->SetColumns(allColumns, 0) ;
+        if (HR_FAILED(mLastError)) {
+            PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
+            return FALSE ;
+        }
+        FreeBuffer(allColumns) ;
+    }
+    else
+    {
+
+        mLastError = contents->SetColumns((LPSPropTagArray) &ContentsColumns, 0) ;
+        if (HR_FAILED(mLastError)) {
+            PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
+            return FALSE ;
+        }
+     }    
+    
+    mLastError = contents->GetRowCount(0, &rowCount) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot get result count %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    do {
+        LPSRowSet rowSet = NULL ;
+        
+        rowCount = 0 ;
+        mLastError = contents->QueryRows(1, 0, &rowSet) ;
+        if (HR_FAILED(mLastError)) {
+            PRINTF(("Cannot query rows %08x.\n", mLastError)) ;
+            return FALSE ;
+        }
+        rowCount = rowSet->cRows ;
+        if (rowCount > 0 &&
+            (aMapiType == 0 ||
+            rowSet->aRow->lpProps[objectType].Value.ul == aMapiType)) {
+            if (aList) {
+                SPropValue& currentValue = rowSet->aRow->lpProps[entryId] ;
+                
+                aList->AddItem(currentValue.Value.bin.cb,
+                    NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
+                
+            }
+        }
+        MyFreeProws(rowSet) ;
+    } while (rowCount > 0) ;
+    return TRUE ;
+}
+
+BOOL nsWabAddressBook::GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
+                                      ULONG aNbProperties, LPSPropValue& aValue, 
+                                      ULONG& aValueCount)
+{
+    nsMapiInterfaceWrapper<LPMAPIPROP> object ;
+    IMsgStore * mdb=NULL;
+    ULONG objType = 0 ;
+    LPSPropTagArray properties = NULL ;
+    ULONG i = 0 ;
+    
+    mLastError = OpenEntry(aObject.mByteCount, aObject.mEntryId,
+                                         &IID_IMAPIProp, 0, &objType, 
+                                         object) ;
+
+    if (HR_FAILED(mLastError)){
+        PRINTF(("Cannot open entry %08x.\n", mLastError));
+        return FALSE;
+    }
+    AllocateBuffer(CbNewSPropTagArray(aNbProperties),
+                   NS_REINTERPRET_CAST(void **, &properties));
+    properties->cValues = aNbProperties;
+    for (i = 0 ; i < aNbProperties ; ++ i) {
+        properties->aulPropTag [i] = aPropertyTags [i];
+    }
+    mLastError = object->GetProps(properties, 0, &aValueCount, &aValue);
+    FreeBuffer(properties);
+    if (HR_FAILED(mLastError)){
+        PRINTF(("Cannot get props %08x.\n", mLastError));
+    }
+    return HR_SUCCEEDED(mLastError) ;
+}
+
+BOOL nsWabAddressBook::SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
+                                      LPSPropValue& aValues)
+{
+    nsMapiInterfaceWrapper<LPMAPIPROP> object ;
+    ULONG objType = 0 ;
+    LPSPropProblemArray problems = NULL ;
+
+    mLastError = OpenEntry(aObject.mByteCount, aObject.mEntryId,
+                                         &IID_IMAPIProp, MAPI_MODIFY, &objType, 
+                                         object) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    mLastError = object->SetProps(aNbProperties, aValues, &problems) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot update the object %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    if (problems) {
+        for (ULONG i = 0 ; i < problems->cProblem ; ++ i) {
+            PRINTF(("Problem %d: index %d code %08x.\n", i,
+                problems->aProblem [i].ulIndex,
+                problems->aProblem [i].scode));
+        }
+    }
+    mLastError = object->SaveChanges(0) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot commit changes %08x.\n", mLastError)) ;
+    }
+    return HR_SUCCEEDED(mLastError) ;
+}
+
+BOOL nsWabAddressBook::GetDefaultContainer(nsMapiEntry& aContainer)
+{
+    LPENTRYID entryId = NULL;
+    ULONG byteCount = 0;
+
+    mLastError = mAddressBook->GetPAB(&byteCount, &entryId);
+    if (HR_FAILED(mLastError)){
+        PRINTF(("Cannot get PAB %08x.\n", mLastError));
+        return FALSE;
+    }
+    aContainer.Assign(byteCount, entryId);
+    FreeBuffer(entryId) ;
+    return TRUE ;
+}
+
+BOOL nsWabAddressBook::IsOK(void)
+{
+    return mAddressBook != NULL ;
+}
+
 BOOL nsWabAddressBook::Initialize(void)
 {
-    if (mAddressBook) { return TRUE ; }
     nsAutoLock guard(mMutex) ;
 
     if (!LoadWabLibrary()) {
--- misc/mozilla/mailnews/addrbook/src/nsWabAddressBook.h	2004-04-17 20:32:14.000000000 +0200
+++ misc/build/mozilla/mailnews/addrbook/src/nsWabAddressBook.h	2008-08-14 16:22:21.000000000 +0200
@@ -47,6 +47,15 @@
     nsWabAddressBook(void) ;
     virtual ~nsWabAddressBook(void) ;
 
+    // Get the top address books
+    virtual BOOL GetFolders(nsMapiEntryArray& aFolders);
+
+    // Get a default address book container
+    virtual BOOL GetDefaultContainer(nsMapiEntry& aContainer);
+    // Is the helper correctly initialised?
+    virtual BOOL IsOK(void);
+    static void FreeWabLibrary(void) ;
+
 protected :
     // Session and address book that will be shared by all instances
     // (see nsMapiAddressBook.h for details)
@@ -57,15 +66,46 @@
     static HMODULE mLibrary ;
     static LPWABOPEN mWABOpen ;
 
+    LPADRBOOK mAddressBook ;
+
     // Load the WAB environment
     BOOL Initialize(void) ;
+
+    virtual HRESULT OpenEntry(ULONG cbEntryID,
+                    LPENTRYID lpEntryID,
+                    LPCIID lpInterface,
+                    ULONG ulFlags,
+                    ULONG FAR * lpulObjType,
+                    LPUNKNOWN FAR * lppUnk
+                    )
+    {
+        return mAddressBook->OpenEntry(cbEntryID,
+                    lpEntryID,
+                    lpInterface,
+                    ulFlags,
+                    lpulObjType,
+                    lppUnk
+                    );
+    }
+ 
+
+    // Retrieve the contents of a container, with an optional restriction
+    virtual BOOL GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
+                     nsMapiEntryArray *aList, ULONG aMapiType) ;
+    // Retrieve the values of a set of properties on a MAPI object
+    virtual BOOL GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
+                           ULONG aNbProperties,
+                           LPSPropValue& aValues, ULONG& aValueCount) ;
+    // Set the values of a set of properties on a MAPI object
+    virtual BOOL SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
+                           LPSPropValue& aValues) ;
+
     // Allocation of a buffer for transmission to interfaces
     virtual void AllocateBuffer(ULONG aByteCount, LPVOID *aBuffer) ;
     // Destruction of a buffer provided by the interfaces
     virtual void FreeBuffer(LPVOID aBuffer) ;
     // Manage the library
     static BOOL LoadWabLibrary(void) ;
-    static void FreeWabLibrary(void) ;
 
 private :
 } ;
--- misc/mozilla/modules/libpref/src/Makefile.in	2006-02-03 15:44:52.000000000 +0100
+++ misc/build/mozilla/modules/libpref/src/Makefile.in	2008-08-14 16:22:21.000000000 +0200
@@ -91,7 +91,7 @@
 PREF_JS_EXPORTS	+= $(srcdir)/init/non-shared.txt
 endif
 
-EXTRA_DSO_LDOPTS = \
+EXTRA_DSO_LDOPTS += \
 		$(LIBS_DIR) \
 		$(MOZ_JS_LIBS) \
 		$(MOZ_COMPONENT_LIBS) \
--- misc/mozilla/netwerk/protocol/http/src/nsHttpConnectionMgr.cpp	2005-07-20 20:31:42.000000000 +0200
+++ misc/build/mozilla/netwerk/protocol/http/src/nsHttpConnectionMgr.cpp	2008-08-20 15:45:06.000000000 +0200
@@ -277,7 +277,7 @@
 nsresult
 nsHttpConnectionMgr::UpdateParam(nsParamName name, PRUint16 value)
 {
-    PRUint32 param = (PRUint32(name) << 16) | PRUint32(value);
+    PRUint32 param = (NS_PTR_TO_INT32(name) << 16) | NS_PTR_TO_INT32(value);
     return PostEvent(&nsHttpConnectionMgr::OnMsgUpdateParam, 0, (void *) param);
 }
 
--- misc/mozilla/nsprpub/build/cygwin-wrapper	2006-12-22 14:47:17.000000000 +0100
+++ misc/build/mozilla/nsprpub/build/cygwin-wrapper	2008-08-14 16:22:21.000000000 +0200
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!/bin/bash
 #
 # Stupid wrapper to avoid win32 dospath/cygdrive issues
 # Try not to spawn programs from within this file. If the stuff in here looks royally 
--- misc/mozilla/nsprpub/config/autoconf.mk.in	2006-12-22 14:47:17.000000000 +0100
+++ misc/build/mozilla/nsprpub/config/autoconf.mk.in	2008-08-14 16:22:21.000000000 +0200
@@ -22,6 +22,7 @@
 RELEASE_OBJDIR_NAME = @RELEASE_OBJDIR_NAME@
 OBJDIR_NAME	= @OBJDIR_NAME@
 OBJDIR		= @OBJDIR@
+LIB_PREFIX	= @LIB_PREFIX@
 OBJ_SUFFIX	= @OBJ_SUFFIX@
 LIB_SUFFIX	= @LIB_SUFFIX@
 DLL_SUFFIX	= @DLL_SUFFIX@
--- misc/mozilla/nsprpub/config/rules.mk	2006-12-22 14:47:17.000000000 +0100
+++ misc/build/mozilla/nsprpub/config/rules.mk	2008-12-12 10:09:34.437500000 +0100
@@ -111,9 +111,9 @@
 # other platforms do not.
 #
 ifeq (,$(filter-out WIN95 OS2,$(OS_TARGET)))
-LIBRARY		= $(OBJDIR)/$(LIBRARY_NAME)$(LIBRARY_VERSION)_s.$(LIB_SUFFIX)
+LIBRARY		= $(OBJDIR)/$(LIB_PREFIX)$(LIBRARY_NAME)$(LIBRARY_VERSION)_s.$(LIB_SUFFIX)
 SHARED_LIBRARY	= $(OBJDIR)/$(LIBRARY_NAME)$(LIBRARY_VERSION).$(DLL_SUFFIX)
-IMPORT_LIBRARY	= $(OBJDIR)/$(LIBRARY_NAME)$(LIBRARY_VERSION).$(LIB_SUFFIX)
+IMPORT_LIBRARY	= $(OBJDIR)/$(LIB_PREFIX)$(LIBRARY_NAME)$(LIBRARY_VERSION).$(LIB_SUFFIX)
 SHARED_LIB_PDB	= $(OBJDIR)/$(LIBRARY_NAME)$(LIBRARY_VERSION).pdb
 else
 LIBRARY		= $(OBJDIR)/lib$(LIBRARY_NAME)$(LIBRARY_VERSION)_s.$(LIB_SUFFIX)
@@ -340,6 +340,10 @@
 else	# AIX 4.1
 ifeq ($(NS_USE_GCC)_$(OS_ARCH),_WINNT)
 	$(LINK_DLL) -MAP $(DLLBASE) $(DLL_LIBS) $(EXTRA_LIBS) $(OBJS) $(RES)
+	@if test -f $@.manifest; then \
+		mt.exe -NOLOGO -MANIFEST $@.manifest -OUTPUTRESOURCE:$@\;2; \
+		rm -f $@.manifest; \
+	fi
 else
 ifeq ($(MOZ_OS2_TOOLS),VACPP)
 	$(LINK_DLL) $(DLLBASE) $(OBJS) $(OS_LIBS) $(EXTRA_LIBS) $(MAPFILE)
--- misc/mozilla/nsprpub/configure	2008-01-29 20:27:43.000000000 +0100
+++ misc/build/mozilla/nsprpub/configure	2008-08-14 16:22:21.000000000 +0200
@@ -2737,6 +2737,7 @@
 LIB_SUFFIX=a
 DLL_SUFFIX=so
 ASM_SUFFIX=s
+LIB_PREFIX=lib
 MKSHLIB='$(LD) $(DSO_LDOPTS) -o $@'
 PR_MD_ASFILES=
 PR_MD_CSRCS=
@@ -3475,7 +3476,7 @@
 EOF
 
     CFLAGS="$CFLAGS $(DSO_CFLAGS) -ansi -Wall"
-    MOZ_OBJFORMAT=`test -x /usr/bin/objformat && /usr/bin/objformat || echo aout`
+    MOZ_OBJFORMAT=`test -x /usr/bin/objformat && /usr/bin/objformat || echo elf`
     if test "$MOZ_OBJFORMAT" = "elf"; then
         DLL_SUFFIX=so
     else
@@ -3941,7 +3942,7 @@
         CC="$CC -mno-cygwin"
         CXX="$CXX -mno-cygwin"
         DLL_SUFFIX=dll
-        MKSHLIB='$(CC) -shared -Wl,--export-all-symbols -Wl,--out-implib -Wl,$(IMPORT_LIBRARY) $(DLLBASE) -o $(subst $(OBJDIR)/,,$(SHARED_LIBRARY))'
+        MKSHLIB='$(CC) -shared -Wl,--enable-runtime-pseudo-reloc -Wl,--export-all-symbols -Wl,--out-implib -Wl,$(IMPORT_LIBRARY) $(DLLBASE) -o $(subst $(OBJDIR)/,,$(SHARED_LIBRARY))'
         RC=$WINDRES
         # Use temp file for windres (bug 213281)
         RCFLAGS='-O coff --use-temp-file'
@@ -3958,6 +3959,7 @@
         OBJ_SUFFIX=obj
         LIB_SUFFIX=lib
         DLL_SUFFIX=dll
+        LIB_PREFIX=
 
         # Determine compiler version
         CC_VERSION=`"${CC}" -v 2>&1 | grep Version | sed -e 's|.* Version ||' -e 's| .*||'`
@@ -5766,6 +5768,7 @@
     CC="\$(CYGWIN_WRAPPER) $CC"
     CXX="\$(CYGWIN_WRAPPER) $CXX"
     RC="\$(CYGWIN_WRAPPER) $RC"
+    LD="\$(CYGWIN_WRAPPER) $LD"
     ;;
 esac
 
@@ -6127,6 +6130,7 @@
 s%@LIB_SUFFIX@%$LIB_SUFFIX%g
 s%@DLL_SUFFIX@%$DLL_SUFFIX%g
 s%@ASM_SUFFIX@%$ASM_SUFFIX%g
+s%@LIB_PREFIX@%$LIB_PREFIX%g
 s%@MKSHLIB@%$MKSHLIB%g
 s%@DSO_CFLAGS@%$DSO_CFLAGS%g
 s%@DSO_LDOPTS@%$DSO_LDOPTS%g
--- misc/mozilla/nsprpub/configure.in	2008-01-29 20:27:44.000000000 +0100
+++ misc/build/mozilla/nsprpub/configure.in	2008-08-14 16:22:21.000000000 +0200
@@ -1137,7 +1137,7 @@
     AC_DEFINE(HAVE_BSD_FLOCK)
     AC_DEFINE(HAVE_SOCKLEN_T)
     CFLAGS="$CFLAGS $(DSO_CFLAGS) -ansi -Wall"
-    MOZ_OBJFORMAT=`test -x /usr/bin/objformat && /usr/bin/objformat || echo aout`
+    MOZ_OBJFORMAT=`test -x /usr/bin/objformat && /usr/bin/objformat || echo elf`
     if test "$MOZ_OBJFORMAT" = "elf"; then
         DLL_SUFFIX=so
     else
--- misc/mozilla/nsprpub/lib/ds/Makefile.in	2006-12-22 14:47:17.000000000 +0100
+++ misc/build/mozilla/nsprpub/lib/ds/Makefile.in	2008-08-14 16:22:21.000000000 +0200
@@ -79,18 +79,22 @@
 OS_LIBS = -lc
 endif
 
+ifeq ($(OS_ARCH),Linux)
+MKSHLIB += -Wl,-rpath,\$$ORIGIN:\$$ORIGIN/../ure-link/lib
+endif
+
 ifeq ($(OS_ARCH),SunOS)
 OS_LIBS = -lc
 MAPFILE = $(OBJDIR)/pldsmap.sun
 GARBAGE += $(MAPFILE)
 ifdef NS_USE_GCC
 ifdef GCC_USE_GNU_LD
-MKSHLIB += -Wl,--version-script,$(MAPFILE)
+MKSHLIB += -Wl,--version-script,$(MAPFILE) -Wl,-rpath,\$$ORIGIN:\$$ORIGIN/../ure-link/lib
 else
-MKSHLIB += -Wl,-M,$(MAPFILE)
+MKSHLIB += -Wl,-M,$(MAPFILE) -Wl,-R,'$$ORIGIN'
 endif
 else
-MKSHLIB += -M $(MAPFILE)
+MKSHLIB += -M $(MAPFILE) -Wl,-R,'$$ORIGIN'
 endif
 # The -R '$ORIGIN' linker option instructs this library to search for its
 # dependencies in the same directory where it resides.
--- misc/mozilla/nsprpub/lib/libc/src/Makefile.in	2006-12-22 14:47:17.000000000 +0100
+++ misc/build/mozilla/nsprpub/lib/libc/src/Makefile.in	2008-08-14 16:22:21.000000000 +0200
@@ -89,18 +89,22 @@
 OS_LIBS = -lc
 endif
 
+ifeq ($(OS_ARCH),Linux)
+MKSHLIB += -Wl,-rpath,\$$ORIGIN:\$$ORIGIN/../ure-link/lib
+endif
+
 ifeq ($(OS_ARCH),SunOS)
 OS_LIBS = -lc
 MAPFILE = $(OBJDIR)/plcmap.sun
 GARBAGE += $(MAPFILE)
 ifdef NS_USE_GCC
 ifdef GCC_USE_GNU_LD
-MKSHLIB += -Wl,--version-script,$(MAPFILE)
+MKSHLIB += -Wl,--version-script,$(MAPFILE) -Wl,-rpath,\$$ORIGIN:\$$ORIGIN/../ure-link/lib
 else
-MKSHLIB += -Wl,-M,$(MAPFILE)
+MKSHLIB += -Wl,-M,$(MAPFILE) -Wl,-R,'$$ORIGIN'
 endif
 else
-MKSHLIB += -M $(MAPFILE)
+MKSHLIB += -M $(MAPFILE) -Wl,-R,'$$ORIGIN'
 endif
 # The -R '$ORIGIN' linker option instructs this library to search for its
 # dependencies in the same directory where it resides.
--- misc/mozilla/nsprpub/pr/src/misc/prnetdb.c	2006-12-22 14:47:27.000000000 +0100
+++ misc/build/mozilla/nsprpub/pr/src/misc/prnetdb.c	2008-08-14 16:22:21.000000000 +0200
@@ -113,7 +113,8 @@
 #define _PR_HAVE_5_ARG_GETPROTO_R
 #endif
 
-#if (defined(LINUX) && defined(__GLIBC__) && __GLIBC__ >= 2)
+#if (defined(LINUX) && defined(__GLIBC__) && __GLIBC__ >= 2) || \
+	(defined(__FreeBSD__) && __FreeBSD_version > 601103)
 #define _PR_HAVE_GETPROTO_R
 #define _PR_HAVE_5_ARG_GETPROTO_R
 #endif
--- misc/mozilla/security/coreconf/FreeBSD.mk	2006-12-22 14:48:06.000000000 +0100
+++ misc/build/mozilla/security/coreconf/FreeBSD.mk	2008-08-14 16:22:21.000000000 +0200
@@ -65,7 +65,7 @@
 
 ARCH			= freebsd
 
-MOZ_OBJFORMAT		:= $(shell test -x /usr/bin/objformat && /usr/bin/objformat || echo aout)
+MOZ_OBJFORMAT		:= $(shell test -x /usr/bin/objformat && /usr/bin/objformat || echo elf)
 
 ifeq ($(MOZ_OBJFORMAT),elf)
 DLL_SUFFIX		= so
--- misc/mozilla/security/coreconf/Linux.mk	2006-12-22 14:48:06.000000000 +0100
+++ misc/build/mozilla/security/coreconf/Linux.mk	2008-08-18 10:16:15.000000000 +0200
@@ -139,7 +139,7 @@
 
 ifeq ($(OS_RELEASE),2.0)
 	OS_REL_CFLAGS	+= -DLINUX2_0
-	MKSHLIB		= $(CC) -shared -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
+	MKSHLIB		= $(CC) $(DSO_LDOPTS) -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
 	ifdef MAPFILE
 		MKSHLIB += -Wl,--version-script,$(MAPFILE)
 	endif
@@ -166,6 +166,7 @@
 
 DSO_CFLAGS		= -fPIC
 DSO_LDOPTS		= -shared $(ARCHFLAG)
+DSO_LDOPTS		+= -Wl,-rpath,\$$ORIGIN:\$$ORIGIN/../ure-link/lib
 DSO_LDFLAGS		=
 LDFLAGS			+= $(ARCHFLAG)
 
--- misc/mozilla/security/coreconf/SunOS5.mk	2008-06-16 00:22:15.000000000 +0200
+++ misc/build/mozilla/security/coreconf/SunOS5.mk	2008-08-14 16:22:21.000000000 +0200
@@ -161,12 +161,14 @@
 
 # ld options:
 # -G: produce a shared object
+# -R '$ORIGIN': search for dependencies in same directory
 # -z defs: no unresolved symbols allowed
 ifdef NS_USE_GCC
 ifeq ($(USE_64), 1)
 	DSO_LDOPTS += -m64
 endif
 	DSO_LDOPTS += -shared -h $(notdir $@)
+    DSO_LDOPTS += -Wl,-rpath,\$$ORIGIN:\$$ORIGIN/../ure-link/lib
 else
 ifeq ($(USE_64), 1)
 	ifeq ($(OS_TEST),i86pc)
@@ -176,6 +178,7 @@
 	endif
 endif
 	DSO_LDOPTS += -G -h $(notdir $@)
+    DSO_LDOPTS += -R '$$ORIGIN'
 endif
 DSO_LDOPTS += -z combreloc -z defs -z ignore
 
--- misc/mozilla/security/coreconf/WIN32.mk	2008-06-16 00:22:15.000000000 +0200
+++ misc/build/mozilla/security/coreconf/WIN32.mk	2008-08-18 16:04:59.000000000 +0200
@@ -43,24 +43,24 @@
 DEFAULT_COMPILER = cl
 
 ifdef NS_USE_GCC
-	CC           = gcc
-	CCC          = g++
-	LINK         = ld
-	AR           = ar
+	CC           = $(CYGWIN_WRAPPER) gcc
+	CCC          = $(CYGWIN_WRAPPER) g++
+	LINK         = $(CYGWIN_WRAPPER) ld
+	AR           = $(CYGWIN_WRAPPER) ar
 	AR          += cr $@
-	RANLIB       = ranlib
+	RANLIB       = $(CYGWIN_WRAPPER) ranlib
 	BSDECHO      = echo
-	RC           = windres.exe -O coff --use-temp-file
-	LINK_DLL      = $(CC) $(OS_DLLFLAGS) $(DLLFLAGS)
+	RC           = $(CYGWIN_WRAPPER) windres.exe -O coff --use-temp-file
+	LINK_DLL     = $(CYGWIN_WRAPPER)  $(CC) $(OS_DLLFLAGS) $(DLLFLAGS)
 else
-	CC           = cl
-	CCC          = cl
-	LINK         = link
-	AR           = lib
+	CC           = $(CYGWIN_WRAPPER) cl
+	CCC          = $(CYGWIN_WRAPPER) cl
+	LINK         = $(CYGWIN_WRAPPER) link
+	AR           = $(CYGWIN_WRAPPER) lib
 	AR          += -NOLOGO -OUT:"$@"
 	RANLIB       = echo
 	BSDECHO      = echo
-	RC           = rc.exe
+	RC           = $(CYGWIN_WRAPPER) rc.exe
 	MT           = mt.exe
 endif
 
@@ -69,7 +69,7 @@
 else
 NSINSTALL_DIR  = $(CORE_DEPTH)/coreconf/nsinstall
 endif
-NSINSTALL      = nsinstall
+NSINSTALL      = $(CYGWIN_WRAPPER) nsinstall
 
 MKDEPEND_DIR    = $(CORE_DEPTH)/coreconf/mkdepend
 MKDEPEND        = $(MKDEPEND_DIR)/$(OBJDIR_NAME)/mkdepend.exe
@@ -95,7 +95,7 @@
     # dllimport cannot be used as as a constant address.
     OS_CFLAGS += -mno-cygwin -mms-bitfields -mnop-fun-dllimport
     _GEN_IMPORT_LIB=-Wl,--out-implib,$(IMPORT_LIBRARY)
-    DLLFLAGS  += -mno-cygwin -o $@ -shared -Wl,--export-all-symbols $(if $(IMPORT_LIBRARY),$(_GEN_IMPORT_LIB))
+    DLLFLAGS  += -mno-cygwin -o $@ -shared -Wl,--enable-runtime-pseudo-reloc,--export-all-symbols $(if $(IMPORT_LIBRARY),$(_GEN_IMPORT_LIB))
     ifdef BUILD_OPT
 	OPTIMIZER  += -O2
 	DEFINES    += -UDEBUG -U_DEBUG -DNDEBUG
--- misc/mozilla/security/coreconf/WIN954.0.mk	2008-06-16 00:22:15.000000000 +0200
+++ misc/build/mozilla/security/coreconf/WIN954.0.mk	2008-08-14 16:22:21.000000000 +0200
@@ -72,3 +72,7 @@
 endif
 endif
 DEFINES += -DWIN95
+
+ifdef NS_USE_GCC
+NSPR31_LIB_PREFIX = lib
+endif
--- misc/mozilla/security/coreconf/command.mk	2008-06-16 00:22:15.000000000 +0200
+++ misc/build/mozilla/security/coreconf/command.mk	2008-08-19 09:58:11.000000000 +0200
@@ -45,7 +45,7 @@
 CCF           = $(CC) $(CFLAGS)
 LINK_DLL      = $(LINK) $(OS_DLLFLAGS) $(DLLFLAGS)
 LINK_EXE      = $(LINK) $(OS_LFLAGS) $(LFLAGS)
-CFLAGS        = $(OPTIMIZER) $(OS_CFLAGS) $(XP_DEFINE) $(DEFINES) $(INCLUDES) \
+CFLAGS        += $(OPTIMIZER) $(OS_CFLAGS) $(XP_DEFINE) $(DEFINES) $(INCLUDES) \
 		$(XCFLAGS)
 PERL          = perl
 RANLIB        = echo
--- misc/mozilla/security/coreconf/rules.mk	2008-06-16 00:22:15.000000000 +0200
+++ misc/build/mozilla/security/coreconf/rules.mk	2008-08-19 10:46:57.000000000 +0200
@@ -284,7 +284,7 @@
 $(PROGRAM): $(OBJS) $(EXTRA_LIBS)
 	@$(MAKE_OBJDIR)
 ifeq (,$(filter-out _WIN%,$(NS_USE_GCC)_$(OS_TARGET)))
-	$(MKPROG) $(subst /,\\,$(OBJS)) -Fe$@ -link $(LDFLAGS) $(subst /,\\,$(EXTRA_LIBS) $(EXTRA_SHARED_LIBS) $(OS_LIBS))
+	$(MKPROG) $(OBJS) -Fe$@ -link $(LDFLAGS) $(EXTRA_LIBS) $(EXTRA_SHARED_LIBS) $(OS_LIBS)
 ifdef MT
 	if test -f $@.manifest; then \
 		$(MT) -NOLOGO -MANIFEST $@.manifest -OUTPUTRESOURCE:$@\;1; \
@@ -305,11 +305,7 @@
 $(LIBRARY): $(OBJS)
 	@$(MAKE_OBJDIR)
 	rm -f $@
-ifeq (,$(filter-out _WIN%,$(NS_USE_GCC)_$(OS_TARGET)))
-	$(AR) $(subst /,\\,$(OBJS))
-else
 	$(AR) $(OBJS)
-endif
 	$(RANLIB) $@
 
 
@@ -344,7 +340,7 @@
 ifdef NS_USE_GCC
 	$(LINK_DLL) $(OBJS) $(SUB_SHLOBJS) $(EXTRA_LIBS) $(EXTRA_SHARED_LIBS) $(OS_LIBS) $(LD_LIBS) $(RES)
 else
-	$(LINK_DLL) -MAP $(DLLBASE) $(subst /,\\,$(OBJS) $(SUB_SHLOBJS) $(EXTRA_LIBS) $(EXTRA_SHARED_LIBS) $(OS_LIBS) $(LD_LIBS) $(RES))
+	$(LINK_DLL) -MAP $(DLLBASE) $(OBJS) $(SUB_SHLOBJS) $(EXTRA_LIBS) $(EXTRA_SHARED_LIBS) $(OS_LIBS) $(LD_LIBS) $(RES)
 ifdef MT
 	if test -f $@.manifest; then \
 		$(MT) -NOLOGO -MANIFEST $@.manifest -OUTPUTRESOURCE:$@\;2; \
@@ -429,15 +425,15 @@
 endif
 endif
 
-core_abspath = $(if $(findstring :,$(1)),$(1),$(if $(filter /%,$(1)),$(1),$(PWD)/$(1)))
+mozabspath = $(if $(findstring :,$(1)),$(1),$(if $(filter /%,$(1)),$(1),$(PWD)/$(1)))
 
 $(OBJDIR)/$(PROG_PREFIX)%$(OBJ_SUFFIX): %.c
 	@$(MAKE_OBJDIR)
 ifdef USE_NT_C_SYNTAX
-	$(CC) -Fo$@ -c $(CFLAGS) $(call core_abspath,$<)
+	$(CC) -Fo$@ -c $(CFLAGS) $(call mozabspath,$<)
 else
 ifdef NEED_ABSOLUTE_PATH
-	$(CC) -o $@ -c $(CFLAGS) $(call core_abspath,$<)
+	$(CC) -o $@ -c $(CFLAGS) $(call mozabspath,$<)
 else
 	$(CC) -o $@ -c $(CFLAGS) $<
 endif
@@ -445,10 +441,10 @@
 
 $(PROG_PREFIX)%$(OBJ_SUFFIX): %.c
 ifdef USE_NT_C_SYNTAX
-	$(CC) -Fo$@ -c $(CFLAGS) $(call core_abspath,$<)
+	$(CC) -Fo$@ -c $(CFLAGS) $(call mozabspath,$<)
 else
 ifdef NEED_ABSOLUTE_PATH
-	$(CC) -o $@ -c $(CFLAGS) $(call core_abspath,$<)
+	$(CC) -o $@ -c $(CFLAGS) $(call mozabspath,$<)
 else
 	$(CC) -o $@ -c $(CFLAGS) $<
 endif
@@ -477,10 +473,10 @@
 $(OBJDIR)/$(PROG_PREFIX)%: %.cpp
 	@$(MAKE_OBJDIR)
 ifdef USE_NT_C_SYNTAX
-	$(CCC) -Fo$@ -c $(CFLAGS) $(call core_abspath,$<)
+	$(CCC) -Fo$@ -c $(CFLAGS) $(call mozabspath,$<)
 else
 ifdef NEED_ABSOLUTE_PATH
-	$(CCC) -o $@ -c $(CFLAGS) $(call core_abspath,$<)
+	$(CCC) -o $@ -c $(CFLAGS) $(call mozabspath,$<)
 else
 	$(CCC) -o $@ -c $(CFLAGS) $<
 endif
@@ -501,10 +497,10 @@
 	rm -f $(OBJDIR)/t_$*.cc
 else
 ifdef USE_NT_C_SYNTAX
-	$(CCC) -Fo$@ -c $(CFLAGS) $(call core_abspath,$<)
+	$(CCC) -Fo$@ -c $(CFLAGS) $(call mozabspath,$<)
 else
 ifdef NEED_ABSOLUTE_PATH
-	$(CCC) -o $@ -c $(CFLAGS) $(call core_abspath,$<)
+	$(CCC) -o $@ -c $(CFLAGS) $(call mozabspath,$<)
 else
 	$(CCC) -o $@ -c $(CFLAGS) $<
 endif
--- misc/mozilla/security/manager/Makefile.in	2008-06-16 00:23:29.000000000 +0200
+++ misc/build/mozilla/security/manager/Makefile.in	2008-08-14 16:22:21.000000000 +0200
@@ -123,8 +123,11 @@
 ifdef CYGDRIVE_MOUNT
 ABS_DIST := $(shell cygpath -w $(ABS_DIST) | sed -e 's|\\|/|g')
 endif
+ifneq (,$(filter cygwin%,$(host_os)))
+ABS_DIST := $(shell cygpath -u $(ABS_DIST))
+endif
 ifneq (,$(filter mingw%,$(host_os)))
-ABS_DIST := $(shell cd $(DIST) && pwd -W)
+ABS_DIST := $(shell cygpath -u $(ABS_DIST))
 endif
 endif
 NSPR_INCLUDE_DIR = $(firstword $(filter -I%,$(NSPR_CFLAGS)))
@@ -172,6 +175,7 @@
 endif
 ifeq ($(OS_ARCH),WINNT)
 DEFAULT_GMAKE_FLAGS += OS_TARGET=WIN95
+DEFAULT_GMAKE_FLAGS += CYGWIN_WRAPPER=@CYGWIN_WRAPPER@
 ifdef MOZ_DEBUG
 ifndef MOZ_NO_DEBUG_RTL
 DEFAULT_GMAKE_FLAGS += USE_DEBUG_RTL=1
--- misc/mozilla/security/nss/cmd/shlibsign/Makefile	2007-02-16 03:16:24.000000000 +0100
+++ misc/build/mozilla/security/nss/cmd/shlibsign/Makefile	2009-02-12 15:42:13.033408000 +0100
@@ -86,17 +86,42 @@
 
 include ../platrules.mk
 
-SRCDIR = $(call core_abspath,.)
-
+ifeq ($(OS_TARGET), Darwin)
+	SRCDIR = .
+else
+ifeq ($(OS_TARGET), Linux)
+	SRCDIR = .
+else
+	SRCDIR = .
+endif
+endif
 %.chk: %.$(DLL_SUFFIX) 
 ifeq ($(OS_TARGET), OS2)
 	cd $(OBJDIR) ; cmd.exe /c $(SRCDIR)/sign.cmd $(DIST) \
 	$(call core_abspath,$(OBJDIR)) $(OS_TARGET) \
 	$(call core_abspath,$(NSPR_LIB_DIR)) $(call core_abspath,$<)
 else
-	cd $(OBJDIR) ; sh $(SRCDIR)/sign.sh $(call core_abspath,$(DIST)) \
-	$(call core_abspath,$(OBJDIR)) $(OS_TARGET) \
-	$(call core_abspath,$(NSPR_LIB_DIR)) $(call core_abspath,$<)
+ifeq ($(OS_TARGET), WIN95)
+	cd $(SRCDIR) ; sh $(CYGWIN_WRAPPER) ./sign.sh $(DIST) \
+        $(OBJDIR) $(OS_TARGET) \
+        $(NSPR_LIB_DIR) $<
+else
+ifeq ($(OS_TARGET), Darwin)
+	cd $(SRCDIR) ; sh ./sign.sh $(DIST) \
+	$(OBJDIR) $(OS_TARGET) \
+	$(NSPR_LIB_DIR) $<
+else
+ifeq ($(OS_TARGET), Linux)
+	cd $(SRCDIR) ; sh ./sign.sh $(DIST) \
+	$(OBJDIR) $(OS_TARGET) \
+	$(NSPR_LIB_DIR) $<
+else
+	cd $(SRCDIR) ; sh ./sign.sh $(DIST) \
+	$(OBJDIR) $(OS_TARGET) \
+	$(NSPR_LIB_DIR) $<
+endif
+endif
+endif
 endif
 
 libs install :: $(CHECKLOC)
--- misc/mozilla/security/nss/lib/ckfw/builtins/config.mk	2005-01-20 03:25:46.000000000 +0100
+++ misc/build/mozilla/security/nss/lib/ckfw/builtins/config.mk	2008-08-14 16:22:21.000000000 +0200
@@ -63,9 +63,4 @@
 DSO_LDOPTS = -bundle
 endif
 
-ifeq ($(OS_TARGET),SunOS)
-# The -R '$ORIGIN' linker option instructs this library to search for its
-# dependencies in the same directory where it resides.
-MKSHLIB += -R '$$ORIGIN'
-endif
 
--- misc/mozilla/security/nss/lib/freebl/Makefile	2008-06-16 00:22:09.000000000 +0200
+++ misc/build/mozilla/security/nss/lib/freebl/Makefile	2008-08-18 14:31:08.000000000 +0200
@@ -199,10 +199,6 @@
 endif
 
 ifeq ($(OS_TARGET),SunOS)
-
-# The -R '$ORIGIN' linker option instructs this library to search for its
-# dependencies in the same directory where it resides.
-MKSHLIB += -R '$$ORIGIN'
 ifdef NS_USE_GCC
     ifdef GCC_USE_GNU_LD
 	MKSHLIB += -Wl,-Bsymbolic,-z,now,-z,text
@@ -210,7 +206,7 @@
 	MKSHLIB += -Wl,-B,symbolic,-z,now,-z,text
     endif # GCC_USE_GNU_LD
 else
-    MKSHLIB += -B symbolic -z now -z text
+    MKSHLIB += -z now -z text
 endif # NS_USE_GCC
 
 # Sun's WorkShop defines v8, v8plus and v9 architectures.
--- misc/mozilla/security/nss/lib/nss/config.mk	2006-12-22 14:47:56.000000000 +0100
+++ misc/build/mozilla/security/nss/lib/nss/config.mk	2008-08-19 17:07:42.000000000 +0200
@@ -113,12 +113,10 @@
 # The -R '$ORIGIN' linker option instructs this library to search for its
 # dependencies in the same directory where it resides.
 ifeq ($(USE_64), 1)
-MKSHLIB += -R '$$ORIGIN:/usr/lib/mps/secv1/64:/usr/lib/mps/64'
+DSO_LDOPTS += -R '$$ORIGIN:/usr/lib/mps/secv1/64:/usr/lib/mps/64'
 else
-MKSHLIB += -R '$$ORIGIN:/usr/lib/mps/secv1:/usr/lib/mps'
+DSO_LDOPTS += -R '$$ORIGIN:/usr/lib/mps/secv1:/usr/lib/mps'
 endif
-else
-MKSHLIB += -R '$$ORIGIN'
 endif
 endif
 
@@ -127,9 +125,9 @@
 # pa-risc
 ifeq ($(USE_64), 1)
 MKSHLIB += +b '$$ORIGIN'
-endif
-endif
-endif
+endif # USE_64
+endif # OS_TEST
+endif # OS_ARCH
 
 ifeq (,$(filter-out WINNT WIN95,$(OS_TARGET)))
 ifndef NS_USE_GCC
--- misc/mozilla/security/nss/lib/nss/nss.def	2008-06-16 00:22:10.000000000 +0200
+++ misc/build/mozilla/security/nss/lib/nss/nss.def	2008-08-14 16:22:21.000000000 +0200
@@ -61,6 +61,7 @@
 CERT_CheckCertValidTimes;
 CERT_CreateCertificateRequest;
 CERT_ChangeCertTrust;
+CERT_DecodeDERCertificate;
 CERT_DecodeDERCrl;
 CERT_DestroyCertificateRequest;
 CERT_DestroyCertList;
--- misc/mozilla/security/nss/lib/smime/config.mk	2006-12-22 14:48:00.000000000 +0100
+++ misc/build/mozilla/security/nss/lib/smime/config.mk	2008-08-19 17:01:53.000000000 +0200
@@ -92,8 +92,3 @@
 	../pkcs7 \
 	$(NULL)
 
-ifeq ($(OS_TARGET),SunOS)
-# The -R '$ORIGIN' linker option instructs this library to search for its
-# dependencies in the same directory where it resides.
-MKSHLIB += -R '$$ORIGIN'
-endif
--- misc/mozilla/security/nss/lib/softoken/config.mk	2006-12-22 14:48:00.000000000 +0100
+++ misc/build/mozilla/security/nss/lib/softoken/config.mk	2008-08-20 10:36:17.000000000 +0200
@@ -87,13 +87,6 @@
 	$(NULL)
 endif
 
-ifeq ($(OS_TARGET),SunOS)
-# The -R '$ORIGIN' linker option instructs this library to search for its
-# dependencies in the same directory where it resides.
-MKSHLIB += -R '$$ORIGIN'
-OS_LIBS += -lbsm 
-endif
-
 ifeq ($(OS_TARGET),WINCE)
 DEFINES += -DDBM_USING_NSPR
 endif
--- misc/mozilla/security/nss/lib/ssl/config.mk	2008-06-16 00:22:12.000000000 +0200
+++ misc/build/mozilla/security/nss/lib/ssl/config.mk	2008-08-19 17:03:03.000000000 +0200
@@ -116,13 +116,6 @@
 EXTRA_SHARED_LIBS += -dylib_file @executable_path/libsoftokn3.dylib:$(DIST)/lib/libsoftokn3.dylib
 endif
 
-ifeq ($(OS_TARGET),SunOS)
-# The -R '$ORIGIN' linker option instructs this library to search for its
-# dependencies in the same directory where it resides.
-MKSHLIB += -R '$$ORIGIN'
-#EXTRA_SHARED_LIBS += -ldl -lrt -lc -z defs
-endif
-
 endif
 
 # indicates dependency on freebl static lib
--- misc/mozilla/webshell/tests/viewer/Makefile.in	2006-06-17 18:27:10.000000000 +0200
+++ misc/build/mozilla/webshell/tests/viewer/Makefile.in	2008-08-14 16:22:21.000000000 +0200
@@ -181,7 +181,7 @@
 GTK_LIBS		= unix/gtk/libviewer_gtk_s.a -lgtksuperwin $(XP_LIBS) $(MOZ_GTK_LDFLAGS)
 
 XP_DIST_DEP_LIBS	:= $(filter-out -L$(DIST)/bin -L$(DIST)/lib, $(XP_DIST_LIBS))
-XP_DIST_DEP_LIBS	:= $(wildcard $(addprefix $(DIST)/,$(patsubst -l%,bin/$(LIB_PREFIX)%$(DLL_SUFFIX),$(XP_DIST_DEP_LIBS:-l%_s=lib/lib%_s)))*)
+XP_DIST_DEP_LIBS	:= $(wildcard $(addprefix $(DIST)/,$(patsubst -l%,bin/$(DLL_PREFIX)%$(DLL_SUFFIX),$(XP_DIST_DEP_LIBS:-l%_s=lib/lib%_s)))*)
 
 EXTRA_DEPS		= \
 			$(XP_DIST_DEP_LIBS) \
--- misc/mozilla/xpcom/reflect/xptinfo/public/xptinfo.h	2004-04-18 16:18:20.000000000 +0200
+++ misc/build/mozilla/xpcom/reflect/xptinfo/public/xptinfo.h	2008-08-14 16:22:21.000000000 +0200
@@ -132,7 +132,7 @@
         }
 
     PRBool IsArray() const
-        {return (PRBool) TagPart() == T_ARRAY;}
+        {return (PRBool) (TagPart() == T_ARRAY);}
 
     // 'Dependent' means that params of this type are dependent upon other 
     // params. e.g. an T_INTERFACE_IS is dependent upon some other param at 
@@ -152,7 +152,7 @@
     uint8 TagPart() const
         {return (uint8) (flags & XPT_TDP_TAGMASK);}
 
-    enum
+    enum _xpttype
     {
         T_I8                = TD_INT8             ,
         T_I16               = TD_INT16            ,
--- misc/mozilla/xpfe/bootstrap/Makefile.in	2007-10-08 21:09:58.000000000 +0200
+++ misc/build/mozilla/xpfe/bootstrap/Makefile.in	2008-08-18 14:10:04.000000000 +0200
@@ -115,11 +115,14 @@
 
 include $(topsrcdir)/config/config.mk
 
+# reduce prerequisites by disabling mozilla binary
+ifndef DISABLE_MOZ_EXECUTABLE
 ifeq ($(USE_SHORT_LIBNAME),1)
 PROGRAM		= $(MOZ_APP_NAME)$(BIN_SUFFIX)
 else
 PROGRAM		= $(MOZ_APP_NAME)-bin$(BIN_SUFFIX)
 endif
+endif
 
 # Force applications to be built non-statically
 # when building the mozcomps meta component
@@ -491,6 +494,7 @@
 APP_NAME = $(MOZ_APP_DISPLAYNAME)
 endif
 
+ifdef PROGRAM
 libs:: $(PROGRAM)
 	mkdir -p $(DIST)/$(APP_NAME).app/Contents/MacOS
 	rsync -a --exclude CVS --exclude "*.in" $(srcdir)/macbuild/Contents $(DIST)/$(APP_NAME).app
@@ -505,6 +509,7 @@
 	rsync -a --copy-unsafe-links $(DIST)/package/PrintPDE.plugin $(DIST)/$(APP_NAME).app/Contents/Plug-Ins
 	cp -RL $(DIST)/package/mozillaSuite.rsrc $(DIST)/$(APP_NAME).app/Contents/Resources/$(PROGRAM).rsrc
 	echo -n APPLMOZZ > $(DIST)/$(APP_NAME).app/Contents/PkgInfo
+endif
 
 clean clobber::
 	rm -rf $(DIST)/$(APP_NAME).app
--- misc/mozilla/directory/c-sdk/ldap/libraries/libiutil/Makefile.in	2006-02-03 15:44:41.000000000 +0100
+++ misc/build/mozilla/directory/c-sdk/ldap/libraries/libiutil/Makefile.in	2011-09-07 10:45:16.000000000 +0200
@@ -89,12 +89,9 @@
 	-e "s|%VERSION%|$${v}|" \
 	< Version.c > $@)
 
-export::    $(OBJDEST) $(LIBDIR) $(OBJS) $(LIBIUTIL)
+export::    $(OBJDEST) $(OBJS) $(LIBIUTIL)
 
-$(LIBDIR):
-	$(MKDIR) $(LIBDIR)
-
-$(LIBIUTIL): $(OBJS) $(LIBDIR)
+$(LIBIUTIL): $(OBJS)
 	@echo ======= making $(LIBIUTIL)
 ifdef SO_FILES_TO_REMOVE
 	-$(RM) $(SO_FILES_TO_REMOVE)
--- misc/mozilla/directory/c-sdk/ldap/libraries/liblber/Makefile.in	2006-02-03 15:44:41.000000000 +0100
+++ misc/build/mozilla/directory/c-sdk/ldap/libraries/liblber/Makefile.in	2011-09-07 10:45:02.000000000 +0200
@@ -79,12 +79,9 @@
 	-e "s|%VERSION%|$${v}|" \
 	< Version.c > $@)
 
-export::    $(OBJDEST) $(LIBDIR) $(OBJS) $(LIBLBER)
+export::    $(OBJDEST) $(OBJS) $(LIBLBER)
 
-$(LIBDIR):
-	$(MKDIR) $(LIBDIR)
-
-$(LIBLBER): $(OBJS) $(LIBDIR)
+$(LIBLBER): $(OBJS)
 	@echo ======= making $(LIBLBER)
 ifdef SO_FILES_TO_REMOVE
 	-$(RM) $(SO_FILES_TO_REMOVE)
--- misc/mozilla/directory/c-sdk/ldap/libraries/libldap/Makefile.in	2011-09-07 10:53:57.000000000 +0200
+++ misc/build/mozilla/directory/c-sdk/ldap/libraries/libldap/Makefile.in	2011-09-07 10:44:45.000000000 +0200
@@ -279,13 +279,13 @@
 	< Version.c > $@)
 
 # Set the default sources for the export target
-EXPDEPS = $(OBJDIR_NAME) $(LIBDIR) $(OBJS) $(LIBLDAP) $(DLLLDAP)
+EXPDEPS = $(OBJDIR_NAME) $(OBJS) $(LIBLDAP) $(DLLLDAP)
 # Remove the LIB source if on win32 and using MSVC
 # This avoids problems with -jX builds where 'link' will make both the
 # .dll and .lib files in one pass
 ifeq ($(OS_ARCH), WINNT)
 ifeq ($(LD),link)
-EXPDEPS = $(OBJDIR_NAME) $(LIBDIR) $(OBJS) $(DLLLDAP)
+EXPDEPS = $(OBJDIR_NAME) $(OBJS) $(DLLLDAP)
 endif
 endif
 
@@ -294,10 +294,7 @@
 ltest::	$(LIBLDAP) test.o
 		$(LINK_EXE) test.o
 
-$(LIBDIR):
-	$(MKDIR) $(LIBDIR)
-
-$(LIBLDAP): $(OBJS) $(LIBDIR) $(LDAP_EXPORT_DEFS)
+$(LIBLDAP): $(OBJS) $(LDAP_EXPORT_DEFS)
 	@echo ======= making $(LIBLDAP)
 ifdef SO_FILES_TO_REMOVE
 	-$(RM) $(SO_FILES_TO_REMOVE)
@@ -314,7 +311,7 @@
 endif
 endif
 
-$(DLLLDAP): $(OBJS) $(LIBDIR) $(LDAP_EXPORT_DEFS)
+$(DLLLDAP): $(OBJS) $(LDAP_EXPORT_DEFS)
 	@echo ======= making $(DLLLDAP)
 ifdef SO_FILES_TO_REMOVE
 	-$(RM) $(SO_FILES_TO_REMOVE)
--- misc/mozilla/directory/c-sdk/ldap/libraries/libldif/Makefile.in	2006-02-03 15:44:49.000000000 +0100
+++ misc/build/mozilla/directory/c-sdk/ldap/libraries/libldif/Makefile.in	2011-09-07 10:44:15.000000000 +0200
@@ -77,12 +77,9 @@
 	-e "s|%VERSION%|$${v}|" \
 	< Version.c > $@)
 
-export::    $(OBJDEST) $(LIBDIR) $(OBJS) $(LIBLDIF)
+export::    $(OBJDEST) $(OBJS) $(LIBLDIF)
 
-$(LIBDIR):
-	$(MKDIR) $(LIBDIR)
-
-$(LIBLDIF): $(OBJS) $(LIBDIR)
+$(LIBLDIF): $(OBJS)
 	@echo ======= making $(LIBLDIF)
 ifdef SO_FILES_TO_REMOVE
 	-$(RM) $(SO_FILES_TO_REMOVE)
--- misc/mozilla/directory/c-sdk/ldap/libraries/libprldap/Makefile.in	2011-09-07 10:53:57.000000000 +0200
+++ misc/build/mozilla/directory/c-sdk/ldap/libraries/libprldap/Makefile.in	2011-09-07 10:43:59.000000000 +0200
@@ -201,12 +201,9 @@
 	-e "s|%VERSION%|$${v}|" \
 	< Version.c > $@)
 
-export::    $(OBJDEST) $(LIBDIR) $(OBJS) $(DLLPRLDAP)
+export::    $(OBJDEST) $(OBJS) $(DLLPRLDAP)
 
-$(LIBDIR):
-	$(MKDIR) $(LIBDIR)
-
-$(LIBPRLDAP): $(OBJS) $(LIBDIR) $(PRLDAP_EXPORT_DEFS)
+$(LIBPRLDAP): $(OBJS) $(PRLDAP_EXPORT_DEFS)
 	@echo ======= making $(LIBPRLDAP)
 ifdef SO_FILES_TO_REMOVE
 	-$(RM) $(SO_FILES_TO_REMOVE)
@@ -219,7 +216,7 @@
 	$(LINK_LIB) $(EXTRA_LIBS)
 endif
 
-$(DLLPRLDAP): $(OBJS) $(LIBDIR) $(PRLDAP_EXPORT_DEFS)
+$(DLLPRLDAP): $(OBJS) $(PRLDAP_EXPORT_DEFS)
 	@echo ======= making $(DLLPRLDAP)
 ifdef SO_FILES_TO_REMOVE
 	-$(RM) $(SO_FILES_TO_REMOVE)
--- misc/mozilla/directory/c-sdk/ldap/libraries/libssldap/Makefile.in	2011-09-07 10:53:57.000000000 +0200
+++ misc/build/mozilla/directory/c-sdk/ldap/libraries/libssldap/Makefile.in	2011-09-07 10:42:48.000000000 +0200
@@ -214,19 +214,16 @@
 	-e "s|%VERSION%|$${v}|" \
 	< Version.c > $@)
 
-export::    $(OBJDEST) $(LIBDIR) $(OBJS) $(DLLSSLDAP)
+export::    $(OBJDEST) $(OBJS) $(DLLSSLDAP)
 
-$(LIBDIR):
-	$(MKDIR) $(LIBDIR)
-
-$(LIBSSLDAP): $(OBJS) $(LIBDIR) $(SSLDAP_EXPORT_DEFS)
+$(LIBSSLDAP): $(OBJS) $(SSLDAP_EXPORT_DEFS)
 	@echo ======= making $(LIBSSLDAP)
  ifdef SO_FILES_TO_REMOVE
 	-$(RM) $(SO_FILES_TO_REMOVE)
  endif
 	$(LINK_LIB) $(EXTRA_LIBS)
 
-$(DLLSSLDAP): $(OBJS) $(LIBDIR) $(SSLDAP_EXPORT_DEFS)
+$(DLLSSLDAP): $(OBJS) $(SSLDAP_EXPORT_DEFS)
 	@echo ======= making $(DLLSSLDAP)
 ifdef SO_FILES_TO_REMOVE
 	-$(RM) $(SO_FILES_TO_REMOVE)
